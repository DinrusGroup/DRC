/// Author: Aziz Köksal
/// License: GPL3
/// $(Maturity average)
module SettingsLoader;

import drc.ast.Node,
       drc.ast.Declarations,
       drc.ast.Expressions;
import drc.semantic.Module,
       drc.semantic.Pass1,
       drc.semantic.Symbol,
       drc.semantic.Symbols;
import drc.Messages;
import drc.Diagnostics;
import drc.Compilation;
import Settings;
import common;

import tango.io.FilePath;
import tango.sys.Environment;

/// Загружает настройки из файла модуля Ди.
abstract class ЗагрузчикНастроек
{
  Диагностика диаг; /// Собирает сообщения об ошибках.
  Модуль мод; /// Текущий модуль.

  this(Диагностика диаг)
  {
    this.диаг = диаг;
  }

  /// Создает отчёт об ошибках.
  /// Параметры:
  ///   сема = в которой произошла ошибка.
  ///   форматирСооб = сообщение об ошибке.
  проц  ошибка(Сема* сема, сим[] форматирСооб, ...)
  {
    auto положение = сема.дайПоложениеОшибки();
    auto сооб = Формат(_arguments, _argptr, форматирСооб);
    диаг ~= new ОшибкаСемантики(положение, сооб);
  }

  T дайЗначение(T)(сим[] имя)
  {
    auto перм = мод.сыщи(имя);
    if (!перм) // Returning T.иниц instead of null, because dmd gives an ошибка.
      return ошибка(мод.перваяСема, "переменная '{}' не указана", имя), T.init;
    auto t = перм.узел.начало;
    if (!перм.Переменная_ли)
      return ошибка(t, "'{}' не является декларацией переменной", имя), T.init;
    auto значение = перм.в!(Переменная).значение;
    if (!значение)
      return ошибка(t, "у переменной '{}' не установлено значение", имя), T.init;
    T знач = значение.Является!(T); // Пробуй casting в T.
    if (!знач)
      ошибка(значение.начало, "значение '{}' должно быть типа {}", имя, T.stringof);
    return знач;
  }

  T перебросьВ(T)(Узел n)
  {
    if (auto результат = n.Является!(T))
      return результат;
    сим[] тип = T.stringof;
    (is(T == ТекстовоеВыражение) && (тип = "сим[]").ptr) ||
    (is(T == ВыражениеИницМассива) && (тип = "[]").ptr) ||
    (is(T == ЦелВыражение) && (тип = "цел"));
    ошибка(n.начало, "выражение не является типа {}", тип);
    return null;
  }

  проц  загрузи()
  {}
}

/// Загружает файл конфигурации drc.
class ЗагрузчикКонфиг : ЗагрузчикНастроек
{
  static ткст имяФайлаКонфиг = "drc.conf"; /// Имя файла конфигурации.
  ткст путьКЭкзе; /// Абсолютный путь к исполнимому коду drc.
  ткст папкаСЭкзе; /// Абсолютный путь к папке с исполнимым кодом drc.
  ткст папкаСДанными; /// Абсолютный путь к папке с данными drc.
  ткст путьДомой; /// Путь к домашней папке.

  this(Диагностика диаг)
  {
    super(диаг);
    this.путьДомой = Environment.get("HOME");
    this.путьКЭкзе = ДайПутьКИсполнимомуФайлу();
    this.папкаСЭкзе = (new FilePath(this.путьКЭкзе)).folder();
    Environment.set("BINDIR", this.папкаСЭкзе);
  }

  static ЗагрузчикКонфиг opCall(Диагностика диаг)
  {
    return new ЗагрузчикКонфиг(диаг);
  }

  static ткст раскройПеременные(ткст знач)
  {
    сим[] сделайТекст(сим* начало, сим* конец)
    {
      assert(начало && конец && начало <= конец);
      return начало[0 .. конец - начало];
    }

    сим[] результат;
    сим* p = знач.ptr, конец = p + знач.length;
    сим* началоКуска = p; // Points в the piece of the ткст after a переменная.

    while (p+3 < конец)
    {
      if (p[0] == '$' && p[1] == '{')
      {
        auto началоПеременной = p;
        while (p < конец && *p != '}')
          p++;
        if (p == конец)
          break; // Не раскрывать незаконченные переменные.
        результат ~= сделайТекст(началоКуска, началоПеременной);
        началоПеременной += 2; // Skip ${
        // Получить переменную среды и добавить её в результат.
        результат ~= Environment.get(сделайТекст(началоПеременной, p));
        началоКуска = p + 1; // Указывает на символ после '}'.
      }
      p++;
    }
    if (началоКуска < конец)
      результат ~= сделайТекст(началоКуска, конец);
    return результат;
  }

  проц  загрузи()
  {
    // Искать файл конфигурации.
    auto путьКФайлу = НайдиПутьКФайлуКонфигурации();
    if (путьКФайлу is null)
    {
      диаг ~= new drc.Information.Ошибка(new Положение("",0),
        "файл конфигурации "~имяФайлаКонфиг~" найти не удалось.");
      return;
    }
    // Загрузить файл как модуль Ди.
    мод = new Модуль(путьКФайлу, диаг);
    мод.разбор();

    if (мод.естьОшибки)
      return;

    auto контекст = new КонтекстКомпиляции;
    auto проход1 = new СемантическаяПроходка1(мод, контекст);
    проход1.пуск();

    // Инициализация члена папкаСДанными.
    if (auto знач = дайЗначение!(ТекстовоеВыражение)("ПАПДАНДРК"))
      this.папкаСДанными = знач.дайТекст();
    this.папкаСДанными = раскройПеременные(this.папкаСДанными);
    ГлобальныеНастройки.папкаСДанными = this.папкаСДанными;
    Environment.set("ПАПДАНДРК", this.папкаСДанными);

    if (auto массив = дайЗначение!(ВыражениеИницМассива)("ИДЫ_ВЕРСИИ"))
      foreach (значение; массив.значения)
        if (auto знач = перебросьВ!(ТекстовоеВыражение)(значение))
          ГлобальныеНастройки.идыВерсий ~= раскройПеременные(знач.дайТекст());
    if (auto знач = дайЗначение!(ТекстовоеВыражение)("ФАЙЛ_ЯЗ"))
      ГлобальныеНастройки.файлЯзыка = раскройПеременные(знач.дайТекст());
    if (auto массив = дайЗначение!(ВыражениеИницМассива)("ПУТИ_ИМПОРТА"))
      foreach (значение; массив.значения)
        if (auto знач = перебросьВ!(ТекстовоеВыражение)(значение))
          ГлобальныеНастройки.путиИмпорта ~= раскройПеременные(знач.дайТекст());
    if (auto массив = дайЗначение!(ВыражениеИницМассива)("ФАЙЛЫ_ДДОК"))
      foreach (значение; массив.значения)
        if (auto знач = перебросьВ!(ТекстовоеВыражение)(значение))
          ГлобальныеНастройки.путиКФайлуДдок ~= раскройПеременные(знач.дайТекст());
    if (auto знач = дайЗначение!(ТекстовоеВыражение)("КАРТА_РЯР"))
      ГлобальныеНастройки.файлКартыРЯР = раскройПеременные(знач.дайТекст());
    if (auto знач = дайЗначение!(ТекстовоеВыражение)("КАРТА_ГЯР"))
      ГлобальныеНастройки.файлКартыГЯР = раскройПеременные(знач.дайТекст());
    if (auto знач = дайЗначение!(ТекстовоеВыражение)("ОШ_ЛЕКСЕРА"))
      ГлобальныеНастройки.форматОшибкиЛексера = раскройПеременные(знач.дайТекст());
    if (auto знач = дайЗначение!(ТекстовоеВыражение)("ОШ_ПАРСЕРА"))
      ГлобальныеНастройки.форматОшибкиПарсера = раскройПеременные(знач.дайТекст());
    if (auto знач = дайЗначение!(ТекстовоеВыражение)("СЕМОШ"))
      ГлобальныеНастройки.форматОшибкиСемантики = раскройПеременные(знач.дайТекст());
    if (auto знач = дайЗначение!(ЦелВыражение)("ШИРИНА_ТАБ"))
    {
      ГлобальныеНастройки.ширинаТаб = cast(бцел)знач.число;
      Положение.ШИРИНА_ТАБ = cast(бцел)знач.число;
    }


    // Загрузка файла языка.
    // TODO: создать для этого отдельный класс?
    путьКФайлу = раскройПеременные(ГлобальныеНастройки.файлЯзыка);
    мод = new Модуль(путьКФайлу);
    мод.разбор();

    if (мод.естьОшибки)
      return;

    проход1 = new СемантическаяПроходка1(мод, контекст);
    проход1.пуск();

    if (auto массив = дайЗначение!(ВыражениеИницМассива)("сообщения"))
    {
      сим[][] сообщения;
      foreach (значение; массив.значения)
        if (auto знач = перебросьВ!(ТекстовоеВыражение)(значение))
          сообщения ~= знач.дайТекст();
      if (сообщения.length != ИДС.max+1)
        ошибка(мод.перваяСема,
              "таблица сообщений  в {} должна иметь строго {} записей, а не {}.",
              путьКФайлу, ИДС.max+1, сообщения.length);
      ГлобальныеНастройки.сообщения = сообщения;
      drc.Messages.УстановиСообщения(сообщения);
    }
    if (auto знач = дайЗначение!(ТекстовоеВыражение)("код_языка"))
      ГлобальныеНастройки.кодЯзыка = знач.дайТекст();
  }

  /// Ищет файл конфигурации drc.
  /// Возвращает: путьКФайлу или null, если файл найти не удаётся.
  ткст НайдиПутьКФайлуКонфигурации()
  {
    // 1. Находит переменную среды DRCONF.
    auto путьКФайлу = new FilePath(Environment.get("DRCONF"));
    if (путьКФайлу.exists())
      return путьКФайлу.вТкст();
    // 2. Поиск в текущем рабочем каталоге.
    путьКФайлу.set(this.имяФайлаКонфиг);
    if (путьКФайлу.exists())
      return путьКФайлу.вТкст();
    // 3. Поиск в папке, указанной в переменной HOME.
    путьКФайлу.set(this.путьДомой);
    путьКФайлу.append(this.имяФайлаКонфиг);
    if (путьКФайлу.exists())
      return путьКФайлу.вТкст();
    // 4. Поиск в папке с бинарниками.
    путьКФайлу.set(this.папкаСЭкзе);
    путьКФайлу.append(this.имяФайлаКонфиг);
    if (путьКФайлу.exists())
      return путьКФайлу.вТкст();
    return null;
  }
}

/// Загружает ассоциативный массив из файла модуля Ди.
class ЗагрузчикКартыТегов : ЗагрузчикНастроек
{
  this(Диагностика диаг)
  {
    super(диаг);
  }

  static ЗагрузчикКартыТегов opCall(Диагностика диаг)
  {
    return new ЗагрузчикКартыТегов(диаг);
  }

  ткст[ткст] загрузи(ткст путьКФайлу)
  {
    мод = new Модуль(путьКФайлу, диаг);
    мод.разбор();
    if (мод.естьОшибки)
      return null;

    auto контекст = new КонтекстКомпиляции;
    auto проход1 = new СемантическаяПроходка1(мод, контекст);
    проход1.пуск();

    ткст[ткст] карта;
    if (auto массив = дайЗначение!(ВыражениеИницМассива)("карта"))
      foreach (i, значение; массив.значения)
      {
        auto key = массив.ключи[i];
        if (auto valExp = перебросьВ!(ТекстовоеВыражение)(значение))
          if (!key)
            ошибка(значение.начало, "ожидались ключ : значение");
          else if (auto keyExp = перебросьВ!(ТекстовоеВыражение)(key))
            карта[keyExp.дайТекст()] = valExp.дайТекст();
      }
    return карта;
  }
}

/// Определяет путь к файлу относительно папки исполнимого кода.
/// Возвращает: путьКФайлу, если он относительный, или путьИсп + путьКФайлу.
ткст определиПуть(ткст путьИсп, ткст путьКФайлу)
{
  scope путь = new FilePath(путьКФайлу);
  if (путь.isAbsolute())
    return путьКФайлу;
  путь.set(путьИсп).append(путьКФайлу);
  return путь.вТкст();
}

version(DDoc)
{
  /// Возвращает полный квалифицированыый путь к данному исполнимому файлу.
  сим[] ДайПутьКИсполнимомуФайлу();
}
else version(Windows)
{
private extern(Windows) бцел GetModuleFileNameA(проц *, сим*, бцел);

сим[] ДайПутьКИсполнимомуФайлу()
{
  alias GetModuleFileNameA GetModuleFileName;
  сим[] буфер = new сим[256];
  бцел счёт;

  while (1)
  {
    if (буфер is null)
      return null;

    счёт = GetModuleFileName(null, буфер.ptr, буфер.length);
    if (счёт == 0)
      return null;
    if (буфер.length != счёт && буфер[счёт] == 0)
      break;
    // Increase размер of буфер
    буфер.length = буфер.length * 2;
  }
  assert(буфер[счёт] == 0);
  // Reduce буфер в the actual length of the ткст (excluding '\0'.)
  if (счёт < буфер.length)
    буфер.length = счёт;
  return буфер;
}
}
else version(linux)
{
private extern(C) т_мера readlink(сим* путь, сим* буф, т_мера буфразм);

сим[] ДайПутьКИсполнимомуФайлу()
{
  сим[] буфер = new сим[256];
  т_мера счёт;

  while (1)
  {
    // Этот won't work on very old Linux systems.
    счёт = readlink("/proc/self/exe".ptr, буфер.ptr, буфер.length);
    if (счёт == -1)
      return null;
    if (счёт < буфер.length)
      break;
    буфер.length = буфер.length * 2;
  }
  буфер.length = счёт;
  return буфер;
}
}
else
  static assert(0, "ДайПутьКИсполнимомуФайлу() на данной платформе не реализован.");
