/*===-- llvm-c/Core.h - Си Интерфейс Библиотеки Ядра -------------*- к -*-===*\
|*                                                                            *|
|* Part of the LLVM Project, under the Apache License v2.0 with LLVM          *|
|* Exceptions.                                                                *|
|* See https://llvm.org/LICENSE.txt for license information.                  *|
|* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception                    *|
|*                                                                            *|
|*===----------------------------------------------------------------------===*|
|*                                                                            *|
|* Этот заголовок декларирует Си интерфейс к libLLVMCore.a, который           *|
|* реализует промежуточное представление LLVM.                                *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

module ll.Core;
import ll.ErrorHandling, ll.Types;

extern (C) {


/**
 * @defgroup LLVMC LLVM-C: Си интерфейс к LLVM
 *
 * Этот модуль предоставляет часть библиотеки LLVM как Си API.
 *
 * @{
 */

/**
 * @defgroup LLVMCTransforms Трансформации
 */

/**
 * @defgroup LLVMCCore Ядро
 *
 * Этот модуль предоставляет интерфейс к libLLVMCore, который реализует
 * промежуточное представление LLVM, а также другие связанные с ним типы
 * и утилиты.
 *
 * Многие экзотические языки могут взаимодействовать с кодом на к, но имеют
 * затруднения с C++ из-за декорирования имён. Поэтому дополнительно к Си
 * этот интерфейс позволяет делать инструменты на подобных языках.
 *
 * @{
 */

/**
 * @defgroup LLVMCCoreTypes Типы и Перечни
 *
 * @{
 */

/// Внешние пользователи зависят от стабильности следующих значений. Небезопасно
/// менять их порядок.
enum ЛЛОпкод {
  /* Инструкции Терминатора */
  Возвр            = 1,
  Бр             = 2,
  Щит         = 3,
  НепрямБр     = 4,
  Инвок         = 5,
  /* removed 6 due to API changes */
  Недоступно    = 7,
  КоллБр         = 67,

  /* Стандартные Унарные Операторы */
  ПОтриц           = 66,

  /* Стандартные Бинарные Операторы */
  Сложи            = 8,
  ПСложи           = 9,
  Отними            = 10,
  ПОтними           = 11,
  Умножь            = 12,
  ПУмножь           = 13,
  БДели           = 14,
  ЗДели           = 15,
  ПДели           = 16,
  URem           = 17,
  SRem           = 18,
  FRem           = 19,

  /* Логические Операторы */
  Shl            = 20,
  LShr           = 21,
  AShr           = 22,
  И            = 23,
  Или             = 24,
  ИИли            = 25,

  /* Операторы Памяти */
  Разместа         = 26,
  Загрузи           = 27,
  Сохрани          = 28,
  ДайУкзЭлта  = 29,

  /* Каст-Операторы */
  Обрежь          = 30,
  НРасш           = 31,
  ЗРасш           = 32,
  ПЗвБЦ         = 33,
  ПЗвЗЦ         = 34,
  БЦвПЗ         = 35,
  ЗЦвПЗ         = 36,
  ПЗОбрежь        = 37,
  ПЗРасш          = 38,
  УкзВЦел       = 39,
  ЦелВУкз       = 40,
  БитКаст        = 41,
  АдрПрострКаст  = 60,

  /* Прочие Операторы */
  ЦСравн           = 42,
  ПСравн           = 43,
  PHI            = 44,
  Вызов           = 45,
  Выбор         = 46,
  ЮзерОп1        = 47,
  ЮзерОп2        = 48,
  ВаАрг          = 49,
  ИзвлЭлта = 50,
  ВставкаЭлта  = 51,
  ШафлВектор  = 52,
  ИзвлЗнач   = 53,
  ВставкаЗнач    = 54,

  /* Атомные Операторы */
  Забор          = 55,
  AtomicCmpXchg  = 56,
  AtomicRMW      = 57,

  /* Операторы Обработки Исключений */
  Возобнови         = 58,
  ЛэндингПад     = 59,
  ОчистьВозвр     = 61,
  КэчВозвр       = 62,
  КэчПад       = 63,
  ОчистьПад     = 64,
  КэчЩит    = 65
} ;

enum ЛЛРодТипа {
  Проц,        /**< тип без размера */
  Пол,        /**< 16-битный тип с плавающей точкой */
  Плав,       /**< 32-битный тип с плавающей точкой */
  Дво,      /**< 64-битный тип с плавающей точкой */
  Х86_ПЗ80,    /**< 80-битный тип с плавающей точкой (X87) */
  ПЗ128,       /**< 128-битный тип с плавающей точкой (112-битная мантисса)*/
  ППЦ_ПЗ128,   /**< 128-битный тип с плавающей точкой (два 64-битных) */
  Ярлык,       /**< Ярлыки */
  Целое,     /**< Целочисленные типы произвольной длины */
  Функция,    /**< Функции */
  Структ,      /**< Структуры */
  Массив,       /**< Массивы */
  Указатель,     /**< Указатели */
  Вектор,      /**< Формат SIMD 'packed', или иной векторный тип */
  Метаданные,    /**< Метаданные */
  Х86_ММХ,     /**< X86 MMX */
  Сема        /**< Токены */
} ;

enum ЛЛКомпоновка {
  Внешняя,    /**< Внешне видимая функция */
  ДоступноИзвне,
  КомпРазЛюб, /**< При компоновке сохранять одну копию функции (inline)*/
  LinkOnceODR, /**< То же, но только заменённую чем-л. равноценным. */
  LinkOnceODRAutoHide, /**< Устарело */
  СлабаяЛюбая,     /**< Keep one copy of function when linking (weak) */
  WeakODR,     /**< Same, but only replaced by something
                            equivalent. */
  Приставка,   /**< Особая цель, применяется только к глобальным массивам */
  Внутренняя,    /**< Переименовывать коллизии при компоновке (статические
                               функции) */
  Приватная,     /**< Как Внутренняя, but omit from symbol table */
  ДЛЛИмпорт,   /**< Устарело */
  ДЛЛЭкспорт,   /**< Устарело */
  ВнешняяСлабая,/**< ExternalWeak linkage description */
  Ghost,       /**< Устарело */
  Общая,      /**< Tentative definitions */
  КомпПриватная, /**< Как Приватная, but linker removes. */
  КомпПриватСлабая /**< Как КомпПриватная, но слабая. */
} ;

enum ЛЛВидимость {
  Дефолт,  /**< The GV is visible */
  Скрыт,   /**< The GV is hidden */
  Защищён /**< The GV is protected */
} ;

enum ЛЛБезымАдрес {
  Нет,    /**< Address of the GV is significant. */
  Лок, /**< Address of the GV is locally insignificant. */
  Глоб /**< Address of the GV is globally insignificant. */
} ;

enum ЛЛКлассХранДЛЛ {
  Дефолт   = 0,
  ДЛЛИмпорт = 1, /**< Функция, импортируемая из DLL. */
  ДЛЛЭкспорт = 2  /**< Функция, доступная из DLL. */
} ;

enum LLVMCallConv {
  C            = 0,
  Fast         = 8,
  Cold         = 9,
  GHC          = 10,
  HiPE         = 11,
  WebKitJS     = 12,
  AnyReg       = 13,
  PreserveMost = 14,
  PreserveAll  = 15,
  Swift        = 16,
  CXXFASTTLS   = 17,
  X86Stdcall   = 64,
  X86Fastcall  = 65,
  ARMAPCS      = 66,
  ARMAAPCS     = 67,
  ARMAAPCSVFP  = 68,
  MSP430INTR   = 69,
  X86ThisCall  = 70,
  PTXKernel    = 71,
  PTXDevice    = 72,
  SPIRFUNC     = 75,
  SPIRKERNEL   = 76,
  IntelOCLBI   = 77,
  X8664SysV    = 78,
  Win64        = 79,
  X86VectorCall= 80,
  HHVM         = 81,
  HHVMC        = 82,
  X86INTR      = 83,
  AVRINTR      = 84,
  AVRSIGNAL    = 85,
  AVRBUILTIN   = 86,
  AMDGPUVS     = 87,
  AMDGPUGS     = 88,
  AMDGPUPS     = 89,
  AMDGPUCS     = 90,
  AMDGPUKERNEL = 91,
  X86RegCall   = 92,
  AMDGPUHS     = 93,
  MSP430BUILTIN= 94,
  AMDGPULS     = 95,
  AMDGPUES     = 96
} ;

enum ЛЛРодЗначения {
  Аргумент,
  БазовыйБлок,
  ИспПамяти,
  MemoryDef,
  MemoryPhi,

  Функция,
  ГлобАлиас,
  ГлобФункц,
  ГлобПерем,
  АдрБлока,
  КонстВыр,
  КонстМассив,
  КонстСтрукт,
  КонстВектор,

  НеопрЗнач,
  КонстАгрегатНуль,
  КонстМассивДан,
  КонстВекторДан,
  КонстЦел,
  КонстПЗ,
  КонстУкНулл,
  КонстСемаНан,

  МетаданныеКакЗнач,
  ИнлайнАсм,

  Инструкция,
} ;

enum ЛЛЦелПредикат {
  IntEQ = 32, /**< равно */
  IntNE,      /**< не равно */
  IntUGT,     /**< бцел больше чем */
  IntUGE,     /**< бцел больше или равно */
  IntULT,     /**< бцел меньше чем */
  IntULE,     /**< бцел меньше или равно */
  IntSGT,     /**< значный больше чем */
  IntSGE,     /**< значный больше или равно */
  IntSLT,     /**< значный меньше чем */
  IntSLE      /**< значный меньше или равно */
} ;

enum ЛЛПредикатРеала {
  False, /**< Always false (always folded) */
  RealOEQ,            /**< Да, если упорядочено и равно */
  RealOGT,            /**< Да, если упорядочено и больше чем */
  RealOGE,            /**< Да, если упорядочено и больше чем или равно */
  RealOLT,            /**< Да, если упорядочено и меньше чем */
  RealOLE,            /**< Да, если упорядочено и меньше чем или равно */
  RealONE,            /**< Да, если упорядочено и операнды неравны */
  RealORD,            /**< Да, если упорядочено (no nans) */
  RealUNO,            /**< Да, если неупорядочено: isnan(X) | isnan(Y) */
  RealUEQ,            /**< Да, если неупорядочено или равно */
  RealUGT,            /**< Да, если неупорядочено или больше чем */
  RealUGE,            /**< Да, если неупорядочено, больше чем или равно */
  RealULT,            /**< Да, если неупорядочено или меньше чем */
  RealULE,            /**< Да, если неупорядочено, меньше чем или равно*/
  RealUNE,            /**< Да, если неупорядочено или не равно */
  True   /**< Всегда да (always folded) */
} ;

enum LLVMLandingPadClauseTy {
  Catch,    /**< атр catch клоз   */
  Filter    /**< атр filter клоз  */
} ;

enum ЛЛНителокРежим {
  NotThreadLocal = 0,
  GeneralDynamicTLSModel,
  LocalDynamicTLSModel,
  InitialExecTLSModel,
  LocalExecTLSModel
} ;

enum ЛЛАтомныйПорядок {
  NotAtomic = 0, /**< атр load or store which is not atomic */
  Unordered = 1, /**< Lowest level of atomicity, guarantees
                                     somewhat sane results, lock free. */
  Monotonic = 2, /**< guarantees that if you take all the
                                     operations affecting a specific address,
                                     a consistent порядок exists */
  Acquire = 4, /**< Acquire provides a barrier of the sort
                                   necessary to acquire a lock to access other
                                   memory with normal loads and stores. */
  Release = 5, /**< Release is similar to Acquire, but with
                                   a barrier of the sort necessary to release
                                   a lock. */
  AcquireRelease = 6, /**< provides both an Acquire and a
                                          Release barrier (for fences and
                                          operations which both read and write
                                           memory). */
  SequentiallyConsistent = 7 /**< provides Acquire semantics
                                                 for loads and Release
                                                 semantics for stores.
                                                 Additionally, it guarantees
                                                 that a total порядок exists
                                                 between all
                                                 SequentiallyConsistent
                                                 operations. */
} ;

enum LLVMAtomicRMWBinOp {
    Xchg, /**< Установить новое значение и вернуть старое */
    Add, /**< Прибавить значение и вернуть старое */
    Sub, /**< Отнять значение и вернуть старое */
    And, /**< And a знач and return the old one */
    Nand, /**< Not-And a знач and return the old one */
    Or, /**< OR a знач and return the old one */
    Xor, /**< Xor a знач and return the old one */
    Max, /**< Sets the знач if it's greater than the
                             original using a signed comparison and return
                             the old one */
    Min, /**< Sets the знач if it's Smaller than the
                             original using a signed comparison and return
                             the old one */
    UMax, /**< Sets the знач if it's greater than the
                             original using an бцел comparison and return
                             the old one */
    UMin /**< Sets the знач if it's greater than the
                             original using an бцел comparison  and return
                             the old one */
} ;

enum ЛЛСтрогостьДиагностики {
    ДСОшибка,
    ДСПредупреждение,
    ДСЗамечание,
    ДСПамятка
} ;

enum ЛЛДиалектИнлайнАсма {
  АТТ,
  Интел
} ;

enum ЛЛПоведениеФлагаМодуля {
  /**
   * Генерирует ошибку, если два значения не согласуются, или же результирующее
   * значение равно этим операндам.
   *
   * @see Module::ModFlagBehavior::Error
   */
  Ошибка,
  /**
   * Генерирует предупреждение, если два значения не согласуются. 
   * Результирующее значение равно операнду флага от 
   * первого компонуемого модуля.
   *
   * @see Module::ModFlagBehavior::Warning
   */
  Предупреждение,
  /**
   * Добавляет требование присутствия флага другого модуля и наличия
   * указанного значения после выполнения компоновки. Это значение
   * должно быть парой метаданных,где первый элемент пары является
   * идентификатором фланга модуля, который ограничивается,
   * а второй элемент пары - это значение флага модуля,
   * до которого будет ограничиваться. Это поведение можно использовать
   * для ограничения допустимых результатов (путём триггирования ошибки) компоновки.
   * ИДы с поведением **Override** .
   *
   * @see Module::ModFlagBehavior::Require
   */
  Требуется,
  /**
   * Использует заданное значение, не смотря на поведение или значение
   * другого модуля. Если оба модуля определяют **Override**, но значения
   * разнятся, то генерируется ошибка.
   *
   * @see Module::ModFlagBehavior::Override
   */
  Перепись,
  /**
   * Приставляет два значения, которые должны быть узлами метаданных.
   *
   * @see Module::ModFlagBehavior::Append
   */
  Приставка,
  /**
   * Приставляет два значения, которые должны быть узлами метаданных.
   * Однако, записи-дубликаты из второго списка во время операции
   * приставления опускаются.
   *
   * @see Module::ModFlagBehavior::AppendUnique
   */
  УникПриставка,
} ;

/**
 * Индекс атрибута либо LLVMAttributeReturnIndex,
 * LLVMAttributeFunctionIndex либо номер параметра от 1 до N.
 */
enum {
  LLVMAttributeReturnIndex = 0U,
  // ISO C ограничивает значения перечислителя до диапазона 'цел'
  // (4294967295 слишком велико)
  // LLVMAttributeFunctionIndex = ~0U,
  LLVMAttributeFunctionIndex = -1,
};

alias бцел ЛЛИндексАтрибута;

/**
 * @}
 */

проц ЛЛИницЯдро(ЛЛРеестрПроходок R);

/** Выместить и разрушить все переменные ManagedStatic.
    @see llvm::llvm_shutdown
    @see ManagedStatic */
проц ЛЛШатдаун();

/*===-- Обработка исключений ----------------------------------------------------===*/

ткст0 ЛЛкоздайкообщение(ткст0 сообщение);
проц ЛЛВыместиСообщение(ткст0 сообщение);

/**
 * @defgroup LLVMCCoreContext Контексты
 *
 * Контексты - это состояния выполнения для системы ядра LLVM IR.
 *
 * Большинство типов прикреплено к экземпляру контекста. Могут одновременно
 * существовать несколько контекстов. Единичный контекст не нитебезопасен. Однако,
 * в разных потоках одновременно могут выполняться разные контексты.
 *
 * @{
 */

alias проц function(ЛЛИнфоДиагностики, ук ) ЛЛОбработчикДиагностики;
alias проц function(ЛЛКонтекст, ук ) ЛЛОбрвызовЖни;

/**
 * Создать новый контекст.
 *
 * Каждый вызов этой функции должен быть в паре с вызовом
 * LLVMContextDispose(), или же возможна утечка памяти.
 */
ЛЛКонтекст ЛЛКонтекстСоздай();

/**
 * Получить экземпляр глобального контекста.
 */
ЛЛКонтекст ЛЛДайГлобКонтекст();

/**
 * Установить для данного контекста диагностический обработчик.
 */
проц ЛЛКонтекстУстОбработчикДиагностики(ЛЛКонтекст к,
                                     ЛЛОбработчикДиагностики обработчик,
                                     ук DiagnosticContext);

/**
 * Получить диагностический обработчик данного контекста.
 */
ЛЛОбработчикДиагностики ЛЛКонтекстДайОбработчикДиагностики(ЛЛКонтекст к);

/**
 * Получить диагностический контекст данного контекста.
 */
ук ЛЛКонтекстДайКонтекстДиагностики(ЛЛКонтекст к);

/**
 * Установить для данного контекста функцию обратного вызова yield ("жни").
 *
 * @see LLVMContext::setYieldCallback()
 */
проц ЛЛКонтекстУстОбрвызовЖни(ЛЛКонтекст к, ЛЛОбрвызовЖни обрвыз,
                                 ук OpaqueHandle);

/**
 * Получить инфу, установлен ли данный контекст на сброс имён всех значений.
 *
 * @see LLVMContext::shouldDiscardValueNames()
 */
ЛЛБул ЛЛКонтекстСбрасыватьИменаЗначений_ли(ЛЛКонтекст к);

/**
 * Установить сброс контекстом имён всех значений.
 *
 * Если true, то только имена объектов GlobalValue будут доступны в IR.
 * Можно использовать для сбережения памяти и времени выполнения, особенно в режиме release.
 *
 * @see LLVMContext::setDiscardValueNames()
 */
проц ЛЛКонтекстУстСбросИмёнЗначений(ЛЛКонтекст к, ЛЛБул Discard);

/**
 * Разрушить экземпляр контекста.
 *
 * Следует вызывать при каждом вызове LLVMContextCreate() 
 * во избежание утечки памяти.
 */
проц ЛЛКонтекстВымести(ЛЛКонтекст к);

/**
 * Возвращает текстовое представление DiagnosticInfo. Следует использовать
 * LLVMDisposeMessage, чтобы высвободить строку.
 *
 * @see DiagnosticInfo::print()
 */
ткст0 ЛЛДайОписаниеДиагИнфо(ЛЛИнфоДиагностики диагИнфо);

/**
 * Возвращает перечень ЛЛСтрогостьДиагностики.
 *
 * @see DiagnosticInfo::getSeverity()
 */
ЛЛСтрогостьДиагностики ЛЛДайСтрогостьДиагИнфо(ЛЛИнфоДиагностики диагИнфо);

бцел ЛЛДайИДТипаМДВКонтексте(ЛЛКонтекст к, ткст0 имя, бцел длинс);
бцел ЛЛДайИДТипаМД(ткст0 имя, бцел длинс);

/**
 * Возвращает уникальный идентификатор, заданный имени атрибута перечня,
 * либо 0, если никакого атрибута с таким именем не существует.
 *
 * Смотрите http://llvm.org/docs/LangRef.html#parameter-attributes
 * и http://llvm.org/docs/LangRef.html#function-attributes,
 * где можно найти список доступных атрибутов.
 *
 * NB: Имена и/или идентификаторы атрибутов подвержены изменению без
 * прохождения через цикл деприкации Си API.
 */
бцел ЛЛДайТипАтрибутаПеречняДляИмени(ткст0 имя, т_мера длинс);
бцел LLVMGetLastEnumAttributeKind();

/**
 * Создать атрибут перечня.
 */
ЛЛАтрибут ЛЛСоздайАтрибутПеречня(ЛЛКонтекст к, бцел идРода,
                                         uint64_t знач);

/**
 * Получить уникальный идентификатор, соответствующий
 * атрибуту перечня, переданного в качестве аргумента.
 */
бцел ЛЛДайТипАтрибутаПеречня(ЛЛАтрибут атр);

/**
 * Получить значение атрибута перечня. Если не существует,
 * то возвращается 0.
 */
uint64_t ЛЛДайЗначениеАтрибутаПеречня(ЛЛАтрибут атр);

/**
 * Создать текстовый атрибут.
 */
ЛЛАтрибут ЛЛСоздайТкстАтрибут(ЛЛКонтекст к, ткст0 K, бцел KLength,
                                           ткст0 З, бцел VLength);

/**
 * Получить вид текстового атрибута.
 */
ткст0 ЛЛДайТипТкстАтрибута(ЛЛАтрибут атр, бцел *длина);

/**
 * Получить значение текстового атрибута.
 */
ткст0 ЛЛДайЗначениеТкстАтрибута(ЛЛАтрибут атр, бцел *длина);

/**
 * Проверка на разные типы атрибутов.
 */
ЛЛБул ЛЛАтрибутПеречня_ли(ЛЛАтрибут атр);
ЛЛБул ЛЛТкстАтрибут_ли(ЛЛАтрибут атр);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreModule Модули
 *
 * Модули представляют высокоуровневую структуру в программе LLVM.
 * Модуль LLVM на деле является блоком трансляции или коллекцией
 * блоков трансляции, собранных вместе.
 *
 * @{
 */

/**
 * Создать новый, пустой модуль в глобольном контексте.
 *
 * Это равноценно вызову LLVMModuleCreateWithNameInContext с
 * LLVMGetGlobalContext() в качестве параметра контекста.
 *
 * Каждый вызов должен следовать в паре с LLVMDisposeModule()
 * во избежание утечки памяти.
 */
ЛЛМодуль ЛЛМодуль_СоздайСИменем(ткст0 идМодуля);

/**
 * Создать новый, пустой модуль в специфичном контексте.
 *
 * Каждый вызов должен следовать в паре с LLVMDisposeModule()
 * во избежание утечки памяти.
 */
ЛЛМодуль ЛЛМодуль_СоздайСИменемВКонтексте(ткст0 идМодуля, ЛЛКонтекст к);
/**
 * Возвращает точную копию указанного модуля.
 */
ЛЛМодуль LLVMCloneModule(ЛЛМодуль м);

/**
 * Разрушить экземпляр модуля.
 *
 * Следует вызывать для каждого созданного модуля
 * во избежание утечки памяти.
 */
проц ЛЛВыместиМодуль(ЛЛМодуль м);

/**
 * Получить идентификатор модуля.
 *
 * @param м Модуль, у которого нужно получить идентификатор
 * @param длин Выходной параметр, содержащий длину возвращаемой строки.
 * @return Идентификатор м.
 * @see Module::getModuleIdentifier()
 */
ткст0 ЛЛДайИдентификаторМодуля(ЛЛМодуль м, т_мера* длин);

/**
 * Устанавливает идентификатор модуля в текст идент с длиной длин.
 *
 * @param м Модуль, у которого устанавливается ид
 * @param идент Текст, на который устанавливается идентификатор модуля
 * @param длин Длина идентификатора
 * @see Module::setModuleIdentifier()
 */
проц ЛЛУстИдентификаторМодуля(ЛЛМодуль м, ткст0 идент, т_мера длин);

/**
 * Получить название файла-исходника модуля.
 *
 * @param м Модуль, у которого следует получить имя
 * @param длин  Выходной параметр, содержащий длину возвращаемой строки
 * @return Имя файла-исходника м
 * @see Module::getSourceFileName()
 */
ткст0 ЛЛДайИмяИсходника(ЛЛМодуль м, т_мера *длин);

/**
 * Установить имя оригинального файла-исходника модуля в текст имя с длиной
 * длин.
 *
 * @param м Модуль, у которого следует установить имя
 * @param имя Текст, в который нужно установить имя исходника модуля
 * @param длин Длина имени
 * @see Module::setSourceFileName()
 */
проц ЛЛУстИмяИсходника(ЛЛМодуль м, ткст0 имя, т_мера длин);

/**
 * Получить раскладку данных для модуля.
 *
 * @see Module::getDataLayoutStr()
 *
 * LLVMGetDataLayout is Депрекировано, as the name is not only incorrect,
 * but match the name of another method on the module. Prefer the use
 * of LLVMGetDataLayoutStr, which is not ambiguous.
 */
ткст0 ЛЛДайСтрРаскладкиДанных(ЛЛМодуль м);
ткст0 ЛЛДайРаскладкуДанных(ЛЛМодуль м);

/**
 * Установить раскладку данных для модуля.
 *
 * @see Module::setDataLayout()
 */
проц ЛЛУстРаскладкуДанных(ЛЛМодуль м, ткст0 ткстРасклДан);

/**
 * Получить целевую триаду для модуля.
 *
 * @see Module::getTargetTriple()
 */
ткст0 ЛЛДайЦель(ЛЛМодуль м);

/**
 * Установить целевую триаду для модуля.
 *
 * @see Module::setTargetTriple()
 */
проц ЛЛУстЦель(ЛЛМодуль м, ткст0 триада);

/**
 * Возвращает флаги модуля как массив триад флаг-ключ-значение. Вызывающий
 * отвечает за освобождение этого массива с помощью
 * \конст LLVMDisposeModuleFlagsMetadata.
 *
 * @see Module::getModuleFlagsMetadata()
 */
ЛЛЗаписьФлагаМодуля *ЛЛКопируйМетаданныеФлаговМодуля(ЛЛМодуль м, т_мера *длин);

/**
 * Уничтожить записи метаданных флагов модуля.
 */
проц ЛЛВыместиМетаданныеФлаговМодуля(ЛЛЗаписьФлагаМодуля *записи);

/**
 * Возвращает поведение флага для записи флага модуля по определённому индексу.
 *
 * @see Module::ModuleFlagEntry::поведение
 */
ЛЛПоведениеФлагаМодуля
ЛЛЗаписиФлаговМодуля_ДайПоведениеФлага(ЛЛЗаписьФлагаМодуля *записи, бцел индекс);

/**
 * Возвращает ключ к записи флага модуля по заданному индексу.
 *
 * @see Module::ModuleFlagEntry::ключ
 */
ткст0 ЛЛЗаписиФлаговМодуля_ДайКлюч(ЛЛЗаписьФлагаМодуля *записи, бцел индекс, т_мера *длин);

/**
 * Возвращает метаданные для записи флага модуля по заданному индексу.
 *
 * @see Module::ModuleFlagEntry::знач
 */
ЛЛМетаданные ЛЛЗаписиФлаговМодуля_ДайМетаданные(ЛЛЗаписьФлагаМодуля *записи, бцел индекс);

/**
 * Добавляет флаг уровня модуля к метаданным флагов уровня модуля, если его ещё
 * не существует.
 *
 * @see Module::getModuleFlag()
 */
ЛЛМетаданные ЛЛДайФлагМодуля(ЛЛМодуль м, ткст0 ключ, т_мера длинКлюча);

/**
 * Добавляет флаг уровня модуля к метаданным флагов уровня модуля, если его ещё
 * не существует.
 *
 * @see Module::addModuleFlag()
 */
проц ЛЛДобавьФлагМодуля(ЛЛМодуль м, ЛЛПоведениеФлагаМодуля поведение,
                       ткст0 ключ, т_мера длинКлюча,
                       ЛЛМетаданные знач);

/**
 * Выводит дамп представления модуля на стдош.
 *
 * @see Module::dump()
 */
проц ЛЛДампМодуля(ЛЛМодуль м);

/**
 * Выводит представление модуля в файл. ошСооб должна вымещаться
 * с помощью LLVMDisposeMessage. Возвращает 0 при успехе, 1 в противном случае.
 *
 * @see Module::print()
 */
ЛЛБул ЛЛВыведиМодульВФайл(ЛЛМодуль м, ткст0 имяФ, ткст0 *ошСооб);

/**
 * Возвращает текстовое представление модуля. 
 * LLVMDisposeMessage используется для освобождения этой строки.
 *
 * @see Module::print()
 */
ткст0 ЛЛВыведиМодульВСтроку(ЛЛМодуль м);

/**
 * Получить инлайн-ассемблер для модуля.
 *
 * @see Module::getModuleInlineAsm()
 */
ткст0 ЛЛУстИнлайнАсмМодуля(ЛЛМодуль м, т_мера *длин);

/**
 * Установить инлайн-ассемблер для модуля.
 *
 * @see Module::setModuleInlineAsm()
 */
проц ЛЛУстИнлайнАсмМодуля2(ЛЛМодуль м, ткст0 асм, т_мера длин);

/**
 * Приставить инлайн-ассемблер к модулю.
 *
 * @see Module::appendModuleInlineAsm()
 */
проц ЛЛПриставьИнлайнАсмМодуля(ЛЛМодуль м, ткст0 асм, т_мера длин);

/**
 * Создать указанную уникальную строку ассемблера.
 *
 * @see InlineAsm::get()
 */
ЛЛЗначение ЛЛДайИнлайнАсм(ЛЛТип тип, ткст0 ткстАсм, т_мера ткстАсмРазм,
                              ткст0 констрейнты, т_мера констрейнтыРазм,
                              ЛЛБул естьПобЭффект, ЛЛБул естьСтэкРаскладки,
                              ЛЛДиалектИнлайнАсма диалект);

/**
 * Получить контекст, с которым ассоциирован этот модуль.
 *
 * @see Module::getContext()
 */
ЛЛКонтекст ЛЛДайКонтекстМодуля(ЛЛМодуль м);

/**
 * Получить тип из модуля по его зарегистрированному имени.
 */
ЛЛТип ЛЛДайТипПоИмени(ЛЛМодуль м, ткст0 имя);

/**
 * Получить итератор к первому имУзелМД в Module.
 *
 * @see llvm::Module::named_metadata_begin()
 */
ЛЛИменованыйУзелМД ЛЛДайПервыеИменованныеМетаданные(ЛЛМодуль м);

/**
 * Получить итератор к последнему имУзелМД в Module.
 *
 * @see llvm::Module::named_metadata_end()
 */
ЛЛИменованыйУзелМД ЛЛДайПоследниеИменованныеМетаданные(ЛЛМодуль м);

/**
 * Переместить итератор имУзелМД к следующему имУзелМД.
 *
 * Возвращает NULL, если итератор уже был в конце и больше нет
 * именованных узлов метаданных.
 */
ЛЛИменованыйУзелМД ЛЛДайСледщИменованныеМетаданные(ЛЛИменованыйУзелМД имУзелМД);

/**
 * Уменьшить итератор имУзелМД до предыдущего имУзелМД.
 *
 * Возвращает NULL, если итератор уже был в начале и больше нет
 * предыдущих именованных узлов метаданных.
 */
ЛЛИменованыйУзелМД ЛЛДайПредшИменованныеМетаданные(ЛЛИменованыйУзелМД имУзелМД);

/**
 * Получить имУзелМД с заданным именем, возвращая NULL, если такового
 * не существует.
 *
 * @see llvm::Module::getNamedMetadata()
 */
ЛЛИменованыйУзелМД ЛЛДайИменованныеМетаданные(ЛЛМодуль м,
                                        ткст0 имя, т_мера длинаИм);

/**
 * Получить имУзелМД с заданным именем, создавая новый узел, если такового
 * не существует.
 *
 * @see llvm::Module::getOrInsertNamedMetadata()
 */
ЛЛИменованыйУзелМД ЛЛДайИлиВставьИменованныеМетаданные(ЛЛМодуль м, ткст0 имя,
                                                т_мера длинаИм);

/**
 * Получить имя имУзелМД.
 *
 * @see llvm::имУзелМД::getName()
 */
 ткст0 ЛЛДайИмяИменованныхМетаданных(ЛЛИменованыйУзелМД имМД, т_мера *длинаИм);

/**
 * Получить число операндов для именованных метаданных в каком-л. модуле.
 *
 * @see llvm::Module::getNamedMetadata()
 */
бцел ЛЛДайЧлоОперандовИменованныхМетаданных(ЛЛМодуль м, ткст0 имя);

/**
 * Получить именованые операнды метаданных для модуля.
 *
 * Переданный указатель ЛЛЗначение должен ссылаться на массив
 * ЛЛЗначение длиною как минимум LLVMGetNamedMetadataNumOperands. Этот
 * массив будет наполнен экземплярами ЛЛЗначение. Каждый
 * экземпляр соответствует llvm::MDNode.
 *
 * @see llvm::Module::getNamedMetadata()
 * @see llvm::MDNode::getOperand()
 */
проц ЛЛДайОперандыИменованныхМетаданных(ЛЛМодуль м, ткст0 имя, ЛЛЗначение *приёмник);

/**
 * Добавить операнд к именованным метаданным.
 *
 * @see llvm::Module::getNamedMetadata()
 * @see llvm::MDNode::addOperand()
 */
проц ЛЛДобавьОперандИменованныхМетаданных(ЛЛМодуль м, ткст0 имя, ЛЛЗначение знач);

/**
 * Вернуть папку отладочной локации для данного значения, которая должна быть
 * одной из: llvm::Instruction, llvm::GlobalVariable или llvm::Function.
 *
 * @see llvm::Instruction::getDebugLoc()
 * @see llvm::GlobalVariable::getDebugInfo()
 * @see llvm::Function::getSubprogram()
 */
ткст0 ЛЛДайОтладЛокПапку(ЛЛЗначение знач, бцел *длина);

/**
 * Return the filename of the debug location for this знач, which must be
 * an llvm::Instruction, llvm::GlobalVariable, or llvm::Function.
 *
 * @see llvm::Instruction::getDebugLoc()
 * @see llvm::GlobalVariable::getDebugInfo()
 * @see llvm::Function::getSubprogram()
 */
ткст0 ЛЛДайОтладЛокИмяф(ЛЛЗначение знач, бцел *длина);

/**
 * Return the line number of the debug location for this знач, which must be
 * an llvm::Instruction, llvm::GlobalVariable, or llvm::Function.
 *
 * @see llvm::Instruction::getDebugLoc()
 * @see llvm::GlobalVariable::getDebugInfo()
 * @see llvm::Function::getSubprogram()
 */
бцел ЛЛДайОтладЛокСтроку(ЛЛЗначение знач);

/**
 * Return the column number of the debug location for this знач, which must be
 * an llvm::Instruction.
 *
 * @see llvm::Instruction::getDebugLoc()
 */
бцел ЛЛДайОтладЛокКолонку(ЛЛЗначение знач);

/**
 * Добавить функцию в модуль с заданным именем.
 *
 * @see llvm::Function::Create()
 */
ЛЛЗначение ЛЛДобавьФункц(ЛЛМодуль м, ткст0 имя, ЛЛТип типФункц);

/**
 * Получить значение Функции из Модуля по её имени.
 *
 * Возвращённое значение соответствует llvm::Function.
 *
 * @see llvm::Module::getFunction()
 */
ЛЛЗначение ЛЛДайИменованФункц(ЛЛМодуль м, ткст0 имя);

/**
 * Получить итератор к первой функции в Модуле.
 *
 * @see llvm::Module::begin()
 */
ЛЛЗначение ЛЛДайПервФункц(ЛЛМодуль м);

/**
 * Получить итератор к последней функции в Модуле.
 *
 * @see llvm::Module::end()
 */
ЛЛЗначение ЛЛДайПоследнФункц(ЛЛМодуль м);

/**
 * Переместить итератор Функции к следующей Функции.
 *
 * Возвращает NULL, если итератор уже был в конце
 * и функций больше не осталось.
 */
ЛЛЗначение ЛЛДайСледщФункц(ЛЛЗначение фн);

/**
 * Уменьшает итератор Функции до предыдущей Функции.
 *
 * Returns NULL if the iterator was already at the beginning and there are
 * no previous functions.
 */
ЛЛЗначение ЛЛДайПредшФункц(ЛЛЗначение фн);

/** Депрекировано: Use LLVMSetModuleInlineAsm2 instead. */
проц ЛЛУстИнлайнАсмМодуля(ЛЛМодуль м, ткст0 асм);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreType Типы
 *
 * Типы представляют тип значения.
 *
 * Типы ассоциируются с экземпляром контекста. Контекст внутренне
 * удаляет дубликаты типов, поэтому единовременно существует только
 * 1 экземпляр определённого типа. Другими словами, уникальный тип
 * разделяется между всеми потребителями внутри контекста.
 *
 * атр Тип в Си API соответствует llvm::Type.
 *
 * Типы имеют следующую иерархию:
 *
 *   типы:
 *     целочисленный тип
 *     реальный тип
 *     тип функция
 *     типы-последовательности:
 *       тип массив
 *       тип указатель
 *       тип вектор
 *     тип проц
 *     тип ярлык
 *     тип опак
 *
 * @{
 */

/**
 * Получает нумерованный тип экземпляра Тип.
 *
 * @see llvm::Type:getTypeID()
 */
ЛЛРодТипа ЛЛДайРодТипа(ЛЛТип тип);

/**
 * Есть ли у типа известный размер.
 *
 * Размера не имеют абстрактные типы, ярлыки и проц.a
 *
 * @see llvm::Type::isSized()
 */
ЛЛБул ЛЛТипСРазмером_ли(ЛЛТип тип);

/**
 * Получить контекст, с которым ассоциирован экземпляр этого типа.
 *
 * @see llvm::Type::getContext()
 */
ЛЛКонтекст ЛЛДайКонтекстТипа(ЛЛТип тип);

/**
 * Демпировать представление типа на стдош.
 *
 * @see llvm::Type::dump()
 */
проц ЛЛДампТипа(ЛЛТип знач);

/**
 * Возвращает строковое представление типа. Чтобы
 * освободить память строки, используется LLVMDisposeMessage.
 *
 * @see llvm::Type::print()
 */
ткст0 ЛЛВыведиТипВСтроку(ЛЛТип знач);

/**
 * @defgroup LLVMCCoreTypeInt Целочисленные Типы
 *
 * Функции из этой секции оперируют над целочисленными типами.
 *
 * @{
 */

/**
 * Получить целочисленный тип из контекста с указанной битовой длиной.
 */
ЛЛТип ЛЛТипЦел1ВКонтексте(ЛЛКонтекст к);
ЛЛТип ЛЛТипЦел8ВКонтексте(ЛЛКонтекст к);
ЛЛТип ЛЛТипЦел16ВКонтексте(ЛЛКонтекст к);
ЛЛТип ЛЛТипЦел32Контексте(ЛЛКонтекст к);
ЛЛТип ЛЛТипЦел64ВКонтексте(ЛЛКонтекст к);
ЛЛТип ЛЛТипЦел128ВКонтексте(ЛЛКонтекст к);
ЛЛТип ЛЛТипЦелВКонтексте(ЛЛКонтекст к, бцел члоБит);

/**
 * Получить целочисленный тип из глобального контекста
 * с указанной битовой длиной.
 */
ЛЛТип ЛЛТипЦел1();
ЛЛТип ЛЛТипЦел8();
ЛЛТип ЛЛТипЦел16();
ЛЛТип ЛЛТипЦел32();
ЛЛТип ЛЛТипЦел64();
ЛЛТип ЛЛТипЦел128();
ЛЛТип ЛЛТипЦел(бцел члоБит);
бцел ЛДайШиринуЦелТипа(ЛЛТип цчТи);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreTypeFloat Типы с Плавающей Точкой
 *
 * @{
 */

/**
 * Получить из контекста 16-битный тип с плавающей точкой.
 */
ЛЛТип ЛЛПолутипВКонтексте(ЛЛКонтекст к);

/**
 * Получить из контекста 32-битный тип с плавающей точкой.
 */
ЛЛТип ЛЛТипПлавВКонтексте(ЛЛКонтекст к);

/**
 * Получить из контекста 64-битный тип с плавающей точкой.
 */
ЛЛТип ЛЛТипДвоВКонтексте(ЛЛКонтекст к);

/**
 * Получить из контекста 80-битный тип с плавающей точкой (X87) .
 */
ЛЛТип ЛЛТипХ86ФП80ВКонтексте(ЛЛКонтекст к);

/**
 * Получить из контекста 128-битный тип с плавающей точкой 
 * (112-битная мантисса) .
 */
ЛЛТип ЛЛТипХ86ФП128ВКонтексте(ЛЛКонтекст к);

/**
 * Получить 128-битный тип с плавающей точкой (два 64-битника)
 * из контекста.
 */
ЛЛТип ЛЛТипППЦФП128ВКонтексте(ЛЛКонтекст к);

/**
 * Получить тип с плавающей точкой из глобального контекста.
 *
 * These map to the functions in this group of the same name.
 */
ЛЛТип ЛЛПолутип();
ЛЛТип ЛЛТипПлав();
ЛЛТип ЛЛТипДво();
ЛЛТип ЛЛТипХ86ФП80();
ЛЛТип ЛЛТипФП128();
ЛЛТип ЛЛТипППЦФП128();

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreTypeFunction Типы Функции
 *
 * @{
 */

/**
 * Получить тип функции, состояшей из определённой сигнатуры.
 *
 * Функция определена как кортеж из возвратного Типа, списка
 * типов параметров, и того, является ли она вариадической.
 */
ЛЛТип ЛЛТипФункция(ЛЛТип типВозврата,
                             ЛЛТип *типыПарам, бцел члоПарам,
                             ЛЛБул варарг_ли);

/**
 * Возвращает, является ли тип функции вариадическим.
 */
ЛЛБул ЛЛВараргФункции_ли(ЛЛТип типФункц);

/**
 * Получить тип, который возвращает данный тип функции.
 */
ЛЛТип ЛЛДайТипВозврата(ЛЛТип типФункц);

/**
 * Получить число параметров, принимаемых этой функцией.
 */
бцел ЛЛСчётТиповПарам(ЛЛТип типФункц);

/**
 * Получить типы параметров функции.
 *
 * Параметр приёмник должен указывать на предразмещённый массив из
 * ЛЛТип , величиной как минимум в LLVMCountParamTypes(). По возврату
 * первые записи LLVMCountParamTypes() в массиве будут наполнены
 * экземплярами ЛЛТип .
 *
 * @param типФункц Тип функции, над которой оперируем.
 * @param приёмник Адрес памяти массива, который будет наполнен результатом.
 */
проц ЛЛДайТипыПарам(ЛЛТип типФункц, ЛЛТип *приёмник);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreTypeStruct Типы Структура
 *
 * Эти функции относятся к экземплярам ЛЛТип.
 *
 * @see llvm::StructType
 *
 * @{
 */

/**
 * Создать новую структуру в контексте.
 *
 * Структура атрибутов указывается списком внутренних элементов/типов
 * и тем, могут ли они быть упакованы.
 *
 * @see llvm::StructType::create()
 */
ЛЛТип ЛЛТипСтруктВКонтексте(ЛЛКонтекст к, ЛЛТип *типыЭлтов,
                                    бцел члоЭлтов, ЛЛБул упакован_ли);

/**
 * Создать новый структурный тип в глобальном контексте.
 *
 * @see llvm::StructType::create()
 */
ЛЛТип ЛЛТипСтрукт(ЛЛТип *типыЭлтов, бцел члоЭлтов, ЛЛБул упакован_ли);

/**
 * Создать пустую структуру в контексте, с указанным именем.
 *
 * @see llvm::StructType::create()
 */
ЛЛТип ЛЛСтруктСоздайСИменем(ЛЛКонтекст к, ткст0 имя);

/**
 * Получить имя структуры.
 *
 * @see llvm::StructType::getName()
 */
ткст0 ЛЛДайИмяСтрукт(ЛЛТип тип);

/**
 * Установить содержимое структурного типа.
 *
 * @see llvm::StructType::setBody()
 */
проц ЛЛСтруктУстТело(ЛЛТип типСтрукт, ЛЛТип *типыЭлтов,
                       бцел члоЭлтов, ЛЛБул упакован_ли);

/**
 * Получить число элементов, определённых внутри этой структуры.
 *
 * @see llvm::StructType::getNumElements()
 */
бцел ЛЛПосчитайТипыЭлементовСтрукт(ЛЛТип типСтрукт);

/**
 * Получить элементы внутри структуры.
 *
 * Функции передаётся адрес предразмещённого массива из
 * ЛЛТип, длиной как минимум в LLVMCountStructElementTypes(). После
 * инвокации этот массив населяется элементами структуры.
 * Объекты из массива-приёмника будут иметь срок жизни, как у самой
 * структуры, равной сроку жизни контекста, в котором она находится.
 */
проц ЛЛДайТипыЭлементовСтрукт(ЛЛТип типСтрукт, ЛЛТип *приёмник);

/**
 * Получить тип элемента, расположенного по заданному индексу в структуре.
 *
 * @see llvm::StructType::getTypeAtIndex()
 */
ЛЛТип ЛЛСтруктДайТипНаИндексе(ЛЛТип типСтрукт, бцел i);

/**
 * Определить, упакована ли структура.
 *
 * @see llvm::StructType::isPacked()
 */
ЛЛБул ЛЛУпакованнаяСтруктура_ли(ЛЛТип типСтрукт);

/**
 * Определить, явялется ли структура опак (opaque).
 *
 * @see llvm::StructType::isOpaque()
 */
ЛЛБул ЛЛОпакСтрукт_ли(ЛЛТип типСтрукт);

/**
 * Определить, является ли структура литералом.
 *
 * @see llvm::StructType::isLiteral()
 */
ЛЛБул ЛЛЛитералСтрукт_ли(ЛЛТип типСтрукт);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreTypeSequential Последовательные Типы
 *
 * Последовательные типы представляют "массивы" типов. Это суперкласс
 * для типов массивов, векторов и указателей.
 *
 * @{
 */

/**
 * Получить тип элементов в последовательном типе.
 *
 * Работает над типами массивов, векторов и указателей.
 *
 * @see llvm::SequentialType::getElementType()
 */
ЛЛТип ЛЛДайТипЭлемента(ЛЛТип тип);

/**
 * Возвращает подтипы типа.
 *
 * @see llvm::Type::subtypes()
 */
проц ЛЛДайПодтипы(ЛЛТип Tp, ЛЛТип *масс);

/**
 *  Вернуть число типов в производном типе.
 *
 * @see llvm::Type::getNumContainedTypes()
 */
бцел ЛЛдайЧисКонтТипы(ЛЛТип Tp);

/**
 * Создать тип массива фиксированной длины, ссылающийся на определённый тип.
 *
 * Созданный тип будет существовать в контексте, в котором существуют
 * его элементы.
 *
 * @see llvm::ArrayType::get()
 */
ЛЛТип ЛЛТипМассив(ЛЛТип типЭлта, бцел члоЭлтов);

/**
 * Получить длину массивного типа.
 *
 * Работает только над типами, представляющими массивы.
 *
 * @see llvm::ArrayType::getNumElements()
 */
бцел ЛЛДайДлинуМассива(ЛЛТип типМассив);

/**
 * Создать указательный тип, указывающий на определённый тип.
 *
 * Созданный тип будет существовать в том же контексте, в котором
 * существует указываемый им тип.
 *
 * @see llvm::PointerType::get()
 */
ЛЛТип ЛЛТипУказатель(ЛЛТип типЭлта, бцел адрПрострво);

/**
 * Получить адресное пространство указывающего типа.
 *
 * Работает только над типами, представляющими собой указатели.
 *
 * @see llvm::PointerType::getAddressSpace()
 */
бцел ЛЛДАйАдрПрострУказателя(ЛЛТип типУказатель);

/**
 * Создать векторный тип, содержащий определенный тип и имеющий
 * определённое число элементов.
 *
 * Созданный тип будет существовать в том же контексте, что
 * и его элементы.
 *
 * @see llvm::VectorType::get()
 */
ЛЛТип ЛЛТипВектор(ЛЛТип типЭлта, бцел члоЭлтов);

/**
 * Получть число элементов в векторном типе.
 *
 * Работает только над типами, представляющими собой векторы.
 *
 * @see llvm::VectorType::getNumElements()
 */
бцел ЛЛДайРазмерВектора(ЛЛТип типВектор);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreTypeOther Прочие Типы
 *
 * @{
 */

/**
 * Создать тип проц в контексте.
 */
ЛЛТип ЛЛТипПроцВКонтексте(ЛЛКонтекст к);

/**
 * Создать тип ярлык в контексте.
 */
ЛЛТип ЛЛТипЯрлыкВКонтексте(ЛЛКонтекст к);

/**
 * Создать тип X86 MMX в контексте.
 */
ЛЛТип ЛЛТипХ86ММХВКонтексте(ЛЛКонтекст к);

/**
 * Создать тип токен в контексте.
 */
ЛЛТип ЛЛТипСемаВКонтексте(ЛЛКонтекст к);

/**
 * Создать тип метаданные в контексте.
 */
ЛЛТип ЛЛТипМетаданныеВКонтексте(ЛЛКонтекст к);

/**
 * Это подобно функциям выше, но работает в глобальном контексте.
 */
ЛЛТип ЛЛТипПроц();
ЛЛТип ЛЛТипЯрлык();
ЛЛТип ЛЛТипХ86ММХ();

/**
 * @}
 */

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValues Значения
 *
 * Часть объектной модели LLVM состоит из значений, которые образуют
 * очень богатую иерархию типов.
 *
 * ЛЛЗначение как правило представляет llvm::Value. В этом типе
 * богатая иерархия классов. В зависимости от полученного экземпляра,
 * не все API доступны.
 *
 * Callers can determine the type of an ЛЛЗначение by calling the
 * LLVMIsA* family of functions (e.g. LLVMIsAArgument()). These
 * functions are defined by a macro, so it isn't obvious which are
 * available by looking at the Doxygen source code. Instead, look at the
 * source definition of LLVM_FOR_EACH_VALUE_SUBCLASS and note the list
 * of знач names given. These знач names also correspond to classes in
 * the llvm::Value hierarchy.
 *
 * @{
 */
/+
#define LLVM_FOR_EACH_VALUE_SUBCLASS(macro) \
  macro(Argument)                           \
  macro(BasicBlock)                         \
  macro(InlineAsm)                          \
  macro(User)                               \
    macro(Constant)                         \
      macro(BlockAddress)                   \
      macro(ConstantAggregateZero)          \
      macro(ConstantArray)                  \
      macro(ConstantDataSequential)         \
        macro(ConstantDataArray)            \
        macro(ConstantDataVector)           \
      macro(ConstantExpr)                   \
      macro(ConstantFP)                     \
      macro(ConstantInt)                    \
      macro(ConstantPointerNull)            \
      macro(ConstantStruct)                 \
      macro(ConstantTokenNone)              \
      macro(ConstantVector)                 \
      macro(GlobalValue)                    \
        macro(GlobalAlias)                  \
        macro(GlobalIFunc)                  \
        macro(GlobalObject)                 \
          macro(Function)                   \
          macro(GlobalVariable)             \
      macro(UndefValue)                     \
    macro(Instruction)                      \
      macro(BinaryOperator)                 \
      macro(инстрВыз)                       \
        macro(IntrinsicInst)                \
          macro(DbgInfoIntrinsic)           \
            macro(DbgVariableIntrinsic)     \
              macro(DbgDeclareInst)         \
            macro(DbgLabelInst)             \
          macro(MemIntrinsic)               \
            macro(MemCpyInst)               \
            macro(MemMoveInst)              \
            macro(MemSetInst)               \
      macro(CmpInst)                        \
        macro(FCmpInst)                     \
        macro(ICmpInst)                     \
      macro(ExtractElementInst)             \
      macro(GetElementPtrInst)              \
      macro(InsertElementInst)              \
      macro(InsertValueInst)                \
      macro(LandingPadInst)                 \
      macro(PHINode)                        \
      macro(SelectInst)                     \
      macro(ShuffleVectorInst)              \
      macro(StoreInst)                      \
      macro(BranchInst)                     \
      macro(IndirectBrInst)                 \
      macro(инстрВып)                     \
      macro(ReturnInst)                     \
      macro(SwitchInst)                     \
      macro(UnreachableInst)                \
      macro(ResumeInst)                     \
      macro(CleanupReturnInst)              \
      macro(CatchReturnInst)                \
      macro(FuncletPadInst)                 \
        macro(кэчПадInst)                 \
        macro(CleanupPadInst)               \
      macro(UnaryInstruction)               \
        macro(AllocaInst)                   \
        macro(CastInst)                     \
          macro(AddrSpaceCastInst)          \
          macro(BitCastInst)                \
          macro(FPExtInst)                  \
          macro(FPToSIInst)                 \
          macro(FPToUIInst)                 \
          macro(FPTruncInst)                \
          macro(IntToPtrInst)               \
          macro(PtrToIntInst)               \
          macro(SExtInst)                   \
          macro(SIToFPInst)                 \
          macro(TruncInst)                  \
          macro(UIToFPInst)                 \
          macro(ZExtInst)                   \
        macro(ExtractValueInst)             \
        macro(LoadInst)                     \
        macro(VAArgInst)
+/
/**
 * @defgroup LLVMCCoreValueGeneral General APIs
 *
 * Functions in this section work on all ЛЛЗначение instances,
 * regardless of their sub-type. They correspond to functions available
 * on llvm::Value.
 *
 * @{
 */

/**
 * Получить тип значения.
 *
 * @see llvm::Value::getType()
 */
ЛЛТип ЛЛТипУ(ЛЛЗначение знач);

/**
 * Получить пронумерованный тип экземпляра знач.
 *
 * @see llvm::Value::getValueID()
 */
ЛЛРодЗначения ЛЛДайРодЗначения(ЛЛЗначение знач);

/**
 * Получить текстовое имя значения.
 *
 * @see llvm::Value::getName()
 */
ткст0 ЛЛДайИмяЗначения2(ЛЛЗначение знач, т_мера *длина);

/**
 * Установить текстовое имя значения.
 *
 * @see llvm::Value::setName()
 */
проц ЛЛУстИмяЗначения2(ЛЛЗначение знач, ткст0 имя, т_мера длинаИм);

/**
 * Ввести дамп представления значения на stderr.
 *
 * @see llvm::Value::dump()
 */
проц ЛЛЗначениеДампа(ЛЛЗначение знач);

/**
 * Return a string representation of the знач. Use
 * LLVMDisposeMessage to free the string.
 *
 * @see llvm::Value::print()
 */
ткст0 ЛЛВыведиЗначениеВСтроку(ЛЛЗначение знач);

/**
 * Replace all uses of a знач with another one.
 *
 * @see llvm::Value::replaceAllUsesWith()
 */
проц ЛЛЗамениВсеИспользованияНа(ЛЛЗначение старЗнач, ЛЛЗначение новЗнач);

/**
 * Determine whether the specified знач instance is constant.
 */
ЛЛБул ЛЛКонстанта_ли(ЛЛЗначение знач);

/**
 * Determine whether a знач instance is undefined.
 */
ЛЛБул ЛЛНеопр_ли(ЛЛЗначение знач);

/**
 * Convert знач instances between types.
 *
 * Internally, an ЛЛЗначение is "pinned" to a specific type. This
 * series of functions allows you to cast an instance to a specific
 * type.
 *
 * If the cast is not valid for the specified type, NULL is returned.
 *
 * @see llvm::dyn_cast_or_null<>
 */
/+
#define LLVM_DECLARE_VALUE_CAST(name) \
  ЛЛЗначение LLVMIsA##name(ЛЛЗначение знач);
LLVM_FOR_EACH_VALUE_SUBCLASS(LLVM_DECLARE_VALUE_CAST)
+/
ЛЛЗначение ЛЛАМДУзел_ли(ЛЛЗначение знач);
ЛЛЗначение ЛЛАМДТкст_ли(ЛЛЗначение знач);

/** Депрекировано: Use LLVMGetValueName2 instead. */
ткст0 ЛЛДайИмяЗначения(ЛЛЗначение знач);
/** Депрекировано: Use LLVMSetValueName2 instead. */
проц ЛЛУстИмяЗначения(ЛЛЗначение знач, ткст0 имя);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueUses Использование
 *
 * Этот модуль опеределяет фукнции, позволяющие наблюдать за использованием
 * ЛЛЗначение.
 *
 * Можно получить ЛЛИспользование для любого экземпляра ЛЛЗначение.
 * Каждое ЛЛИспользование (соответствующее экземпляру llvm::Use) содержит
 * llvm::User и llvm::Value.
 *
 * @{
 */

/**
 * Получить первое использование значения.
 *
 * Uses are obtained in an iterator fashion. First, call this function
 * to obtain a reference to the first use. Then, call LLVMGetNextUse()
 * on that instance and all subsequently obtained instances until
 * LLVMGetNextUse() returns NULL.
 *
 * @see llvm::Value::use_begin()
 */
ЛЛИспользование ЛЛДайПервоеИспользование(ЛЛЗначение знач);

/**
 * Получить следующее использование значения.
 *
 * This effectively advances the iterator. It returns NULL if you are on
 * the final use and no more are available.
 */
ЛЛИспользование ЛЛДайСледщИспользование(ЛЛИспользование u);

/**
 * Получить значение пользователя для пользователя.
 *
 * Возвращённое значение соответствует типу llvm::User.
 *
 * @see llvm::Use::getUser()
 */
ЛЛЗначение ЛЛДайПользователя(ЛЛИспользование u);

/**
 * Получить значение, которому соответствует это использование.
 *
 * @see llvm::Use::get().
 */
ЛЛЗначение ЛЛДайИспользованноеЗначение(ЛЛИспользование u);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueUser User знач
 *
 * Function in this group pertain to ЛЛЗначение instances that descent
 * from llvm::User. This includes constants, instructions, and
 * operators.
 *
 * @{
 */

/**
 * Получить операнд по определённому индексу из значения llvm::User.
 *
 * @see llvm::User::getOperand()
 */
ЛЛЗначение ЛЛДайОперанд(ЛЛЗначение знач, бцел инд);

/**
 * Получить использование операнда по определённому индексу из значения llvm::User.
 *
 * @see llvm::User::getOperandUse()
 */
ЛЛИспользование ЛЛДайИспользованиеОперанда(ЛЛЗначение знач, бцел инд);

/**
 * Установить операнд по определённому индексу в значении llvm::User.
 *
 * @see llvm::User::setOperand()
 */
проц ЛЛУстОперанд(ЛЛЗначение пользователь, бцел инд, ЛЛЗначение знач);

/**
 * Получить число операндов в значении llvm::User.
 *
 * @see llvm::User::getNumOperands()
 */
цел ЛЛДайЧлоОперандов(ЛЛЗначение знач);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueConstant Константы
 *
 * This section contains APIs for interacting with ЛЛЗначение that
 * correspond to llvm::Constant instances.
 *
 * These functions will work for any ЛЛЗначение in the llvm::Constant
 * class hierarchy.
 *
 * @{
 */

/**
 * Получить константное значение, ссылающееся на пустой (null) экземпляр какого-л. типа.
 *
 * @see llvm::Constant::getNullValue()
 */
ЛЛЗначение ЛЛКонстПусто(ЛЛТип тип); /* all zeroes */

/**
 * Obtain a constant знач referring to the instance of a type
 * consisting of all ones.
 *
 * This is only valid for integer types.
 *
 * @see llvm::Constant::getAllOnesValue()
 */
ЛЛЗначение ЛЛКонстВсеЕд(ЛЛТип тип);

/**
 * Obtain a constant знач referring to an undefined знач of a type.
 *
 * @see llvm::UndefValue::get()
 */
ЛЛЗначение ЛЛДайНеопр(ЛЛТип тип);

/**
 * Determine whether a знач instance is null.
 *
 * @see llvm::Constant::isNullValue()
 */
ЛЛБул ЛЛПусто_ли(ЛЛЗначение знач);

/**
 * Obtain a constant that is a constant pointer pointing to NULL for a
 * specified type.
 */
ЛЛЗначение ЛЛКонстУкПусто(ЛЛТип тип);

/**
 * @defgroup LLVMCCoreValueConstantScalar Scalar constants
 *
 * Functions in this group model ЛЛЗначение instances that correspond
 * to constants referring to scalar types.
 *
 * For integer types, the ЛЛТип parameter should correspond to a
 * llvm::цчТиpe instance and the returned ЛЛЗначение will
 * correspond to a llvm::ConstantInt.
 *
 * For floating point types, the ЛЛТип returned corresponds to a
 * llvm::ConstantFP.
 *
 * @{
 */

/**
 * Получить константное значение для численного типа.
 *
 * Возвращаемое значение соответствует llvm::ConstantInt.
 *
 * @see llvm::ConstantInt::get()
 *
 * @param типЦел Integer type to obtain знач of.
 * @param N The знач the returned instance should refer to.
 * @param SignExtend Whether to sign extend the produced знач.
 */
ЛЛЗначение ЛЛКонстЦел(ЛЛТип типЦел, бдол n, ЛЛБул расшЗнака);

/**
 * Obtain a constant знач for an integer of arbitrary precision.
 *
 * @see llvm::ConstantInt::get()
 */
ЛЛЗначение ЛЛКонстЦелПроизвольнойТочности(ЛЛТип типЦел, бцел члоСлов,
                                              uint64_t[] слова);

/**
 * Obtain a constant знач for an integer parsed from a string.
 *
 * атр similar API, LLVMConstIntOfStringAndSize is also available. If the
 * string's length is available, it is preferred to call that function
 * instead.
 *
 * @see llvm::ConstantInt::get()
 */
ЛЛЗначение ЛЛКонстЦелИзТкста(ЛЛТип типЦел, ткст0 текст,
                                  uint8_t корень);

/**
 * Obtain a constant знач for an integer parsed from a string with
 * specified length.
 *
 * @see llvm::ConstantInt::get()
 */
ЛЛЗначение ЛЛКонстЦелИзТкстаСРазмером(ЛЛТип типЦел, ткст0 текст,
                                         бцел длинс, uint8_t корень);

/**
 * Obtain a constant знач referring to a double floating point знач.
 */
ЛЛЗначение ЛЛКонстРеал(ЛЛТип типРеал, дво N);

/**
 * Obtain a constant for a floating point знач parsed from a string.
 *
 * атр similar API, LLVMConstRealOfStringAndSize is also available. It
 * should be used if the input string's length is known.
 */
ЛЛЗначение ЛЛКонстРеалИзТкста(ЛЛТип типРеал, ткст0 текст);

/**
 * Obtain a constant for a floating point знач parsed from a string.
 */
ЛЛЗначение ЛЛКонстРеалИзТкстаСРазмером(ЛЛТип типРеал, ткст0 текст, бцел длинс);

/**
 * Obtain the zero extended знач for an integer constant знач.
 *
 * @see llvm::ConstantInt::getZExtValue()
 */
бдол ЛЛКонстЦелДайНРасшЗначение(ЛЛЗначение констЗнач);

/**
 * Obtain the sign extended знач for an integer constant знач.
 *
 * @see llvm::ConstantInt::getSExtValue()
 */
дол ЛЛКонстЦелДайЗРасшЗначение(ЛЛЗначение констЗнач);

/**
 * Obtain the double знач for an floating point constant знач.
 * теряетИнфу_ли indicates if some precision was lost in the conversion.
 *
 * @see llvm::ConstantFP::getDoubleValue
 */
дво ЛЛКонстРеалДайДво(ЛЛЗначение констЗнач, ЛЛБул *теряетИнфу_ли);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueConstantComposite Composite Constants
 *
 * Functions in this group operate on composite constants.
 *
 * @{
 */

/**
 * Create a ConstantDataSequential and initialize it with a string.
 *
 * @see llvm::ConstantDataArray::getString()
 */
ЛЛЗначение ЛЛКонстТкстВКонтексте(ЛЛКонтекст к, ткст0 текст,
                                      бцел длина, ЛЛБул оканчиватьНаНулл_ли);

/**
 * Create a ConstantDataSequential with string content in the global context.
 *
 * This is the same as LLVMConstStringInContext except it operates on the
 * global context.
 *
 * @see LLVMConstStringInContext()
 * @see llvm::ConstantDataArray::getString()
 */
ЛЛЗначение ЛЛКонстТкст(ткст0 текст, бцел длина, ЛЛБул оканчиватьНаНулл_ли);

/**
 * Returns true if the specified constant is an array of i8.
 *
 * @see ConstantDataSequential::getAsString()
 */
ЛЛБул ЛЛКонстТкст_ли(ЛЛЗначение конст);

/**
 * Get the given constant data sequential as a string.
 *
 * @see ConstantDataSequential::getAsString()
 */
ткст0 ЛЛДайКакТкст(ЛЛЗначение конст, т_мера *длина);

/**
 * Create an anonymous ConstantStruct with the specified values.
 *
 * @see llvm::ConstantStruct::getAnon()
 */
ЛЛЗначение ЛЛКонстСтруктВКонтексте(ЛЛКонтекст к, ЛЛЗначение *констЗначч,
                                      бцел чло, ЛЛБул упакован_ли);

/**
 * Create a ConstantStruct in the global Context.
 *
 * This is the same as LLVMConstStructInContext except it operates on the
 * global Context.
 *
 * @see LLVMConstStructInContext()
 */
ЛЛЗначение ЛЛКонстСтрукт(ЛЛЗначение *констЗначч, бцел чло, ЛЛБул упакован_ли);

/**
 * Create a ConstantArray from values.
 *
 * @see llvm::ConstantArray::get()
 */
ЛЛЗначение ЛЛКонстМассив(ЛЛТип типЭлт, ЛЛЗначение *констЗначч, бцел длина);

/**
 * Create a non-anonymous ConstantStruct from values.
 *
 * @see llvm::ConstantStruct::get()
 */
ЛЛЗначение ЛЛИменованнаяКонстСтрукт(ЛЛТип типСтрукт,ЛЛЗначение *констЗначч,
                                  бцел чло);

/**
 * Get an element at specified инд as a constant.
 *
 * @see ConstantDataSequential::getElementAsConstant()
 */
ЛЛЗначение ЛЛДайЭлтКакКонст(ЛЛЗначение к, бцел инд);

/**
 * Create a ConstantVector from values.
 *
 * @see llvm::ConstantVector::get()
 */
ЛЛЗначение ЛЛКонстВектор(ЛЛЗначение *скалярКонстЗначч, бцел разм);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueConstantExpressions Константные Выражения
 *
 * Functions in this group correspond to APIs on llvm::ConstantExpr.
 *
 * @see llvm::ConstantExpr.
 *
 * @{
 */
ЛЛОпкод ЛЛДайКонстОпкод(ЛЛЗначение констЗнач);
ЛЛЗначение ЛЛРаскладУ(ЛЛТип тип);
ЛЛЗначение ЛЛРазмерУ(ЛЛТип тип);
ЛЛЗначение ЛЛКонстОтр(ЛЛЗначение констЗнач);
ЛЛЗначение LLConstNSWNeg(ЛЛЗначение констЗнач);
ЛЛЗначение LLConstNUWNeg(ЛЛЗначение констЗнач);
ЛЛЗначение ЛЛКонстПОтриц(ЛЛЗначение констЗнач);
ЛЛЗначение ЛЛКонстНе(ЛЛЗначение констЗнач);
ЛЛЗначение ЛЛКонстДобавь(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение LLConstNSWAdd(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение LLConstNUWAdd(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстПСложи(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстОтними(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение LLConstNSWSub(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение LLConstNUWSub(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстПОтними(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстУмножь(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение LLConstNSWMul(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение LLConstNUWMul(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстПУмножь(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстБДели(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстТочноБДели(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстЗДели(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстТочноЗДели(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстПДели(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение LLConstURem(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение LLConstSRem(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение LLConstFRem(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстИ(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстИли(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстИИли(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстЦСравн(ЛЛЦелПредикат предикат,
                           ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстПСравн(ЛЛПредикатРеала предикат,
                           ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстСдвл(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение ЛЛКонстСдвп(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение LLConstAShr(ЛЛЗначение константаLHS, ЛЛЗначение константаRHS);
ЛЛЗначение LLConstGEP(ЛЛЗначение констЗнач,
                          ЛЛЗначение *ConstantIndices, бцел члоИндексов);
ЛЛЗначение LLConstGEP2(ЛЛТип тип, ЛЛЗначение констЗнач,
                           ЛЛЗначение *ConstantIndices, бцел члоИндексов);
ЛЛЗначение LLConstInBoundsGEP(ЛЛЗначение констЗнач,
                                  ЛЛЗначение *ConstantIndices,
                                  бцел члоИндексов);
ЛЛЗначение LLConstInBoundsGEP2(ЛЛТип тип, ЛЛЗначение констЗнач,
                                   ЛЛЗначение *ConstantIndices,
                                   бцел члоИндексов);
ЛЛЗначение ЛЛКонстОбрежь(ЛЛЗначение констЗнач, ЛЛТип вТип);
ЛЛЗначение ЛЛКонстЗРасш(ЛЛЗначение констЗнач, ЛЛТип вТип);
ЛЛЗначение ЛЛКонстНРасш(ЛЛЗначение констЗнач, ЛЛТип вТип);
ЛЛЗначение ЛЛКонстПЗОбрежь(ЛЛЗначение констЗнач, ЛЛТип вТип);
ЛЛЗначение ЛЛКонстПЗРасш(ЛЛЗначение констЗнач, ЛЛТип вТип);
ЛЛЗначение ЛЛКонстБЦвПЗ(ЛЛЗначение констЗнач, ЛЛТип вТип);
ЛЛЗначение ЛЛКонстЗЦвПЗ(ЛЛЗначение констЗнач, ЛЛТип вТип);
ЛЛЗначение ЛЛКонстПЗвБЦ(ЛЛЗначение констЗнач, ЛЛТип вТип);
ЛЛЗначение ЛЛКонстПЗвЗЦ(ЛЛЗначение констЗнач, ЛЛТип вТип);
ЛЛЗначение ЛЛКонстУкзВЦел(ЛЛЗначение констЗнач, ЛЛТип вТип);
ЛЛЗначение ЛЛКонстЦелВУкз(ЛЛЗначение констЗнач, ЛЛТип вТип);
ЛЛЗначение ЛЛКонстБитКаст(ЛЛЗначение констЗнач, ЛЛТип вТип);
ЛЛЗначение ЛЛКонстАдрПрострКаст(ЛЛЗначение констЗнач, ЛЛТип вТип);
ЛЛЗначение ЛЛКонстНРасшИлиБитКаст(ЛЛЗначение констЗнач,
                                    ЛЛТип вТип);
ЛЛЗначение ЛЛКонстЗРасшИлиБитКаст(ЛЛЗначение констЗнач,
                                    ЛЛТип вТип);
ЛЛЗначение ЛЛКонстОбрежьИлиБитКаст(ЛЛЗначение констЗнач,
                                     ЛЛТип вТип);
ЛЛЗначение ЛЛКонстУказательКаст(ЛЛЗначение констЗнач,
                                  ЛЛТип вТип);
ЛЛЗначение ЛЛКонстЦелКаст(ЛЛЗначение констЗнач, ЛЛТип вТип,
                              ЛЛБул соЗнаком_ли);
ЛЛЗначение ЛЛКонстПЗКаст(ЛЛЗначение констЗнач, ЛЛТип вТип);
ЛЛЗначение ЛЛКонстВыбор(ЛЛЗначение ConstantCondition,
                             ЛЛЗначение ConstantIfTrue,
                             ЛЛЗначение ConstantIfFalse);
ЛЛЗначение ЛЛКонстИзвлекиЭлемент(ЛЛЗначение VectorConstant,
                                     ЛЛЗначение IndexConstant);
ЛЛЗначение ЛЛКонстВставьЭлемент(ЛЛЗначение VectorConstant,
                                    ЛЛЗначение ElementValueConstant,
                                    ЛЛЗначение IndexConstant);
ЛЛЗначение ЛЛКонстШафлВектор(ЛЛЗначение VectorAConstant,
                                    ЛЛЗначение VectorBConstant,
                                    ЛЛЗначение MaskConstant);
ЛЛЗначение ЛЛКонстИзвлекиЗначение(ЛЛЗначение AggConstant, бцел *IdxList,
                                   бцел NumIdx);
ЛЛЗначение ЛЛКонстВставьЗначение(ЛЛЗначение AggConstant,
                                  ЛЛЗначение ElementValueConstant,
                                  бцел *IdxList, бцел NumIdx);
ЛЛЗначение ЛЛАдрБлока(ЛЛЗначение ф, ЛЛБазовыйБлок ББ);

/** Депрекировано: Use LLVMGetInlineAsm instead. */
ЛЛЗначение ЛЛКонстИнлайнАсм(ЛЛТип тип, ткст0 ткстАсм, ткст0 констрейнты,
                                ЛЛБул естьПобЭффект, ЛЛБул естьСтэкРаскладки);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueConstantGlobals глоб Values
 *
 * This group contains functions that operate on global values. Functions in
 * this group relate to functions in the llvm::GlobalValue class tree.
 *
 * @see llvm::GlobalValue
 *
 * @{
 */

ЛЛМодуль ЛЛДайГлобРодителя(ЛЛЗначение глоб);
ЛЛБул ЛЛДекларация_ли(ЛЛЗначение глоб);
ЛЛКомпоновка ЛЛДайКомпоновку(ЛЛЗначение глоб);
проц ЛЛУстКомпоновку(ЛЛЗначение глоб, ЛЛКомпоновка компоновка);
ткст0 ЛЛДайСекцию(ЛЛЗначение глоб);
проц ЛЛУстСекцию(ЛЛЗначение глоб, ткст0 секция);
ЛЛВидимость ЛЛДайВидимость(ЛЛЗначение глоб);
проц ЛЛУстВидимость(ЛЛЗначение глоб, ЛЛВидимость вид);
ЛЛКлассХранДЛЛ ЛЛДайКлассХраненияДЛЛ(ЛЛЗначение глоб);
проц ЛЛУстКлассХраненияДЛЛ(ЛЛЗначение глоб, ЛЛКлассХранДЛЛ класс);
ЛЛБезымАдрес ЛЛДайБезымянныйАдрес(ЛЛЗначение глоб);
проц ЛЛУстБезымянныйАдрес(ЛЛЗначение глоб, ЛЛБезымАдрес безымАдр);

/**
 * Returns the "знач type" of a global знач.  This differs from the formal
 * type of a global знач which is always a pointer type.
 *
 * @see llvm::GlobalValue::getValueType()
 */
ЛЛТип ЛЛГлобДайТипЗначения(ЛЛЗначение глоб);

/** Депрекировано: Use LLVMGetUnnamedAddress instead. */
ЛЛБул ЛЛЕстьБезымянныйАдр(ЛЛЗначение глоб);
/** Депрекировано: Use LLVMSetUnnamedAddress instead. */
проц ЛЛУстБезымянныйАдр(ЛЛЗначение глоб, ЛЛБул естьБезымАдр_ли);

/**
 * @defgroup LLVMCCoreValueWithAlignment Values with alignment
 *
 * Functions in this group only apply to values with alignment, i.e.
 * global variables, load and store instructions.
 */

/**
 * Obtain the preferred alignment of the знач.
 * @see llvm::AllocaInst::getAlignment()
 * @see llvm::LoadInst::getAlignment()
 * @see llvm::StoreInst::getAlignment()
 * @see llvm::GlobalValue::getAlignment()
 */
бцел ЛЛДайРаскладку(ЛЛЗначение З);

/**
 * Set the preferred alignment of the знач.
 * @see llvm::AllocaInst::setAlignment()
 * @see llvm::LoadInst::setAlignment()
 * @see llvm::StoreInst::setAlignment()
 * @see llvm::GlobalValue::setAlignment()
 */
проц ЛЛУстРаскладку(ЛЛЗначение З, бцел байты);

/**
 * Sets a metadata attachment, erasing the existing metadata attachment if
 * it already exists for the given kind.
 *
 * @see llvm::GlobalObject::setMetadata()
 */
проц ЛЛГлоб_УстановиМетаданные(ЛЛЗначение глоб, бцел род, ЛЛМетаданные МД);

/**
 * Erases a metadata attachment of the given kind if it exists.
 *
 * @see llvm::GlobalObject::eraseMetadata()
 */
проц ЛЛГлоб_СотриМетаданные(ЛЛЗначение глоб, бцел род);

/**
 * Removes all metadata attachments from this знач.
 *
 * @see llvm::GlobalObject::clearMetadata()
 */
проц ЛЛГлоб_СбросьМетаданные(ЛЛЗначение глоб);

/**
 * Retrieves an array of metadata entries representing the metadata attached to
 * this знач. The caller is responsible for freeing this array by calling
 * \конст LLVMDisposeValueMetadataEntries.
 *
 * @see llvm::GlobalObject::getAllMetadata()
 */
ЛЛЗаписьМетаданныхЗначения *ЛЛГлоб_КопируйВсеМетаданные(ЛЛЗначение знач,
                                                  т_мера *члоЗапп);

/**
 * Удалить записи метаданных значений.
 */
проц ЛЛВыместиЗаписиМетаданныхЗначения(ЛЛЗаписьМетаданныхЗначения *записи);

/**
 * Returns the kind of a знач metadata entry at a specific инд.
 */
бцел ЛЛЗначение_ЗаписиМетаданных_ДайРод(ЛЛЗаписьМетаданныхЗначения *записи,
                                         бцел индекс);

/**
 * Returns the underlying metadata node of a знач metadata entry at a
 * specific инд.
 */
ЛЛМетаданные
ЛЛЗначение_ЗаписиМетаданных_ДайМетаданные(ЛЛЗаписьМетаданныхЗначения *записи,
                                    бцел индекс);

/**
 * @}
 */

/**
 * @defgroup LLVMCoreValueConstantGlobalVariable глоб Variables
 *
 * This group contains functions that operate on global variable values.
 *
 * @see llvm::GlobalVariable
 *
 * @{
 */
ЛЛЗначение ЛЛДобавьГлоб(ЛЛМодуль м, ЛЛТип тип, ткст0 имя);
ЛЛЗначение ЛЛДобавьГлобВАдрПрострво(ЛЛМодуль м, ЛЛТип тип, ткст0 имя,
                                         бцел адрПрострво);
ЛЛЗначение ЛЛДайИменованныйГлоб(ЛЛМодуль м, ткст0 имя);
ЛЛЗначение ЛЛДайПервыйГлоб(ЛЛМодуль м);
ЛЛЗначение ЛЛДайПоследнийГлоб(ЛЛМодуль м);
ЛЛЗначение ЛЛДайСледщГлоб(ЛЛЗначение глобПеремн);
ЛЛЗначение ЛЛДайПредшГлоб(ЛЛЗначение глобПеремн);
проц ЛЛУдалиГлоб(ЛЛЗначение глобПеремн);
ЛЛЗначение ЛЛДайИнициализатор(ЛЛЗначение глобПеремн);
проц ЛЛУстИнициализатор(ЛЛЗначение глобПеремн, ЛЛЗначение констЗнач);
ЛЛБул ЛЛНителок_ли(ЛЛЗначение глобПеремн);
проц ЛЛУстНителок(ЛЛЗначение глобПеремн, ЛЛБул нителок_ли);
ЛЛБул ЛЛГлобКонст_ли(ЛЛЗначение глобПеремн);
проц ЛЛУстГлобКонст(ЛЛЗначение глобПеремн, ЛЛБул конст_ли);
ЛЛНителокРежим ЛЛДайНителокРежим(ЛЛЗначение глобПеремн);
проц ЛЛУстНителокРежим(ЛЛЗначение глобПеремн, ЛЛНителокРежим режим);
ЛЛБул ЛЛИзвнеИнициализуем_ли(ЛЛЗначение глобПеремн);
проц ЛЛУстИзвнеИнициализуем(ЛЛЗначение глобПеремн, ЛЛБул расшИниц_ли);

/**
 * @}
 */

/**
 * @defgroup LLVMCoreValueConstantGlobalAlias глоб Aliases
 *
 * This group contains function that operate on global alias values.
 *
 * @see llvm::GlobalAlias
 *
 * @{
 */
ЛЛЗначение ЛЛДобавьНик(ЛЛМодуль м, ЛЛТип тип, ЛЛЗначение ники, ткст0 имя);

/**
 * Obtain a GlobalAlias знач from a Module by its name.
 *
 * The returned знач corresponds to a llvm::GlobalAlias знач.
 *
 * @see llvm::Module::getNamedAlias()
 */
ЛЛЗначение ЛЛДайИменованГлобНик(ЛЛМодуль м, ткст0 имя, т_мера длинаИм);

/**
 * Obtain an iterator to the first GlobalAlias in a Module.
 *
 * @see llvm::Module::alias_begin()
 */
ЛЛЗначение ЛЛДайПервыйГлобНик(ЛЛМодуль м);

/**
 * Obtain an iterator to the last GlobalAlias in a Module.
 *
 * @see llvm::Module::alias_end()
 */
ЛЛЗначение ЛЛДайПоследнийГлобНик(ЛЛМодуль м);

/**
 * Advance a GlobalAlias iterator to the next GlobalAlias.
 *
 * Returns NULL if the iterator was already at the end and there are no more
 * global aliases.
 */
ЛЛЗначение ЛЛДайСледщГлобНик(ЛЛЗначение гА);

/**
 * Decrement a GlobalAlias iterator to the previous GlobalAlias.
 *
 * Returns NULL if the iterator was already at the beginning and there are
 * no previous global aliases.
 */
ЛЛЗначение ЛЛДайПредшГлобНик(ЛЛЗначение гА);

/**
 * Retrieve the target знач of an alias.
 */
ЛЛЗначение ЛЛАлиас_ДайНики(ЛЛЗначение ник);

/**
 * Set the target знач of an alias.
 */
проц ЛЛАлиас_УстНики(ЛЛЗначение ник, ЛЛЗначение ники);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueFunction Function values
 *
 * Functions in this group operate on ЛЛЗначение instances that
 * correspond to llvm::Function instances.
 *
 * @see llvm::Function
 *
 * @{
 */

/**
 * Remove a function from its containing module and deletes it.
 *
 * @see llvm::Function::eraseFromParent()
 */
проц ЛЛУдалиФункц(ЛЛЗначение фн);

/**
 * Check whether the given function has a personality function.
 *
 * @see llvm::Function::hasPersonalityFn()
 */
ЛЛБул ЛЛЕстьПерсоналФн_ли(ЛЛЗначение фн);

/**
 * Obtain the personality function attached to the function.
 *
 * @see llvm::Function::getPersonalityFn()
 */
ЛЛЗначение ЛЛДайПерсоналФн(ЛЛЗначение фн);

/**
 * Set the personality function attached to the function.
 *
 * @see llvm::Function::setPersonalityFn()
 */
проц ЛЛУстПерсоналФн(ЛЛЗначение фн, ЛЛЗначение PersonalityFn);

/**
 * Obtain the intrinsic ид number which matches the given function name.
 *
 * @see llvm::Function::lookupIntrinsicID()
 */
бцел ЛЛИщиИнтринсикИД(ткст0 имя, т_мера длинаИм);

/**
 * Obtain the ид number from a function instance.
 *
 * @see llvm::Function::getIntrinsicID()
 */
бцел ЛЛДАйИнтринсикИД(ЛЛЗначение фн);

/**
 * Create or insert the declaration of an intrinsic.  For overloaded intrinsics,
 * parameter types must be provided to uniquely identify an overload.
 *
 * @see llvm::Intrinsic::getDeclaration()
 */
ЛЛЗначение ЛЛДАйИнтринсикДекл(ЛЛМодуль мод, бцел ид, ЛЛТип *типыПарам,
                                         т_мера члоПарам);

/**
 * Retrieves the type of an intrinsic.  For overloaded intrinsics, parameter
 * types must be provided to uniquely identify an overload.
 *
 * @see llvm::Intrinsic::getType()
 */
ЛЛТип ЛЛИнтринсик_ДайТип(ЛЛКонтекст кткст, бцел ид, ЛЛТип *типыПарам, т_мера члоПарам);

/**
 * Retrieves the name of an intrinsic.
 *
 * @see llvm::Intrinsic::getName()
 */
ткст0 ЛЛИнтринсик_ДайИмя(бцел ид, т_мера *длинаИм);

/**
 * Copies the name of an overloaded intrinsic identified by a given list of
 * parameter types.
 *
 * Unlike LLVMIntrinsicGetName, the caller is responsible for freeing the
 * returned string.
 *
 * @see llvm::Intrinsic::getName()
 */
ткст0 ЛЛИнтринсик_КопируйПерегруженИмя(бцел ид, ЛЛТип *типыПарам,
                                            т_мера члоПарам,
                                            т_мера *длинаИм);

/**
 * Obtain if the intrinsic identified by the given ид is overloaded.
 *
 * @see llvm::Intrinsic::isOverloaded()
 */
ЛЛБул ЛЛИнтринсик_Перегружен_ли(бцел ид);

/**
 * Obtain the calling function of a function.
 *
 * The returned знач corresponds to the LLVMCallConv enumeration.
 *
 * @see llvm::Function::getCallingConv()
 */
бцел ЛЛДайКонвВызФунции(ЛЛЗначение фн);

/**
 * Set the calling convention of a function.
 *
 * @see llvm::Function::setCallingConv()
 *
 * @param фн Function to operate on
 * @param кВыз LLVMCallConv to set calling convention to
 */
проц ЛЛУстКонвВызФунции(ЛЛЗначение фн, бцел кВыз);

/**
 * Obtain the name of the garbage collector to use during code
 * generation.
 *
 * @see llvm::Function::getGC()
 */
ткст0 ЛЛДайСМ(ЛЛЗначение фн);

/**
 * Определить используемый сборщик мусора при генерации кода.
 *
 * @see llvm::Function::setGC()
 */
проц ЛЛУстСМ(ЛЛЗначение фн, ткст0 имя);

/**
 * Добавить атрибут к функции.
 *
 * @see llvm::Function::addAttribute()
 */
проц ЛЛДобавьАтрПоИндексу(ЛЛЗначение ф, ЛЛИндексАтрибута инд,
                             ЛЛАтрибут атр);
бцел ЛЛДайСчётАтровПоИндексу(ЛЛЗначение ф, ЛЛИндексАтрибута инд);
проц ЛЛДайАтрыПоИндексу(ЛЛЗначение ф, ЛЛИндексАтрибута инд,
                              ЛЛАтрибут *атры);
ЛЛАтрибут ЛЛДайАтрПеречняПоИндексу(ЛЛЗначение ф,
                                             ЛЛИндексАтрибута инд,
                                             бцел идРода);
ЛЛАтрибут ЛЛДайТкстАтрПоИндексу(ЛЛЗначение ф,
                                               ЛЛИндексАтрибута инд,
                                               ткст0 K, бцел KLen);
проц ЛЛУдалиАтрПеречняПоИндексу(ЛЛЗначение ф, ЛЛИндексАтрибута инд,
                                    бцел идРода);
проц ЛЛУдалиТкстАтрПоИндексу(ЛЛЗначение ф, ЛЛИндексАтрибута инд,
                                      ткст0 K, бцел KLen);

/**
 * Add a target-dependent attribute to a function
 * @see llvm::AttrBuilder::addAttribute()
 */
проц ЛЛДобавьЦелеЗависимАтрФции(ЛЛЗначение фн, ткст0 атр, ткст0 З);

/**
 * @defgroup LLVMCCoreValueFunctionParameters Параметры Функции
 *
 * Functions in this group relate to arguments/parameters on functions.
 *
 * Functions in this group expect ЛЛЗначение instances that correspond
 * to llvm::Function instances.
 *
 * @{
 */

/**
 * Получить у функции число параметров.
 *
 * @see llvm::Function::arg_size()
 */
бцел ЛЛПосчитайПарамы(ЛЛЗначение фн);

/**
 * Получить параметры у функции.
 *
 * The takes a pointer to a pre-allocated array of ЛЛЗначение that is
 * at least LLVMCountParams() long. This array will be filled with
 * ЛЛЗначение instances which correspond to the parameters the
 * function receives. Each ЛЛЗначение corresponds to a llvm::Argument
 * instance.
 *
 * @see llvm::Function::arg_begin()
 */
проц ЛЛДайПарамы(ЛЛЗначение фн, ЛЛЗначение *парамы);

/**
 * Получить параметр по заданному инд.
 *
 * Параметры индексируются от 0.
 *
 * @see llvm::Function::arg_begin()
 */
ЛЛЗначение ЛЛДайПарам(ЛЛЗначение фн, бцел индекс);

/**
 * Obtain the function to which this argument belongs.
 *
 * Unlike other functions in this group, this one takes an ЛЛЗначение
 * that corresponds to a llvm::Attribute.
 *
 * The returned ЛЛЗначение is the llvm::Function to which this
 * argument belongs.
 */
ЛЛЗначение ЛЛДайПредкаПарам(ЛЛЗначение инстр);

/**
 * Obtain the first parameter to a function.
 *
 * @see llvm::Function::arg_begin()
 */
ЛЛЗначение ЛЛДайПервПарам(ЛЛЗначение фн);

/**
 * Получить последний параметр функции.
 *
 * @see llvm::Function::arg_end()
 */
ЛЛЗначение ЛЛДайПоследнПарам(ЛЛЗначение фн);

/**
 * Получить следующий параметр функции.
 *
 * This takes an ЛЛЗначение obtained from LLVMGetFirstParam() (which is
 * actually a wrapped iterator) and obtains the next parameter from the
 * underlying iterator.
 */
ЛЛЗначение ЛЛДайСледщПарам(ЛЛЗначение арг);

/**
 * Получить предыдущий параметр функции.
 *
 * This is the opposite of LLVMGetNextParam().
 */
ЛЛЗначение ЛЛДайПредшПарам(ЛЛЗначение арг);

/**
 * Установить раскладку для параметра функции.
 *
 * @see llvm::Argument::addAttr()
 * @see llvm::AttrBuilder::addAlignmentAttr()
 */
проц ЛЛУстРаскладПарама(ЛЛЗначение арг, бцел расклад);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueGlobalIFunc IFuncs
 *
 * Functions in this group relate to indirect functions.
 *
 * Functions in this group expect ЛЛЗначение instances that correspond
 * to llvm::GlobalIFunc instances.
 *
 * @{
 */

/**
 * Add a global indirect function to a module under a specified name.
 *
 * @see llvm::GlobalIFunc::create()
 */
ЛЛЗначение ЛЛДобавьГлобИФункц(ЛЛМодуль м, ткст0 имя, т_мера длинаИм,
                                ЛЛТип тип, бцел адрПрострво,
                                ЛЛЗначение ресольвер);

/**
 * Obtain a GlobalIFunc знач from a Module by its name.
 *
 * The returned знач corresponds to a llvm::GlobalIFunc знач.
 *
 * @see llvm::Module::getNamedIFunc()
 */
ЛЛЗначение ЛЛДайИменованГлобИФункц(ЛЛМодуль м, ткст0 имя, т_мера длинаИм);

/**
 * Obtain an iterator to the first GlobalIFunc in a Module.
 *
 * @see llvm::Module::ifunc_begin()
 */
ЛЛЗначение ЛЛДайПервГлобИФункц(ЛЛМодуль м);

/**
 * Obtain an iterator to the last GlobalIFunc in a Module.
 *
 * @see llvm::Module::ifunc_end()
 */
ЛЛЗначение ЛЛДайПоследнГлобИФункц(ЛЛМодуль м);

/**
 * Advance a GlobalIFunc iterator to the next GlobalIFunc.
 *
 * Returns NULL if the iterator was already at the end and there are no more
 * global aliases.
 */
ЛЛЗначение ЛЛДайСледщГлобИФункц(ЛЛЗначение иФункц);

/**
 * Decrement a GlobalIFunc iterator to the previous GlobalIFunc.
 *
 * Returns NULL if the iterator was already at the beginning and there are
 * no previous global aliases.
 */
ЛЛЗначение ЛЛДайПредшГлобИФункц(ЛЛЗначение иФункц);
  
/**
 * Retrieves the resolver function associated with this indirect function, or
 * NULL if it doesn't not exist.
 *
 * @see llvm::GlobalIFunc::getResolver()
 */
ЛЛЗначение ЛЛДайРезольверГлобИФункц(ЛЛЗначение иФункц);

/**
 * Sets the resolver function associated with this indirect function.
 *
 * @see llvm::GlobalIFunc::setResolver()
 */
проц ЛЛУстРезольверГлобИФункц(ЛЛЗначение иФункц, ЛЛЗначение ресольвер);

/**
 * Remove a global indirect function from its parent module and delete it.
 *
 * @see llvm::GlobalIFunc::eraseFromParent()
 */
проц ЛЛСотриГлобИФункц(ЛЛЗначение иФункц);

/**
 * Remove a global indirect function from its parent module.
 *
 * This unlinks the global indirect function from its containing module but
 * keeps it alive.
 *
 * @see llvm::GlobalIFunc::removeFromParent()
 */
проц ЛЛУдалиГлобИФункц(ЛЛЗначение иФункц);


/**
 * @defgroup LLVMCCoreValueMetadata Metadata
 *
 * @{
 */

/**
 * Create an MDString знач from a given string знач.
 *
 * The MDString знач does not take ownership of the given string, it remains
 * the responsibility of the caller to free it.
 *
 * @see llvm::MDString::get()
 */
ЛЛМетаданные ЛЛМДТкстВКонтексте2(ЛЛКонтекст к, ткст0 текст, т_мера длинс);

/**
 * Create an MDNode знач with the given array of operands.
 *
 * @see llvm::MDNode::get()
 */
ЛЛМетаданные ЛЛМДУзелВКонтексте2(ЛЛКонтекст к, ЛЛМетаданные *MDs, т_мера чло);

/**
 * Obtain a Metadata as a знач.
 */
ЛЛЗначение ЛЛМетаданныеКакЗначение(ЛЛКонтекст к, ЛЛМетаданные МД);

/**
 * Obtain a знач as a Metadata.
 */
ЛЛМетаданные ЛЛЗначениеКакМетаданные(ЛЛЗначение знач);

/**
 * Obtain the underlying string from a MDString знач.
 *
 * @param З Instance to obtain string from.
 * @param длина Memory address which will hold length of returned string.
 * @return String data in MDString.
 */
ткст0 ЛЛДайМДТкст(ЛЛЗначение З, бцел *длина);

/**
 * Obtain the number of operands from an MDNode знач.
 *
 * @param З MDNode to get number of operands from.
 * @return Number of operands of the MDNode.
 */
бцел ЛЛДайЧлоОперандовМДУзла(ЛЛЗначение З);

/**
 * Obtain the given MDNode's operands.
 *
 * The passed ЛЛЗначение pointer should point to enough memory to hold all of
 * the operands of the given MDNode (see LLVMGetMDNodeNumOperands) as
 * LLVMValueRefs. This memory will be populated with the LLVMValueRefs of the
 * MDNode's operands.
 *
 * @param З MDNode to get the operands from.
 * @param приёмник Destination array for operands.
 */
проц ЛЛДайОперандыМДУзла(ЛЛЗначение З, ЛЛЗначение *приёмник);

/** Депрекировано: Use LLVMMDStringInContext2 instead. */
ЛЛЗначение ЛЛМДТкстВКонтексте(ЛЛКонтекст к, ткст0 текст, бцел длинс);
/** Депрекировано: Use LLVMMDStringInContext2 instead. */
ЛЛЗначение ЛЛМДТкст(ткст0 текст, бцел длинс);
/** Депрекировано: Use LLVMMDNodeInContext2 instead. */
ЛЛЗначение ЛЛМДУзелВКонтексте(ЛЛКонтекст к, ЛЛЗначение *Vals, бцел чло);
/** Депрекировано: Use LLVMMDNodeInContext2 instead. */
ЛЛЗначение ЛЛМДУзел(ЛЛЗначение *Vals, бцел чло);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueBasicBlock Basic блок
 *
 * атр basic блок represents a single entry single exit section of code.
 * Basic blocks contain a list of instructions which form the body of
 * the блок.
 *
 * Basic blocks belong to functions. They have the type of label.
 *
 * Basic blocks are themselves values. However, the к API models them as
 * ЛЛБазовыйБлок.
 *
 * @see llvm::BasicBlock
 *
 * @{
 */

/**
 * Convert a basic блок instance to a знач type.
 */
ЛЛЗначение ЛЛБазБлокКакЗначение(ЛЛБазовыйБлок ББ);

/**
 * Determine whether an ЛЛЗначение is itself a basic блок.
 */
ЛЛБул ЛЛЗначение_БазБлок_ли(ЛЛЗначение знач);

/**
 * Convert an ЛЛЗначение to an ЛЛБазовыйБлок instance.
 */
ЛЛБазовыйБлок ЛЛЗначениеКакБазБлок(ЛЛЗначение знач);

/**
 * Obtain the string name of a basic блок.
 */
ткст0 ЛЛДайИмяБазБлока(ЛЛБазовыйБлок ББ);

/**
 * Obtain the function to which a basic блок belongs.
 *
 * @see llvm::BasicBlock::getParent()
 */
ЛЛЗначение ЛЛДайРодителяБазБлока(ЛЛБазовыйБлок ББ);

/**
 * Obtain the terminator instruction for a basic блок.
 *
 * If the basic блок does not have a terminator (it is not well-formed
 * if it doesn't), then NULL is returned.
 *
 * The returned ЛЛЗначение corresponds to an llvm::Instruction.
 *
 * @see llvm::BasicBlock::getTerminator()
 */
ЛЛЗначение ЛЛДайТерминаторБазБлока(ЛЛБазовыйБлок ББ);

/**
 * Obtain the number of basic blocks in a function.
 *
 * @param фн Function знач to operate on.
 */
бцел ЛЛПосчитайБазБлоки(ЛЛЗначение фн);

/**
 * Obtain all of the basic blocks in a function.
 *
 * This operates on a function знач. The ББки parameter is a
 * pointer to a pre-allocated array of ЛЛБазовыйБлок of at least
 * LLVMCountBasicBlocks() in length. This array is populated with
 * ЛЛБазовыйБлок instances.
 */
проц ЛЛДайБазБлоки(ЛЛЗначение фн, ЛЛБазовыйБлок *ББки);

/**
 * Obtain the first basic блок in a function.
 *
 * The returned basic блок can be used as an iterator. You will likely
 * eventually call into LLVMGetNextBasicBlock() with it.
 *
 * @see llvm::Function::begin()
 */
ЛЛБазовыйБлок ЛЛДайПервБазБлок(ЛЛЗначение фн);

/**
 * Obtain the last basic блок in a function.
 *
 * @see llvm::Function::end()
 */
ЛЛБазовыйБлок ЛЛДайПоследнБазБлок(ЛЛЗначение фн);

/**
 * Advance a basic блок iterator.
 */
ЛЛБазовыйБлок ЛЛДайСледщБазБлок(ЛЛБазовыйБлок ББ);

/**
 * Go backwards in a basic блок iterator.
 */
ЛЛБазовыйБлок ЛЛДайПредшБазБлок(ЛЛБазовыйБлок ББ);

/**
 * Obtain the basic блок that corresponds to the entry point of a
 * function.
 *
 * @see llvm::Function::getEntryBlock()
 */
ЛЛБазовыйБлок ЛЛДайВводнБазБлок(ЛЛЗначение фн);

/**
 * Insert the given basic блок after the insertion point of the given построитель.
 *
 * The insertion point must be valid.
 *
 * @see llvm::Function::BasicBlockListType::insertAfter()
 */
проц ЛЛВставьСущБазБлокПослеБлокаВставки(ЛЛПостроитель построитель,
                                                  ЛЛБазовыйБлок ББ);

/**
 * Append the given basic блок to the basic блок list of the given function.
 *
 * @see llvm::Function::BasicBlockListType::push_back()
 */
проц ЛЛПриставьСущБазБлок(ЛЛЗначение фн, ЛЛБазовыйБлок ББ);
  
/**
 * Create a new basic блок without inserting it into a function.
 *
 * @see llvm::BasicBlock::Create()
 */
ЛЛБазовыйБлок ЛЛСоздайБазБлокВКонтексте(ЛЛКонтекст к, ткст0 имя);

/**
 * Append a basic блок to the end of a function.
 *
 * @see llvm::BasicBlock::Create()
 */
ЛЛБазовыйБлок ЛЛПриставьБазБлокВКонтексте(ЛЛКонтекст к,ЛЛЗначение фн, ткст0 имя);

/**
 * Append a basic блок to the end of a function using the global
 * context.
 *
 * @see llvm::BasicBlock::Create()
 */
ЛЛБазовыйБлок ЛЛПриставьБазБлок(ЛЛЗначение фн, ткст0 имя);

/**
 * Insert a basic блок in a function before another basic блок.
 *
 * The function to add to is determined by the function of the
 * passed basic блок.
 *
 * @see llvm::BasicBlock::Create()
 */
ЛЛБазовыйБлок ЛЛВставьБазБлокВКонтекст(ЛЛКонтекст к, ЛЛБазовыйБлок ББ, ткст0 имя);

/**
 * Insert a basic блок in a function using the global context.
 *
 * @see llvm::BasicBlock::Create()
 */
ЛЛБазовыйБлок ЛЛВставьБазБлок(ЛЛБазовыйБлок вставкаПередББ, ткст0 имя);

/**
 * Remove a basic блок from a function and delete it.
 *
 * This deletes the basic блок from its containing function and deletes
 * the basic блок itself.
 *
 * @see llvm::BasicBlock::eraseFromParent()
 */
проц ЛЛУдалиБазБлок(ЛЛБазовыйБлок ББ);

/**
 * Remove a basic блок from a function.
 *
 * This deletes the basic блок from its containing function but keep
 * the basic блок alive.
 *
 * @see llvm::BasicBlock::removeFromParent()
 */
проц ЛЛУдалиБазБлокИзРодителя(ЛЛБазовыйБлок ББ);

/**
 * Move a basic блок to before another one.
 *
 * @see llvm::BasicBlock::moveBefore()
 */
проц ЛЛПоставьБазБлокПеред(ЛЛБазовыйБлок ББ, ЛЛБазовыйБлок смещПоз);

/**
 * Move a basic блок to after another one.
 *
 * @see llvm::BasicBlock::moveAfter()
 */
проц ЛЛПоставьБазБлокПосле(ЛЛБазовыйБлок ББ, ЛЛБазовыйБлок смещПоз);

/**
 * Obtain the first instruction in a basic блок.
 *
 * The returned ЛЛЗначение corresponds to a llvm::Instruction
 * instance.
 */
ЛЛЗначение ЛЛДайПервИнстр(ЛЛБазовыйБлок ББ);

/**
 * Obtain the last instruction in a basic блок.
 *
 * The returned ЛЛЗначение corresponds to an LLVM:Instruction.
 */
ЛЛЗначение ЛЛДайПоследнИнстр(ЛЛБазовыйБлок ББ);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueInstruction Instructions
 *
 * Functions in this group relate to the inspection and manipulation of
 * individual instructions.
 *
 * In the C++ API, an instruction is modeled by llvm::Instruction. This
 * class has a large number of descendents. llvm::Instruction is a
 * llvm::Value and in the к API, instructions are modeled by
 * ЛЛЗначение.
 *
 * This group also contains sub-groups which operate on specific
 * llvm::Instruction types, e.g. llvm::инстрВыз.
 *
 * @{
 */

/**
 * Determine whether an instruction has any metadata attached.
 */
цел ЛЛЕстьМетаданные_ли(ЛЛЗначение знач);

/**
 * Return metadata associated with an instruction знач.
 */
ЛЛЗначение ЛЛДайМетаданные(ЛЛЗначение знач, бцел идРода);

/**
 * Set metadata associated with an instruction знач.
 */
проц ЛЛУстМетаданные(ЛЛЗначение знач, бцел идРода, ЛЛЗначение узел);

/**
 * Returns the metadata associated with an instruction знач, but filters out
 * all the debug locations.
 *
 * @see llvm::Instruction::getAllMetadataOtherThanDebugLoc()
 */
ЛЛЗаписьМетаданныхЗначения *
ЛЛИнструкцияДайВсеМетаданныеКромеЛокОтлад(ЛЛЗначение инстр, т_мера *члоЗапп);

/**
 * Obtain the basic блок to which an instruction belongs.
 *
 * @see llvm::Instruction::getParent()
 */
ЛЛБазовыйБлок ЛЛДайРодителяИнстр(ЛЛЗначение инстр);

/**
 * Obtain the instruction that occurs after the one specified.
 *
 * The next instruction will be from the same basic блок.
 *
 * If this is the last instruction in a basic блок, NULL will be
 * returned.
 */
ЛЛЗначение ЛЛДайСледщИнстр(ЛЛЗначение инстр);

/**
 * Obtain the instruction that occurred before this one.
 *
 * If the instruction is the first instruction in a basic блок, NULL
 * will be returned.
 */
ЛЛЗначение ЛЛДайПредшИнстр(ЛЛЗначение инстр);

/**
 * Remove and delete an instruction.
 *
 * The instruction specified is removed from its containing building
 * блок but is kept alive.
 *
 * @see llvm::Instruction::removeFromParent()
 */
проц ЛЛИнструкция_УдалиИзРодителя(ЛЛЗначение инстр);

/**
 * Remove and delete an instruction.
 *
 * The instruction specified is removed from its containing building
 * блок and then deleted.
 *
 * @see llvm::Instruction::eraseFromParent()
 */
проц ЛЛИнструкция_СотриИзРодителя(ЛЛЗначение инстр);

/**
 * Obtain the code opcode for an individual instruction.
 *
 * @see llvm::Instruction::getOpCode()
 */
ЛЛОпкод ЛЛДайОпкодИнстр(ЛЛЗначение инстр);

/**
 * Obtain the predicate of an instruction.
 *
 * This is only valid for instructions that correspond to llvm::ICmpInst
 * or llvm::ConstantExpr whose opcode is llvm::Instruction::ICmp.
 *
 * @see llvm::ICmpInst::getPredicate()
 */
ЛЛЦелПредикат ЛЛДайПредикатЦСравн(ЛЛЗначение инстр);

/**
 * Obtain the float predicate of an instruction.
 *
 * This is only valid for instructions that correspond to llvm::FCmpInst
 * or llvm::ConstantExpr whose opcode is llvm::Instruction::FCmp.
 *
 * @see llvm::FCmpInst::getPredicate()
 */
ЛЛПредикатРеала ЛЛДайПредикатПСравн(ЛЛЗначение инстр);

/**
 * Create a copy of 'this' instruction that is identical in all ways
 * except the following:
 *   * The instruction has no parent
 *   * The instruction has no name
 *
 * @see llvm::Instruction::clone()
 */
ЛЛЗначение ЛЛИнструкция_Клонируй(ЛЛЗначение инстр);

/**
 * Determine whether an instruction is a terminator. This routine is named to
 * be compatible with historical functions that did this by querying the
 * underlying C++ type.
 *
 * @see llvm::Instruction::isTerminator()
 */
ЛЛЗначение ЛЛИнстрТерминатор_ли(ЛЛЗначение инстр);

/**
 * @defgroup LLVMCCoreValueInstructionCall Call Sites and Invocations
 *
 * Functions in this group apply to instructions that refer to call
 * sites and invocations. These correspond to C++ types in the
 * llvm::инстрВыз class tree.
 *
 * @{
 */

/**
 * Obtain the argument count for a call instruction.
 *
 * This expects an ЛЛЗначение that corresponds to a llvm::инстрВыз,
 * llvm::инстрВып, or llvm:FuncletPadInst.
 *
 * @see llvm::инстрВыз::getNumArgOperands()
 * @see llvm::инстрВып::getNumArgOperands()
 * @see llvm::FuncletPadInst::getNumArgOperands()
 */
бцел ЛЛДайЧлоАргОперандов(ЛЛЗначение инстр);

/**
 * Set the calling convention for a call instruction.
 *
 * This expects an ЛЛЗначение that corresponds to a llvm::инстрВыз or
 * llvm::инстрВып.
 *
 * @see llvm::инстрВыз::setCallingConv()
 * @see llvm::инстрВып::setCallingConv()
 */
проц ЛЛУстКонвВызИнстр(ЛЛЗначение инстр, бцел кВыз);

/**
 * Obtain the calling convention for a call instruction.
 *
 * This is the opposite of LLVMSetInstructionCallConv(). Reads its
 * usage.
 *
 * @see LLVMSetInstructionCallConv()
 */
бцел ЛЛДайКонвВызИнстр(ЛЛЗначение инстр);

проц ЛЛУстРаскладПарамовИнстр(ЛЛЗначение инстр, бцел инд, бцел расклад);

проц ЛЛДобавьАтрМестаВызова(ЛЛЗначение к, ЛЛИндексАтрибута инд, ЛЛАтрибут атр);
бцел ЛЛДайЧлоАтровМестаВызова(ЛЛЗначение к, ЛЛИндексАтрибута инд);
проц ЛЛДайАтрыМестаВызова(ЛЛЗначение к, ЛЛИндексАтрибута инд, ЛЛАтрибут *атры);
ЛЛАтрибут ЛЛДайАтрыПеречняМестаВызова(ЛЛЗначение к, ЛЛИндексАтрибута инд,бцел идРода);

ЛЛАтрибут ЛЛДайТкстАтрыМестаВызова(ЛЛЗначение к, ЛЛИндексАтрибута инд,
                                                ткст0 K, бцел KLen);
проц ЛЛУдалиАтрПеречняМестаВызова(ЛЛЗначение к, ЛЛИндексАтрибута инд,
                                     бцел идРода);
проц ЛЛУдалиТкстАтрМестаВызова(ЛЛЗначение к, ЛЛИндексАтрибута инд,
                                       ткст0 K, бцел KLen);

/**
 * Obtain the function type called by this instruction.
 *
 * @see llvm::CallBase::getFunctionType()
 */
ЛЛТип ЛЛДайТипВызваннойФункц(ЛЛЗначение к);

/**
 * Obtain the pointer to the function invoked by this instruction.
 *
 * This expects an ЛЛЗначение that corresponds to a llvm::инстрВыз or
 * llvm::инстрВып.
 *
 * @see llvm::инстрВыз::getCalledValue()
 * @see llvm::инстрВып::getCalledValue()
 */
ЛЛЗначение ЛЛДайВызванноеЗнач(ЛЛЗначение инстр);

/**
 * Obtain whether a call instruction is a tail call.
 *
 * This only works on llvm::инстрВыз instructions.
 *
 * @see llvm::инстрВыз::isTailCall()
 */
ЛЛБул ЛЛТейлВызов_ли(ЛЛЗначение инстрВыз);

/**
 * Set whether a call instruction is a tail call.
 *
 * This only works on llvm::инстрВыз instructions.
 *
 * @see llvm::инстрВыз::setTailCall()
 */
проц ЛЛУстТейлВызов(ЛЛЗначение инстрВыз, ЛЛБул IsTailCall);

/**
 * Return the normal destination basic блок.
 *
 * This only works on llvm::инстрВып instructions.
 *
 * @see llvm::инстрВып::getNormalDest()
 */
ЛЛБазовыйБлок ЛЛДайНормальнПриёмник(ЛЛЗначение инстрВып);

/**
 * Return the unwind destination basic блок.
 *
 * Works on llvm::инстрВып, llvm::CleanupReturnInst, and
 * llvm::CatchSwitchInst instructions.
 *
 * @see llvm::инстрВып::getUnwindDest()
 * @see llvm::CleanupReturnInst::getUnwindDest()
 * @see llvm::CatchSwitchInst::getUnwindDest()
 */
ЛЛБазовыйБлок ЛЛДайПриёмникОтмотки(ЛЛЗначение инстрВып);

/**
 * Set the normal destination basic блок.
 *
 * This only works on llvm::инстрВып instructions.
 *
 * @see llvm::инстрВып::setNormalDest()
 */
проц ЛЛУстНормальнПриёмник(ЛЛЗначение инстрВып, ЛЛБазовыйБлок постр);

/**
 * Set the unwind destination basic блок.
 *
 * Works on llvm::инстрВып, llvm::CleanupReturnInst, and
 * llvm::CatchSwitchInst instructions.
 *
 * @see llvm::инстрВып::setUnwindDest()
 * @see llvm::CleanupReturnInst::setUnwindDest()
 * @see llvm::CatchSwitchInst::setUnwindDest()
 */
проц ЛЛУстПриёмникОтмотки(ЛЛЗначение инстрВып, ЛЛБазовыйБлок постр);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueInstructionTerminator Terminators
 *
 * Functions in this group only apply to instructions for which
 * LLVMIsATerminatorInst returns true.
 *
 * @{
 */

/**
 * Return the number of successors that this terminator has.
 *
 * @see llvm::Instruction::getNumSuccessors
 */
бцел ЛЛДайЧлоПоследователей(ЛЛЗначение терм);

/**
 * Return the specified successor.
 *
 * @see llvm::Instruction::getSuccessor
 */
ЛЛБазовыйБлок ЛЛДайПоследователи(ЛЛЗначение терм, бцел i);

/**
 * Update the specified successor to point at the provided блок.
 *
 * @see llvm::Instruction::setSuccessor
 */
проц ЛЛУстПоследователь(ЛЛЗначение терм, бцел i, ЛЛБазовыйБлок блок);

/**
 * Return if a branch is conditional.
 *
 * This only works on llvm::BranchInst instructions.
 *
 * @see llvm::BranchInst::isConditional
 */
ЛЛБул ЛЛУсловн_ли(ЛЛЗначение ветвь);

/**
 * Return the condition of a branch instruction.
 *
 * This only works on llvm::BranchInst instructions.
 *
 * @see llvm::BranchInst::getCondition
 */
ЛЛЗначение ЛЛДайУсловие(ЛЛЗначение ветвь);

/**
 * Set the condition of a branch instruction.
 *
 * This only works on llvm::BranchInst instructions.
 *
 * @see llvm::BranchInst::setCondition
 */
проц ЛЛУстУсловие(ЛЛЗначение ветвь, ЛЛЗначение услов);

/**
 * Obtain the default destination basic блок of a switch instruction.
 *
 * This only works on llvm::SwitchInst instructions.
 *
 * @see llvm::SwitchInst::getDefaultDest()
 */
ЛЛБазовыйБлок ЛЛДайДефПриёмникРеле(ЛЛЗначение инстрПерекл);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueInstructionAlloca Allocas
 *
 * Functions in this group only apply to instructions that map to
 * llvm::AllocaInst instances.
 *
 * @{
 */

/**
 * Obtain the type that is being allocated by the alloca instruction.
 */
ЛЛТип ЛЛДайРазмещТип(ЛЛЗначение разместа);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueInstructionGetElementPointer GEPs
 *
 * Functions in this group only apply to instructions that map to
 * llvm::GetElementPtrInst instances.
 *
 * @{
 */

/**
 * Check whether the given GEP instruction is inbounds.
 */
ЛЛБул ЛЛвПределах_ли(ЛЛЗначение GEP);

/**
 * Set the given GEP instruction to be inbounds or not.
 */
проц ЛЛУстВПределах(ЛЛЗначение GEP, ЛЛБул InBounds);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueInstructionPHINode PHI Nodes
 *
 * Functions in this group only apply to instructions that map to
 * llvm::PHINode instances.
 *
 * @{
 */

/**
 * Add an incoming знач to the end of a PHI list.
 */
проц ЛЛДобавьВходящ(ЛЛЗначение PhiNode, ЛЛЗначение *IncomingValues,
                     ЛЛБазовыйБлок *IncomingBlocks, бцел чло);

/**
 * Obtain the number of incoming basic blocks to a PHI node.
 */
бцел ЛЛПосчитайВходящ(ЛЛЗначение PhiNode);

/**
 * Obtain an incoming знач to a PHI node as an ЛЛЗначение.
 */
ЛЛЗначение ЛЛДайВходящЗнач(ЛЛЗначение PhiNode, бцел индекс);

/**
 * Obtain an incoming знач to a PHI node as an ЛЛБазовыйБлок.
 */
ЛЛБазовыйБлок ЛЛДайВходящБлок(ЛЛЗначение PhiNode, бцел индекс);

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreValueInstructionExtractValue ExtractValue
 * @defgroup LLVMCCoreValueInstructionInsertValue InsertValue
 *
 * Functions in this group only apply to instructions that map to
 * llvm::ExtractValue and llvm::InsertValue instances.
 *
 * @{
 */

/**
 * Получить число индексов.
 * NB: Также работает на GEP.
 */
бцел ЛЛДайЧлоИндексов(ЛЛЗначение инстр);

/**
 * Получить индексы как массив.
 */
бцел *ЛЛДайИндексы(ЛЛЗначение инстр);

/**
 * @}
 */

/**
 * @}
 */

/**
 * @}
 */

/**
 * @defgroup LLVMCCoreInstructionBuilder Построители Инструкций
 *
 * Построитель инструкций представляет точку внутри базового блока и
 * является исключительным средством построения инструкций
 * с использованием Си интерфейса.
 *
 * @{
 */

ЛЛПостроитель ЛЛСоздайПостроительВКонтексте(ЛЛКонтекст к);
ЛЛПостроитель ЛЛСоздайПостроитель();
проц ЛЛПостроительПозиции(ЛЛПостроитель построитель, ЛЛБазовыйБлок блок,
                         ЛЛЗначение инстр);
проц ЛЛПостроительПозицииПеред(ЛЛПостроитель построитель, ЛЛЗначение инстр);
проц ЛЛПостроительПозицииВКонце(ЛЛПостроитель построитель, ЛЛБазовыйБлок блок);
ЛЛБазовыйБлок ЛЛДайБлокВставки(ЛЛПостроитель построитель);
проц ЛЛОчистиПозициюВставки(ЛЛПостроитель построитель);
проц ЛЛВставьВПостроитель(ЛЛПостроитель построитель, ЛЛЗначение инстр);
проц ЛЛВставьВПостроительСИменем(ЛЛПостроитель построитель, ЛЛЗначение инстр,
                                   ткст0 имя);
проц ЛЛВыместиПостроитель(ЛЛПостроитель построитель);

/* Метаданные */

/**
 * Получить информацию о расположении, используемую в отладочной информации.
 *
 * @see llvm::IRBuilder::getCurrentDebugLocation()
 */
ЛЛМетаданные ЛЛДайТекЛокОтладки2(ЛЛПостроитель построитель);

/**
 * Установить информацию о расположении, используемую в отладочной информации.
 *
 * Чтобы удалить метаданные расположения данной инструкции,
 * передайте NULL в \p лок.
 *
 * @see llvm::IRBuilder::SetCurrentDebugLocation()
 */
проц ЛЛУстТекЛокОтладки2(ЛЛПостроитель построитель, ЛЛМетаданные лок);

/**
 * Attempts to set the debug location for the given instruction using the
 * current debug location for the given построитель.  If the построитель has no current
 * debug location, this function is a no-op.
 *
 * @see llvm::IRBuilder::SetInstDebugLocation()
 */
проц ЛЛУстТекЛокОтладкиИнстр(ЛЛПостроитель построитель, ЛЛЗначение инстр);

/**
 * Получить дефолтные математические метаданные
 * плавающей точки для данного построителя.
 *
 * @see llvm::IRBuilder::getDefaultтэгПЗМат()
 */
ЛЛМетаданные ЛЛПостроитель_ДайДефПЗМатТег(ЛЛПостроитель построитель);

/**
 * Установить дефолтные математические метаданные
 * плавающей точки для данного построителя.
 *
 * Чтобы удалить метаданные, передайте NULL в \p тэгПЗМат.
 *
 * @see llvm::IRBuilder::setDefaultтэгПЗМат()
 */
проц ЛЛПостроитель_УстДефПЗМатТег(ЛЛПостроитель построитель, ЛЛМетаданные тэгПЗМат);

/**
 * Депрекировано: Passing the NULL location will crash.
 * Use LLVMGetCurrentDebugLocation2 instead.
 */
проц ЛЛУстТекЛокОтладки2(ЛЛПостроитель построитель, ЛЛЗначение L);
/**
 * Депрекировано: Returning the NULL location will crash.
 * Use LLVMGetCurrentDebugLocation2 instead.
 */
ЛЛЗначение ЛЛДайТекЛокОтладки(ЛЛПостроитель построитель);

/* Terminators */
ЛЛЗначение ЛЛСтройВозврПроц(ЛЛПостроитель);
ЛЛЗначение ЛЛСтройВозвр(ЛЛПостроитель постр, ЛЛЗначение З);
ЛЛЗначение ЛЛСтройАгрегатВозвр(ЛЛПостроитель постр, ЛЛЗначение *RetVals,
                                   бцел N);
ЛЛЗначение ЛЛСтройБр(ЛЛПостроитель постр, ЛЛБазовыйБлок приёмник);
ЛЛЗначение ЛЛСтройУсловнБр(ЛЛПостроитель постр, ЛЛЗначение If,
                             ЛЛБазовыйБлок Then, ЛЛБазовыйБлок Else);
ЛЛЗначение ЛЛСтройЩит(ЛЛПостроитель постр, ЛЛЗначение З,
                             ЛЛБазовыйБлок Else, бцел NumCases);
ЛЛЗначение ЛЛСтройНепрямБр(ЛЛПостроитель постр, ЛЛЗначение Addr,
                                 бцел NumDests);
// LLVMBuildInvoke is Депрекировано in favor of LLVMBuildInvoke2, in preparation
// for opaque pointer types.
ЛЛЗначение ЛЛСтройИнвок(ЛЛПостроитель постр, ЛЛЗначение фн,
                             ЛЛЗначение *арги, бцел члоАргов,
                             ЛЛБазовыйБлок Then, ЛЛБазовыйБлок Catch,
                             ткст0 имя);
ЛЛЗначение ЛЛСтройИнвок2(ЛЛПостроитель постр, ЛЛТип тип, ЛЛЗначение фн,
                              ЛЛЗначение *арги, бцел члоАргов,
                              ЛЛБазовыйБлок Then, ЛЛБазовыйБлок Catch,
                              ткст0 имя);
ЛЛЗначение ЛЛСтройНедоступный(ЛЛПостроитель);

/* Exception Handling */
ЛЛЗначение ЛЛСтройВозобнови(ЛЛПостроитель постр, ЛЛЗначение Exn);
ЛЛЗначение ЛЛСтойЛэндингПад(ЛЛПостроитель постр, ЛЛТип тип,
                                 ЛЛЗначение PersFn, бцел члоКлоз,
                                 ткст0 имя);
ЛЛЗначение ЛЛСтройОчистиВозвр(ЛЛПостроитель постр, ЛЛЗначение кэчПад,
                                 ЛЛБазовыйБлок ББ);
ЛЛЗначение ЛЛСтройКэчВозвр(ЛЛПостроитель постр, ЛЛЗначение кэчПад,
                               ЛЛБазовыйБлок ББ);
ЛЛЗначение ЛЛСтройКэчПад(ЛЛПостроитель постр, ЛЛЗначение родитПад,
                               ЛЛЗначение *арги, бцел члоАргов,
                               ткст0 имя);
ЛЛЗначение ЛЛСтройОчистиПад(ЛЛПостроитель постр, ЛЛЗначение родитПад,
                                 ЛЛЗначение *арги, бцел члоАргов,
                                 ткст0 имя);
ЛЛЗначение ЛЛСтройКэчЩит(ЛЛПостроитель постр, ЛЛЗначение родитПад,
                                  ЛЛБазовыйБлок отмотББ,
                                  бцел члоОбров, ткст0 имя);

/* Добавить реле(case) инструкции щит(switch) */
проц ЛЛДобавьРеле(ЛЛЗначение щит, ЛЛЗначение приЗнач,
                 ЛЛБазовыйБлок приёмник);

/* Добавить приёмник инструкции indirectbr */
проц ЛЛДобавьПриёмник(ЛЛЗначение индирБр, ЛЛБазовыйБлок приёмник);

/* Получить число клоз у инструкции landingpad */
бцел ЛЛДайЧлоКлоз(ЛЛЗначение лэндингПад);

/* Получить значение клозы по индексу в инструкции landingpad */
ЛЛЗначение ЛЛДайКлоз(ЛЛЗначение лэндингПад, бцел инд);

/* Add a catch or filter clause to the landingpad instruction */
проц ЛЛДобавьКлоз(ЛЛЗначение лэндингПад, ЛЛЗначение клозЗнач);

/* Get the 'cleanup' flag in the landingpad instruction */
ЛЛБул ЛЛОчистка_ли(ЛЛЗначение лэндингПад);

/* Set the 'cleanup' flag in the landingpad instruction */
проц ЛЛУстОчистку(ЛЛЗначение лэндингПад, ЛЛБул знач);

/* Add a destination to the catchswitch instruction */
проц ЛЛДобавьОбработчик(ЛЛЗначение кэчЩит, ЛЛБазовыйБлок приёмник);

/* Get the number of handlers on the catchswitch instruction */
бцел ЛЛДайЧлоОбработчиков(ЛЛЗначение кэчЩит);

/**
 * Obtain the basic blocks acting as handlers for a catchswitch instruction.
 *
 * The обры parameter should point to a pre-allocated array of
 * LLVMBasicBlockRefs at least LLVMGetNumHandlers() large. On return, the
 * first LLVMGetNumHandlers() entries in the array will be populated
 * with ЛЛБазовыйБлок instances.
 *
 * @param кэчЩит The catchswitch instruction to operate on.
 * @param обры Memory address of an array to be filled with basic blocks.
 */
проц ЛЛДайОбработчики(ЛЛЗначение кэчЩит, ЛЛБазовыйБлок *обры);

// Функлеты 

/* Get the number of funcletpad arguments. */
ЛЛЗначение ЛЛДайАргОперанд(ЛЛЗначение функлет, бцел i);

/* Set a funcletpad argument at the given инд. */
проц ЛЛУстАргОперанд(ЛЛЗначение функлет, бцел i, ЛЛЗначение знач);

/**
 * Получит родительскую инструкцию catchswitch инструкции catchpad.
 *
 * Работает только с инструкциями llvm::CatchPadInst.
 *
 * @see llvm::кэчПадInst::getCatchSwitch()
 */
ЛЛЗначение ЛЛДайРодительскКэчЩит(ЛЛЗначение кэчПад);

/**
 * Set the parent catchswitch instruction of a catchpad instruction.
 *
 * This only works on llvm::кэчПадInst instructions.
 *
 * @see llvm::кэчПадInst::setCatchSwitch()
 */
проц ЛЛУстРодительскКэчЩит(ЛЛЗначение кэчПад, ЛЛЗначение кэчЩит);

/* Арифметика */
ЛЛЗначение ЛЛСтройСложи(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                          ткст0 имя);
ЛЛЗначение LLBuildNSWAdd(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                             ткст0 имя);
ЛЛЗначение LLBuildNUWAdd(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                             ткст0 имя);
ЛЛЗначение ЛЛСтройПСложи(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                           ткст0 имя);
ЛЛЗначение ЛЛСтройОтними(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                          ткст0 имя);
ЛЛЗначение LLBuildNSWSub(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                             ткст0 имя);
ЛЛЗначение LLBuildNUWSub(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                             ткст0 имя);
ЛЛЗначение ЛЛСтройПОтними(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                           ткст0 имя);
ЛЛЗначение ЛЛСтройУмножь(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                          ткст0 имя);
ЛЛЗначение LLBuildNSWMul(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                             ткст0 имя);
ЛЛЗначение LLBuildNUWMul(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                             ткст0 имя);
ЛЛЗначение ЛЛСтройПУмножь(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                           ткст0 имя);
ЛЛЗначение ЛЛСтройБДели(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                           ткст0 имя);
ЛЛЗначение ЛЛСтройТочноБДели(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                                ткст0 имя);
ЛЛЗначение ЛЛСтройЗДели(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                           ткст0 имя);
ЛЛЗначение ЛЛСтройТочноЗДели(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                                ткст0 имя);
ЛЛЗначение ЛЛСтройПДели(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                           ткст0 имя);
ЛЛЗначение LLBuildURem(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                           ткст0 имя);
ЛЛЗначение LLBuildSRem(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                           ткст0 имя);
ЛЛЗначение LLBuildFRem(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                           ткст0 имя);
ЛЛЗначение LLBuildShl(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                           ткст0 имя);
ЛЛЗначение LLBuildLShr(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                           ткст0 имя);
ЛЛЗначение LLBuildAShr(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                           ткст0 имя);
ЛЛЗначение ЛЛСтройИ(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                          ткст0 имя);
ЛЛЗначение ЛЛСтройИли(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                          ткст0 имя);
ЛЛЗначение ЛЛСтройИИли(ЛЛПостроитель постр, ЛЛЗначение LHS, ЛЛЗначение RHS,
                          ткст0 имя);
ЛЛЗначение ЛЛСтройБинОп(ЛЛПостроитель постр, ЛЛОпкод оп,
                            ЛЛЗначение LHS, ЛЛЗначение RHS,
                            ткст0 имя);
ЛЛЗначение ЛЛСтройОтриц(ЛЛПостроитель постр, ЛЛЗначение З, ткст0 имя);
ЛЛЗначение LLBuildNSWNeg(ЛЛПостроитель постр, ЛЛЗначение З,
                             ткст0 имя);
ЛЛЗначение LLBuildNUWNeg(ЛЛПостроитель постр, ЛЛЗначение З,
                             ткст0 имя);
ЛЛЗначение ЛЛСтройПОтриц(ЛЛПостроитель постр, ЛЛЗначение З, ткст0 имя);
ЛЛЗначение ЛЛСтройНе(ЛЛПостроитель постр, ЛЛЗначение З, ткст0 имя);

/* Memory */
ЛЛЗначение ЛЛСтройРазместПам(ЛЛПостроитель постр, ЛЛТип тип, ткст0 имя);
ЛЛЗначение ЛЛСтройРазместПамМасс(ЛЛПостроитель постр, ЛЛТип тип,
                                  ЛЛЗначение знач, ткст0 имя);

/**
 * создаёт и вставляет memset в определённый указатель и заданное значение.
 *
 * @see llvm::IRRBuilder::CreateMemSet()
 */
ЛЛЗначение ЛЛСтройУстПам(ЛЛПостроитель постр, ЛЛЗначение укз,
                             ЛЛЗначение знач, ЛЛЗначение длин,
                             бцел расклад);
/**
 * Creates and inserts a memcpy between the specified pointers.
 *
 * @see llvm::IRRBuilder::CreateMemCpy()
 */
ЛЛЗначение ЛЛСтройКопирПам(ЛЛПостроитель постр, 
                             ЛЛЗначение приёмник, бцел DstAlign,
                             ЛЛЗначение исток, бцел раскладИсх,
                             ЛЛЗначение разм);
/**
 * Creates and inserts a memmove between the specified pointers.
 *
 * @see llvm::IRRBuilder::CreateMemMove()
 */
ЛЛЗначение ЛЛСтройПреместПам(ЛЛПостроитель постр, 
                              ЛЛЗначение приёмник, бцел DstAlign,
                              ЛЛЗначение исток, бцел раскладИсх,
                              ЛЛЗначение разм);

ЛЛЗначение ЛЛСтройАллока(ЛЛПостроитель постр, ЛЛТип тип, ткст0 имя);
ЛЛЗначение ЛЛСтройАллокаМасс(ЛЛПостроитель постр, ЛЛТип тип,
                                  ЛЛЗначение знач, ткст0 имя);
ЛЛЗначение ЛЛСтройОсвободи(ЛЛПостроитель постр, ЛЛЗначение значУкз);
// LLBuildLoad is Депрекировано in favor of LLBuildLoad2, in preparation for
// opaque pointer types.
ЛЛЗначение ЛЛСтройЗагрузи(ЛЛПостроитель постр, ЛЛЗначение значУкз,
                           ткст0 имя);
ЛЛЗначение ЛЛСтройЗагрузи2(ЛЛПостроитель постр, ЛЛТип тип,
                            ЛЛЗначение значУкз, ткст0 имя);
ЛЛЗначение ЛЛСтройСохрани(ЛЛПостроитель постр, ЛЛЗначение знач, ЛЛЗначение укз);
// LLBuildGEP, LLBuildInBoundsGEP, and LLBuildStructGEP are Депрекировано in
// favor of LLBuild*GEP2, in preparation for opaque pointer types.
ЛЛЗначение LLBuildGEP(ЛЛПостроитель постр, ЛЛЗначение указатель,
                          ЛЛЗначение *индексы, бцел члоИндексов,
                          ткст0 имя);
ЛЛЗначение LLBuildInBoundsGEP(ЛЛПостроитель постр, ЛЛЗначение указатель,
                                  ЛЛЗначение *индексы, бцел члоИндексов,
                                  ткст0 имя);
ЛЛЗначение LLBuildStructGEP(ЛЛПостроитель постр, ЛЛЗначение указатель,
                                бцел инд, ткст0 имя);
ЛЛЗначение LLBuildGEP2(ЛЛПостроитель постр, ЛЛТип тип,
                           ЛЛЗначение указатель, ЛЛЗначение *индексы,
                           бцел члоИндексов, ткст0 имя);
ЛЛЗначение LLBuildInBoundsGEP2(ЛЛПостроитель постр, ЛЛТип тип,
                                   ЛЛЗначение указатель, ЛЛЗначение *индексы,
                                   бцел члоИндексов, ткст0 имя);
ЛЛЗначение LLBuildStructGEP2(ЛЛПостроитель постр, ЛЛТип тип,
                                 ЛЛЗначение указатель, бцел инд,
                                 ткст0 имя);
ЛЛЗначение ЛЛСтройГлобТкст(ЛЛПостроитель постр, ткст0 текст,
                                   ткст0 имя);
ЛЛЗначение ЛЛСтройГлобТкстУкз(ЛЛПостроитель постр, ткст0 текст,
                                      ткст0 имя);
ЛЛБул ЛЛДайВолатил(ЛЛЗначение инстрДоступаКПам);
проц ЛЛУстВолатил(ЛЛЗначение инстрДоступаКПам, ЛЛБул волатилен_ли);
ЛЛАтомныйПорядок ЛЛДайПорядок(ЛЛЗначение инстрДоступаКПам);
проц ЛЛУстПорядок(ЛЛЗначение инстрДоступаКПам, ЛЛАтомныйПорядок порядок);

// Приведение к типу (касты)

ЛЛЗначение ЛЛСтройОбрежь(ЛЛПостроитель постр, ЛЛЗначение знач,
                            ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройНРасш(ЛЛПостроитель постр, ЛЛЗначение знач,
                           ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройЗРасш(ЛЛПостроитель постр, ЛЛЗначение знач,
                           ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройПЗвБЦ(ЛЛПостроитель постр, ЛЛЗначение знач,
                             ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройПЗвЗЦ(ЛЛПостроитель постр, ЛЛЗначение знач,
                             ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройБЦвПЗ(ЛЛПостроитель постр, ЛЛЗначение знач,
                             ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройЗЦвПЗ(ЛЛПостроитель постр, ЛЛЗначение знач,
                             ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройПЗОбрежь(ЛЛПостроитель постр, ЛЛЗначение знач,
                              ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройПЗРасш(ЛЛПостроитель постр, ЛЛЗначение знач,
                            ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройУкзВЦел(ЛЛПостроитель постр, ЛЛЗначение знач,
                               ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройЦелВУкз(ЛЛПостроитель постр, ЛЛЗначение знач,
                               ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройБитКаст(ЛЛПостроитель постр, ЛЛЗначение знач,
                              ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройАдрПрострКаст(ЛЛПостроитель постр, ЛЛЗначение знач,
                                    ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройНРасшИлиБитКаст(ЛЛПостроитель постр, ЛЛЗначение знач,
                                    ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройЗРасшИлиБитКаст(ЛЛПостроитель постр, ЛЛЗначение знач,
                                    ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройОбрежьИлиБитКаст(ЛЛПостроитель постр, ЛЛЗначение знач,
                                     ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройКаст(ЛЛПостроитель постр, ЛЛОпкод оп, ЛЛЗначение знач,
                           ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройУказательКаст(ЛЛПостроитель постр, ЛЛЗначение знач,
                                  ЛЛТип приёмнТип, ткст0 имя);
ЛЛЗначение ЛЛСтройЦелКаст2(ЛЛПостроитель постр, ЛЛЗначение знач,
                               ЛЛТип приёмнТип, ЛЛБул соЗнаком_ли,
                               ткст0 имя);
ЛЛЗначение ЛЛСтройПЗКаст(ЛЛПостроитель постр, ЛЛЗначение знач,
                             ЛЛТип приёмнТип, ткст0 имя);

/** Депрекировано: This cast is always signed. Use LLBuildIntCast2 instead. */
ЛЛЗначение ЛЛСтройЦелКаст(ЛЛПостроитель постр, ЛЛЗначение знач, /*Signed cast!*/
                              ЛЛТип приёмнТип, ткст0 имя);

/* Comparisons */
ЛЛЗначение ЛЛСтройЦСравн(ЛЛПостроитель постр, ЛЛЦелПредикат оп,
                           ЛЛЗначение LHS, ЛЛЗначение RHS,
                           ткст0 имя);
ЛЛЗначение ЛЛСтройПСравн(ЛЛПостроитель постр, ЛЛПредикатРеала оп,
                           ЛЛЗначение LHS, ЛЛЗначение RHS,
                           ткст0 имя);

/* Miscellaneous instructions */
ЛЛЗначение LLBuildPhi(ЛЛПостроитель постр, ЛЛТип тип, ткст0 имя);
// LLBuildCall is Депрекировано in favor of LLBuildCall2, in preparation for
// opaque pointer types.
ЛЛЗначение ЛЛСтройВызов(ЛЛПостроитель постр, ЛЛЗначение фн,
                           ЛЛЗначение *арги, бцел члоАргов,
                           ткст0 имя);
ЛЛЗначение ЛЛСтройВызов2(ЛЛПостроитель постр, ЛЛТип, ЛЛЗначение фн,
                            ЛЛЗначение *арги, бцел члоАргов,
                            ткст0 имя);
ЛЛЗначение ЛЛСтройВыбери(ЛЛПостроитель постр, ЛЛЗначение If,
                             ЛЛЗначение Then, ЛЛЗначение Else,
                             ткст0 имя);
ЛЛЗначение ЛЛСтройВААрг(ЛЛПостроитель постр, ЛЛЗначение список, ЛЛТип тип,
                            ткст0 имя);
ЛЛЗначение ЛЛСтройИзвлекиЭлт(ЛЛПостроитель постр, ЛЛЗначение векторнЗнач,
                                     ЛЛЗначение индекс, ткст0 имя);
ЛЛЗначение ЛЛСтройВставьЭлт(ЛЛПостроитель постр, ЛЛЗначение векторнЗнач,
                                    ЛЛЗначение значЭлта, ЛЛЗначение индекс,
                                    ткст0 имя);
ЛЛЗначение ЛЛСтройШафлВектор(ЛЛПостроитель постр, ЛЛЗначение зн1,
                                    ЛЛЗначение зн2, ЛЛЗначение маска,
                                    ткст0 имя);
ЛЛЗначение ЛЛСтройИзвлекиЗначение(ЛЛПостроитель постр, ЛЛЗначение AggVal,
                                   бцел индекс, ткст0 имя);
ЛЛЗначение ЛЛСтройВставьЗначение(ЛЛПостроитель постр, ЛЛЗначение AggVal,
                                  ЛЛЗначение значЭлта, бцел индекс,
                                  ткст0 имя);

ЛЛЗначение ЛЛСтройПусто(ЛЛПостроитель постр, ЛЛЗначение знач,
                             ткст0 имя);
ЛЛЗначение ЛЛСтройНеПусто(ЛЛПостроитель постр, ЛЛЗначение знач,
                                ткст0 имя);
ЛЛЗначение ЛСтройУкзДифф(ЛЛПостроитель постр, ЛЛЗначение LHS,
                              ЛЛЗначение RHS, ткст0 имя);
ЛЛЗначение ЛЛСтройЗабор(ЛЛПостроитель постр, ЛЛАтомныйПорядок порядок,
                            ЛЛБул однопоточен_ли, ткст0 имя);
ЛЛЗначение LLBuildAtomicRMW(ЛЛПостроитель постр, LLVMAtomicRMWBinOp op,
                                ЛЛЗначение PTR, ЛЛЗначение знач,
                                ЛЛАтомныйПорядок порядок,
                                ЛЛБул однопоточен_ли);
ЛЛЗначение LLBuildAtomicCmpXchg(ЛЛПостроитель постр, ЛЛЗначение укз,
                                    ЛЛЗначение Cmp, ЛЛЗначение нов,
                                    ЛЛАтомныйПорядок порядокУспех,
                                    ЛЛАтомныйПорядок порядокСбой,
                                    ЛЛБул однопоточен_ли);

ЛЛБул ЛЛАтомнОднонить_ли(ЛЛЗначение атомнИнстр);
проц ЛЛУстАтомнОднонить(ЛЛЗначение атомнИнстр, ЛЛБул однопоточен_ли);

ЛЛАтомныйПорядок LLGetCmpXchgSuccessOrdering(ЛЛЗначение CmpXchgInst);
проц LLSetCmpXchgSuccessOrdering(ЛЛЗначение CmpXchgInst,
                                   ЛЛАтомныйПорядок порядок);
ЛЛАтомныйПорядок LLGetCmpXchgFailureOrdering(ЛЛЗначение CmpXchgInst);
проц LLSetCmpXchgFailureOrdering(ЛЛЗначение CmpXchgInst,
                                   ЛЛАтомныйПорядок порядок);

/**
 * @}
 */

/**
 * @defgroup LLCCoreModuleProvider Модуль Провайдеры
 *
 * @{
 */

/**
 * Changes the type of м so it can be passed to FunctionPassManagers and the
 * JIT.  They take ModuleProviders for historical reasons.
 */
ЛЛМодульПровайдер
ЛЛСоздайМодульПровайдерДляСущМодуля(ЛЛМодуль м);

/**
 * Удалить модуль м.
 */
проц ЛЛвыместиМодульПровайдер(ЛЛМодульПровайдер м);

/**
 * @}
 */

/**
 * @defgroup LLCCoreMemoryBuffers Буферы Памяти
 *
 * @{
 */

ЛЛБул ЛЛСоздайБуфПамССодержимымФайла(ткст0 путь, ЛЛБуферПамяти *выхБуфПам, ткст0 *выхСооб);
ЛЛБул ЛЛСоздайБуфПамСоСТДВХО(ЛЛБуферПамяти *выхБуфПам, ткст0 *выхСооб);
ЛЛБуферПамяти ЛЛСоздайБуфПамСДиапазономПам(ткст0 вхоДан, т_мера длинаВхоДан,
                                                          ткст0 имяБуф,
                                                          ЛЛБул нуженНулТерминатор_ли);
ЛЛБуферПамяти ЛЛСоздайБуфПамСКопиейДиапазонаПам(ткст0 вхоДан,
                                                              т_мера длинаВхоДан,
                                                              ткст0 имяБуф);
ткст0 ЛЛДайНачалоБуфера(ЛЛБуферПамяти буфПам);
т_мера ЛЛДайРазмерБуфера(ЛЛБуферПамяти буфПам);
проц ЛЛВыместиБуферПамяти(ЛЛБуферПамяти буфПам);

/**
 * @}
 */

/**
 * @defgroup LLCCorePassRegistry Реестр Проходок
 *
 * @{
 */

/** Возвращает глобальный реестр проходок для использования с
 функциями инициализации.
    @see llvm::PassRegistry::getPassRegistry */
ЛЛРеестрПроходок ЛЛДайГлобРеестрПроходок();

/**
 * @}
 */

/**
 * @defgroup LLCCorePassManagers Менеджеры Проходок
 *
 * @{
 */

/** Constructs a new whole-module pass pipeline. This type of pipeline is
    suitable for link-time optimization and whole-module transformations.
    @see llvm::PassManager::PassManager */
ЛЛМенеджерПроходок ЛЛСоздайМенеджерПроходок();

/** Constructs a new function-by-function pass pipeline over the module
    provider. It does not take ownership of the module provider. This type of
    pipeline is suitable for code generation and JIT compilation tasks.
    @see llvm::FunctionPassManager::FunctionPassManager */
ЛЛМенеджерПроходок ЛЛСоздайМенеджерФукнцПроходокДляМодуля(ЛЛМодуль м);

/** Депрекировано: Use LLCreateFunctionPassManagerForModule instead. */
ЛЛМенеджерПроходок ЛЛСоздайМенеджерФукнцПроходок(ЛЛМодульПровайдер MP);

/** Инициализует все проходки,запланированные в менеджере проходок.
    Возвращает 1, если любая из проходок изменяет модуль, или иначе 0.
    @see llvm::PassManager::run(Module&) */
ЛЛБул ЛЛЗапустиМенеджерПроходок(ЛЛМенеджерПроходок пм, ЛЛМодуль м);

/** Инициализует все проходки по функциям,запланированные в менеджере проходок по
    функциям. Возвращает 1, если любая из проходок изменяет модуль, или иначе 0.
    @see llvm::FunctionPassManager::doInitialization */
ЛЛБул ЛЛИнициализуйМенеджерФукнцПроходок(ЛЛМенеджерПроходок FPM);

/** Выполняет все проходки по функциям,запланированные в менеджере проходок по
    функциям. Возвращает 1, если любая из проходок изменяет модуль, или иначе 0.
    @see llvm::FunctionPassManager::run(Function&) */
ЛЛБул ЛЛЗапустиМенеджерФукнцПроходок(ЛЛМенеджерПроходок FPM, ЛЛЗначение ф);

/** Финилизует все проходки по функциям, запланированные в менеджере проходок по
    функциям. Возвращает 1, если любая из проходок изменяет модуль, или иначе 0.
    @see llvm::FunctionPassManager::doFinalization */
ЛЛБул ЛЛФинализуйМенеджерФукнцПроходок(ЛЛМенеджерПроходок FPM);

/** Освобождает память пайплайна проходок. Для пайплайна функций не высвобождает
    провайдер модулей.
    @see llvm::PassManagerBase::~PassManagerBase. */
проц ЛЛВыместиМенеджерПроходок(ЛЛМенеджерПроходок пм);

/**
 * @}
 */

/**
 * @defgroup LLCCoreThreading Управление потоками
 *
 * Содержит структуры, необходимые для безопасности LLVM при многопоточности.
 *
 * @{
 */

/** Депрекировано: Многопоточность может быть включена/выключена только при определении
    во время компиляции LLVM_ENABLE_THREADS.  Эта функция всегда возвращает
    LLVMIsMultithreaded(). */
ЛЛБул ЛЛСтартМультинить();

/** Депрекировано: Многопоточность может быть включена/выключена только при определении
    во время компиляции LLVM_ENABLE_THREADS. */
проц ЛЛСтопМультинить();

/** Проверить, выполняется ли LLVM в потокобезопасном режиме.
    @see llvm::llvm_is_multithreaded */
ЛЛБул ЛЛМультинить_ли();

}

