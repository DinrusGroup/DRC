/// Author: Aziz Köksal, Vitaly Kulich
/// License: GPL3
/// $(Maturity high)
module cmd.DDocEmitter;

import cmd.Highlight;
import drc.doc.Parser,
       drc.doc.Macro,
       drc.doc.Doc;
import drc.ast.DefaultVisitor,
       drc.ast.Node,
       drc.ast.Declarations,
       drc.ast.Statements,
       drc.ast.Expression,
       drc.ast.Parameters,
       drc.ast.Types;
import drc.lexer.Token,
       drc.lexer.Funcs;
import drc.semantic.Module;
import drc.Diagnostics;
import drc.SourceText;
import drc.Enums;
import common;

import text.Ascii : вЗаг, сравнилюб;

/// Обходит синтактическое дерево и записывает макросы DDoc в текстовый буфер.
abstract class ЭмиттерДДок : ДефолтныйВизитёр
{
  ткст текст; /// Буфер, в который происходит запись.
  бул включатьНедокументированное;
  ТаблицаМакросов мтаблица;
  Модуль модуль;
  ПодсветчикСем псвСем;

  /// Конструирует объект ЭмиттерДДок.
  /// Параметры:
  ///   модуль = модуль, для которого генерируется текст.
  ///   мтаблица = таблица макросов.
  ///   включатьНедокументированное = включать ли недокументированные символы.
  ///   псвСем = используется для подсветки разделов кода.
  this(Модуль модуль, ТаблицаМакросов мтаблица, бул включатьНедокументированное,
       ПодсветчикСем псвСем)
  {
    this.мтаблица = мтаблица;
    this.включатьНедокументированное = включатьНедокументированное;
    this.модуль = модуль;
    this.псвСем = псвСем;
  }

  /// Метод ввода.
  ткст выдать()
  {
    if (файлДДок(модуль))
    { // Модуль действительно является текстовым файлом DDoc.
      auto с = УтилитыДДок.дайКомментарийДДок(дайТекстДДок(модуль));
      foreach (s; с.разделы)
      {
        if (s.Является("макрос"))
        { // E этой секции декларируется макрос.
          auto ms = new РазделМакросов(s.имя, s.текст);
          мтаблица.вставь(ms.именаМакросов, ms.текстыМакросов);
        }
        else
          пиши(s.весьТекст);
      }
      return текст;
    }
    // Обрабатывать как обычный модуль Ди с декларациями.
    if (auto d = модуль.деклМодуля)
    {
      if (ддок(d))
      {
        if (auto авторское_право = коммент.взятьАвторскоеПраво())
          мтаблица.вставь("COPYRIGHT", авторское_право.текст);
        writeComment();
      }
    }
    ЧЛЕНЫ("МОДУЛЬ", "", модуль.корень);
    return текст;
  }

  /// Возвращает "да", если исходный текст начинается с "Ddoc\n" (регистр букв не важен.)
  static бул файлДДок(Модуль мод)
  {
    auto данные = мод.исходныйТекст.данные;
    // 5 = "ддок\n".length; +1 = заключительный '\0' в данных.
    if (данные.length >= 5 + 1 && // Проверим на минимальную длину.
        сравнилюб(данные[0..4], "ддок") == 0 && // Проверим первых четыре символа.
        новСтр(данные.ptr + 4)) // Проверим на нс.
      return да;
    return нет;
  }

  /// Возвращает DDoc текст данного модуля.
  static ткст дайТекстДДок(Модуль мод)
  {
    auto данные = мод.исходныйТекст.данные;
    сим* у = данные.ptr + "ддок".length;
    if (сканируйНовСтр(у)) // Пропустим нс.
      // Исключитьпредшествующий "Ddoc\n" и заключительный '\0'.
      return данные[у-данные.ptr .. $-1];
    return пусто;
  }

  ткст участокТекста(Сема* левый, Сема* правый)
  {
    //assert(левый && правый && (левый.конец <= правый.старт || левый is правый));
    //ткст результат;
    //TODO: отфильтровать пробельныеe семы.
    return Сема.участокТекста(левый, правый);
  }

  /// Параметры шаблона текущей декларации.
  ПараметрыШаблона шпарамы;

  /// Отражает ПКИ (полное квалифицированное имя) родителя текущего символа.
  /// При входе в Масштаб происходит вталкивание на стек, при выходе - выталкивание.
  ткст[] стэкПКИ;
  /// Считает символы с одинаковым ПКИ.
  /// Используется для для имён-якорей, требующих уникальные тксты.
  бцел[ткст] счётПКИ;

  /// Вталкивает идентификатор на стек.
  проц  суньПКИ(ткст пки)
  {
    if (пки.length)
      стэкПКИ ~= пки;
  }
  /// Выталкивает идентификатор из стека.
  проц  выньПКИ()
  {
    if (стэкПКИ.length)
      стэкПКИ = стэкПКИ[0..$-1];
  }

  /// Возвращает уникальный идентифицирующий ткст для текущего символа.
  ткст дайПКНСимвола(ткст имя)
  {
    ткст пки;
    foreach (часть_имени; стэкПКИ)
      пки ~= часть_имени ~ ".";
    пки ~= имя;

    бцел счёт;
    auto укПки = пки in счётПКИ;
    if (укПки)
      счёт = (*укПки += 1); // Счётчик обновлений.
    else
      счётПКИ[пки] = 1; // Начнём счёт с 1.

    if (счёт > 1) // Игнорировать уникальный суффикс для значение 1.
      пки ~= Формат(":{}", счёт);
    return пки;
  }

  КомментарийДДок коммент; /// Текущий комментарий.
  КомментарийДДок предшКоммент; /// Предыдущий комментарий в Масштабе.
  /// Пустой комментарий. Используется для недокументированных символов.
  static const КомментарийДДок пустойКоммент;

  /// Инициализирует пустой комментарий.
  static this()
  {
    this.пустойКоммент = new КомментарийДДок(пусто, пусто, пусто);
  }

  /// Отслеживает путь предшествующего комментария в каждом Масштабе.
 scope class МасштабДДок
  {
    КомментарийДДок сохр_предшКоммент;
    бул saved_cmntIsDitto;
    бцел сохр_смещениеПредшДекл;
    /// Когда построены, переменные сохраняются.
    this(ткст имя)
    { // Сохранить предшествующий комментарий родительского Масштаба.
      сохр_предшКоммент = this.outer.предшКоммент;
      saved_cmntIsDitto = this.outer.cmntIsDitto;
      сохр_смещениеПредшДекл = this.outer.предшСмещДекл;
      суньПКИ(имя);
      // Вход в новый Масштаб. Очистка переменных.
      this.outer.предшКоммент = пусто;
      this.outer.cmntIsDitto = нет;
      this.outer.предшСмещДекл = 0;
    }
    /// После разрушения переменные восстанавливаются.
    ~this()
    { // Восстановить предшествующий комментарий родительского Масштаба.
      this.outer.предшКоммент = сохр_предшКоммент;
      this.outer.cmntIsDitto = saved_cmntIsDitto;
      this.outer.предшСмещДекл = сохр_смещениеПредшДекл;
      выньПКИ();
    }
  }

  бул cmntIsDitto; /// Истина, если текущий комментарий = "определено".

  /// Устанавликает некоторые члены и возвращает КомментарийДДок для узла.
  КомментарийДДок ддок(Узел узел)
  {
    this.коммент = УтилитыДДок.дайКомментарийДДок(узел);
    if (this.коммент)
    {
      if (this.коммент.дитто) // атр определено comment.
        (this.коммент = this.предшКоммент), (this.cmntIsDitto = да);
      else // атр nилиmal comment.
        (this.предшКоммент = this.коммент), (this.cmntIsDitto = нет);
    }
    else if (включатьНедокументированное)
      this.коммент = this.пустойКоммент; // Присвоить особый пустой комментарий.
    return this.коммент;
  }

  /// Список предопределённых особых резделов.
  static сим[][сим[]] особыеВыделения;
  static this()
  {
    foreach (имя; ["АВТОРЫ", "БАГИ", "АВТОРСКОЕ_ПРАВО", "ДАТА", "ДЕПРЕКИРОВАНО",
                    "ПРИМЕРЫ", "ИСТОРИЯ", "ЛИЦЕНЗИЯ", "ВОЗВРАТЫ", "СМ_ТАКЖЕ",
                    "СТАНДАРТЫ", "ВЫБРАСЫВАЕТ", "ВЕРСИЯ"] ~
                   ["АВТОР"]) // Addition by drc.
      особыеВыделения[имя] = имя;
  }

  /// Записывает комментарий DDoc в текстовый буфер.
  проц  writeComment()
  {
    auto с = this.коммент;
    assert(с !is пусто);
    пиши("$(ДДОК_РАЗДЕЛЫ ");
      foreach (s; с.разделы)
      {
        if (s is с.сводка)
          пиши("\n$(ДДОК_СВОДКА ");
        else if (s is с.описание)
          пиши("\n$(ДДОК_ОПИСАНИЕ ");
        else if (auto имя = вЗаг(s.имя.dup) in особыеВыделения)
          пиши("\n$(ДДОК_", *имя, " ");
        else if (s.Является("парамы"))
        { // Обработать ращздел параметров.
          auto ps = new РазделПараметров(s.имя, s.текст);
          пиши("\n$(ДДОК_ПАРАМЫ ");
          foreach (i, имяПарама; ps.именаПарамов)
            пиши("\n$(ДДОК_РЯД_ПАРАМОВ ",
                    "$(ДДОК_ИД_ПАРАМА $(ДДОК_ПАРАМ ", имяПарама, "))",
                    "$(ДДОК_ОПИС_ПАРАМА ", ps.деклыПарамов[i], ")",
                  ")");
          пиши(")");
          continue;
        }
        else if (s.Является("макрос"))
        { // Декларировать макрос в данном разделе.
          auto ms = new РазделМакросов(s.имя, s.текст);
          мтаблица.вставь(ms.именаМакросов, ms.текстыМакросов);
          continue;
        }
        else
          пиши("\n$(ДДОК_РАЗДЕЛ $(ДДОК_З_РАЗДЕЛА ", замени_(s.имя), ":)");
        пиши(сканируйТекстКоммента(s.текст), ")");
      }
    пиши(")");
  }

  /// Заменяет в ткт случаи '_' на ' ' .
  ткст замени_(ткст ткт)
  {
    foreach (ref с; ткт.dup)
      if (с == '_') с = ' ';
    return ткт;
  }

  /// Сканирует текст комментария и:
  /// $(UL
  /// $(LI пропускает и оставляет неизменённым вызовы макросов)
  /// $(LI пропускает ГЯР тэги)
  /// $(LI экранирует '(', ')', '<', '>' и '&')
  /// $(LI вставляет $&#40;DDOC_BLANKLINE&#41; на место \n\n)
  /// $(LI подсвечивает код в разделах кода)
  /// )
  ткст сканируйТекстКоммента(ткст текст)
  {
    сим* у = текст.ptr;
    сим* конец = у + текст.length;
    ткст результат = new сим[текст.length]; // Резервируем пространство.
    результат.length = 0;

    while (у < конец)
    {
      switch (*у)
      {
      case '$':
        if (auto конецМакроса = ПарсерМакросов.сканируйМакрос(у, конец))
        {
          результат ~= сделайТекст(у, конецМакроса); // Копировать как есть вызов макроса
          у = конецМакроса;
          continue;
        }
        goto default;
      case '<':
        auto начало = у;
        у++;
        if (у+2 < конец && *у == '!' && у[1] == '-' && у[2] == '-') // <!--
        {
          у += 2; // Point в 2nd '-'.
          // Сканировать до закрывающей "-->".
          while (++у < конец)
            if (*у == '-' && у+2 < конец && у[1] == '-' && у[2] == '>')
            {
              у += 3; // Point one past '>'.
              break;
            }
          результат ~= сделайТекст(начало, у);
        } // <тэг ...> или </тэг>
        else if (у < конец && (буква(*у) || *у == '/'))
        {
          while (++у < конец && *у != '>') // Пропустим в закрывающий '>'.
          {}
          if (у == конец)
          { // No закрывающий '>' found.
            у = начало + 1;
            результат ~= "&тк;";
            continue;
          }
          у++; // Пропустим '>'.
          результат ~= сделайТекст(начало, у);
        }
        else
          результат ~= "&тк;";
        continue;
      case '(': результат ~= "&#40;"; break;
      case ')': результат ~= "&#41;"; break;
      // case '\'': результат ~= "&apos;"; break; // &#39;
      // case '"': результат ~= "&quot;"; break;
      case '>': результат ~= "&gt;"; break;
      case '&':
        if (у+1 < конец && (буква(у[1]) || у[1] == '#'))
          goto default;
        результат ~= "&amp;";
        break;
      case '\n':
        if (!(у+1 < конец && у[1] == '\n'))
          goto default;
        ++у;
        результат ~= "$(ДДОК_ПУСТАЯ_СТРОКА)";
        break;
      case '-':
        if (у+2 < конец && у[1] == '-' && у[2] == '-')
        { // Found "---".
          while (у < конец && *у == '-') // Пропустим вводящие дефисы.
            у++;
          auto КодBegin = у;
          while (у < конец && пбел(*у))
            у++;
          if (у < конец && *у == '\n') // Пропустим первый нс.
            КодBegin = ++у;
          // Найдём закрывающие дефисы.
          while (у < конец && !(*у == '-' && у+2 < конец &&
                            у[1] == '-' && у[2] == '-'))
            у++;
          // Удалить последний нс, если он есть.
          auto КодКонец = у;
          while (пбел(*--КодКонец))
          {}
          if (*КодКонец != '\n') // Leaving the pointer on '\n' will exclude it.
            КодКонец++; // Include the non-нс символ.
          if (КодBegin < КодКонец)
          { // Highlight the extracted source код.
            auto Кодтекст = сделайТекст(КодBegin, КодКонец);
            Кодтекст = УтилитыДДок.unindentText(Кодтекст);
            результат ~= псвСем.highlight(Кодтекст, модуль.дайПКИ());
          }
          while (у < конец && *у == '-') // Пропустим remaining dashes.
            у++;
          continue;
        }
        //goto default;
      default:
        результат ~= *у;
      }
      у++;
    }
    assert(у is конец);
    return результат;
  }

  /// Escapes '<', '>' and '&' with Имяd ГЯР entities.
  ткст escape(ткст текст)
  {
    ткст результат = new сим[текст.length]; // Reserve space.
    результат.length = 0;
    foreach(с; текст)
      switch(с)
      {
        case '<': результат ~= "&тк;";  break;
        case '>': результат ~= "&gt;";  break;
        case '&': результат ~= "&amp;"; break;
        default:  результат ~= с;
      }
    if (результат.length != текст.length)
      return результат;
    // Nothing escaped. Итог илиiginal текст.
    delete результат;
    return текст;
  }

  /// Writes an массив of тксты в the текст буфер.
  проц  пиши(сим[][] тксты...)
  {
    foreach (s; тксты)
      текст ~= s;
  }

  /// Writes парамы в the текст буфер.
  проц  пишиПарамы(Параметры парамы)
  {
    пиши("$(DRC_PARAMS ");
    foreach (парам; парамы.элементы)
    {
      if (парам.СиВариадический)
        пиши("...");
      else
      {
        assert(парам.тип);
        // Write stилиage classes.
        auto typeBegin = парам.тип.типОснова.начало;
        if (typeBegin !is парам.начало) // Write stилиage classes.
          пиши(участокТекста(парам.начало, typeBegin.предшНепроб), " ");
        пиши(escape(участокТекста(typeBegin, парам.тип.конец))); // Write тип.
        if (парам.имя)
          пиши(" $(DDOC_PARAM ", парам.имя.ткт, ")");
        if (парам.ДиВариадический)
          пиши("...");
        if (парам.дефЗначение)
          пиши(" = ", escape(участокТекста(парам.дефЗначение.начало, парам.дефЗначение.конец)));
      }
      пиши(", ");
    }
    if (парамы.элементы)
      текст = текст[0..$-2]; /// Срез off last ", ".
    пиши(")");
  }

  /// Writes the current template параметры в the текст буфер.
  проц  пишиПарамыШаблона()
  {
    if (!шпарамы)
      return;
    auto текст = участокТекста(шпарамы.начало, шпарамы.конец);
    текст = escape(текст)[1..$-1]; // Escape and remove '(', ')'.
    пиши("$(DRC_TEMPLATE_PARAMS ", текст, ")");
    шпарамы = пусто;
  }

  /// Writes основы в the текст буфер.
  проц  пишиСписокНаследования(ТипКлассОснова[] основы)
  {
    if (основы.length == 0)
      return;
    auto basesBegin = основы[0].начало.предшНепроб;
    if (basesBegin.вид == TOK.Двоеточие)
      basesBegin = основы[0].начало;
    auto текст = escape(участокТекста(basesBegin, основы[$-1].конец));
    пиши(" $(DRC_BASE_CLASSES ", текст, ")");
  }

  /// Offset at which в вставь a declaration with a "определено" comment.
  бцел предшСмещДекл;

  /// Writes a declaration в the текст буфер.
  проц  ДЕКЛ(проц  delegate() dg, Декларация d, бул writeSemicolon = да)
  {
    проц  пишиДЕКЛ()
    {
      пиши("\n$(DDOC_DECL ");
      dg();
      writeSemicolon && пиши(";");
      пишиАтрибуты(d);
      пиши(")");
    }

    if (/+включатьНедокументированное &&+/ this.коммент is this.пустойКоммент)
    { // Handle undocumented символы separately.
      // Этот way they don'т interrupt consolidated declarations.
      пишиДЕКЛ();
      // Write an empty DDOC_DECL_DD.
      // The method ДЕСК() does not выдать anything when cmntIsDitto is да.
      cmntIsDitto && пиши("\n$(DDOC_DECL_DD)");
    }
    else if (cmntIsDitto)
    { // The declaration has a определено comment.
      alias предшСмещДекл offs;
      assert(offs != 0);
      auto savedText = текст;
      текст = "";
      пишиДЕКЛ();
      // Вставить текст at offset.
      auto len = текст.length;
      текст = savedText[0..offs] ~ текст ~ savedText[offs..$];
      offs += len; // Add length of the inserted текст в the offset.
    }
    else
    {
      пишиДЕКЛ();
      // Установить the offset. At this offset другой declarations with a определено
      // comment will be inserted, if present.
      предшСмещДекл = текст.length;
    }
  }

  /// Wraps the DDOC_DECL_DD macro around the текст Автор dg().
  /// Writes the comment befилиe dg() is called.
  проц  ДЕСК(проц  delegate() dg = пусто)
  {
    if (cmntIsDitto)
      return; // Don'т пиши a описание when we have a определено declaration.
    пиши("\n$(DDOC_DECL_DD ");
    writeComment();
    dg && dg();
    пиши(")");
  }

  /// Writes символ в the текст буфер.
  /// E.g: &#36;(DRC_SYMBOL сканируй, Лексер.сканируй, функц, 229, 646);
  проц  СИМВОЛ(ткст имя, ткст вид, Декларация d)
  {
    auto пки = дайПКНСимвола(имя);
    auto место = d.начало.дайРеальноеПоложение();
    auto loc_end = d.конец.дайРеальноеПоложение();
    auto ткт = Формат("$(DRC_SYMBOL {}, {}, {}, {}, {})",
                      имя, пки, вид, место.номерСтроки, loc_end.номерСтроки);
    пиши(ткт);
    // пиши("$(DDOC_PСИМВОЛ ", имя, ")"); // DMD's macro with no инфо.
  }

  /// Wraps the DDOC_kind_ЧленS macro around the текст
  /// Автор посети(члены).
  проц  ЧЛЕНЫ(D)(ткст вид, ткст имя, D члены)
  {
    scope s = new МасштабДДок(имя);
    пиши("\n$(DDOC_"~вид~"_ЧленS ");
    if (члены !is пусто)
      super.посети(члены);
    пиши(")");
  }

  /// Writes a class или interface declaration.
  проц  пишиКлассИлиИнтерфейс(T)(T d)
  {
    //if (!ддок(d))
     // return d;
    ДЕКЛ({
      const вид = is(T == ДекларацияКласса) ? "class" : "interface";
      пиши(вид, " ");
      СИМВОЛ(d.имя.ткт, вид, d);
      пишиПарамыШаблона();
      пишиСписокНаследования(d.основы);
    }, d);
    const вид = is(T == ДекларацияКласса) ? "CLASS" : "INTERFACE";
    ДЕСК({ ЧЛЕНЫ(вид, d.имя.ткт, d.деклы); });
  }

  /// Writes a struct или union declaration.
  проц  пишиСтруктИлиСоюз(T)(T d)
  {
    //if (!ддок(d))
     // return d;
    ДЕКЛ({
      const вид = is(T == ДекларацияСтруктуры) ? "struct" : "union";
      пиши(вид, d.имя ? " " : "");
      if (d.имя)
        СИМВОЛ(d.имя.ткт, вид, d);
      пишиПарамыШаблона();
    }, d);
    const вид = is(T == ДекларацияСтруктуры) ? "STRUCT" : "UNION";
    ДЕСК({ ЧЛЕНЫ(вид, d.имя ? d.имя.ткт : "", d.деклы); });
  }

  /// Writes an alias или alias declaration.
  проц  пишиАлиасИлиТипдеф(T)(T d)
  {
    const вид = is(T == ДекларацияАлиаса) ? "alias" : "alias";
    if (auto vd = d.декл.Является!(ДекларацияПеременных))
    {
      auto тип = участокТекста(vd.узелТипа.типОснова.начало, vd.узелТипа.конец);
      foreach (имя; vd.имена)
        ДЕКЛ({ пиши(вид, " "); пиши(escape(тип), " ");
          СИМВОЛ(имя.ткт, вид, d);
        }, d);
    }
    else if (auto дф = d.декл.Является!(ДекларацияФункции))
    {}
    // ДЕКЛ({ пиши(участокТекста(d.начало, d.конец)); }, нет);
    ДЕСК();
  }

  /// Writes the атрибуты of a declaration in brackets.
  проц  пишиАтрибуты(Декларация d)
  {
    сим[][] атрибуты;

    if (d.защ != Защита.Нет)
      атрибуты ~= "$(DRC_PROT " ~ .вТкст(d.защ) ~ ")";

    auto кхр = d.кхр;
    кхр &= ~КлассХранения.Авто; // Ignилиe auto.
    foreach (stcStr; .вТксты(кхр))
      атрибуты ~= "$(DRC_STC " ~ stcStr ~ ")";

    ТипКомпоновки типК;
    if (auto vd = d.Является!(ДекларацияПеременных))
      типК = vd.типКомпоновки;
    else if (auto дф = d.Является!(ДекларацияФункции))
      типК = дф.типКомпоновки;

    if (типК != ТипКомпоновки.Нет)
      атрибуты ~= "$(DRC_LINKAGE extern(" ~ .вТкст(типК) ~ "))";

    if (!атрибуты.length)
      return;

    пиши(" $(DRC_ATTRIBUTES ", атрибуты[0]);
    foreach (атрибут; атрибуты[1..$])
      пиши(", ", атрибут);
    пиши(")");
  }

  alias Декларация D;

override:
  D посети(ДекларацияАлиаса d)
  {
    if (ддок(d))
      пишиАлиасИлиТипдеф(d);
    return d;
  }

  D посети(ДекларацияТипдефа d)
  {
    if (ддок(d))
      пишиАлиасИлиТипдеф(d);
    return d;
  }

  D посети(ДекларацияПеречня d)
  {
    if (!ддок(d))
      return d;
    ДЕКЛ({
      пиши("enum", d.имя ? " " : "");
      d.имя && СИМВОЛ(d.имя.ткт, "enum", d);
    }, d);
    ДЕСК({ ЧЛЕНЫ("ENUM", d.имя ? d.имя.ткт : "", d); });
    return d;
  }

  D посети(ДекларацияЧленаПеречня d)
  {
    if (!ддок(d))
      return d;
    ДЕКЛ({ СИМВОЛ(d.имя.ткт, "enummem", d); }, d, нет);
    ДЕСК();
    return d;
  }

  D посети(ДекларацияШаблона d)
  {
    this.шпарамы = d.шпарамы;
    if (d.начало.вид != TOK.Шаблон)
    { // Этот есть templatized class/interface/struct/union/function.
      super.посети(d.деклы);
      this.шпарамы = пусто;
      return d;
    }
    if (!ддок(d))
      return d;
    ДЕКЛ({
      пиши("template ");
      СИМВОЛ(d.имя.ткт, "template", d);
      пишиПарамыШаблона();
    }, d);
    ДЕСК({ ЧЛЕНЫ("TEMPLATE", d.имя.ткт, d.деклы); });
    return d;
  }

  D посети(ДекларацияКласса d)
  {
    пишиКлассИлиИнтерфейс(d);
    return d;
  }

  D посети(ДекларацияИнтерфейса d)
  {
    пишиКлассИлиИнтерфейс(d);
    return d;
  }

  D посети(ДекларацияСтруктуры d)
  {
    пишиСтруктИлиСоюз(d);
    return d;
  }

  D посети(ДекларацияСоюза d)
  {
    пишиСтруктИлиСоюз(d);
    return d;
  }

  D посети(ДекларацияКонструктора d)
  {
    if (!ддок(d))
      return d;
    ДЕКЛ({ СИМВОЛ("this", "ctor", d); пишиПарамы(d.парамы); }, d);
    ДЕСК();
    return d;
  }

  D посети(ДекларацияСтатическогоКонструктора d)
  {
    if (!ддок(d))
      return d;
    ДЕКЛ({ пиши("static "); СИМВОЛ("this", "sctor", d); пиши("()"); }, d);
    ДЕСК();
    return d;
  }

  D посети(ДекларацияДеструктора d)
  {
    if (!ддок(d))
      return d;
    ДЕКЛ({ пиши("~"); СИМВОЛ("this", "dtor", d); пиши("()"); }, d);
    ДЕСК();
    return d;
  }

  D посети(ДекларацияСтатическогоДеструктора d)
  {
    if (!ддок(d))
      return d;
    ДЕКЛ({ пиши("static ~"); СИМВОЛ("this", "sdtor", d); пиши("()"); }, d);
    ДЕСК();
    return d;
  }

  D посети(ДекларацияФункции d)
  {
    if (!ддок(d))
      return d;
    auto тип = участокТекста(d.типВозврата.типОснова.начало, d.типВозврата.конец);
    ДЕКЛ({
      пиши(escape(тип), " ");
      СИМВОЛ(d.имя.ткт, "function", d);
      пишиПарамыШаблона();
      пишиПарамы(d.парамы);
    }, d);
    ДЕСК();
    return d;
  }

  D посети(ДекларацияНов d)
  {
    if (!ддок(d))
      return d;
    ДЕКЛ({ СИМВОЛ("new", "new", d); пишиПарамы(d.парамы); }, d);
    ДЕСК();
    return d;
  }

  D посети(ДекларацияУдали d)
  {
    if (!ддок(d))
      return d;
    ДЕКЛ({ СИМВОЛ("delete", "delete", d); пишиПарамы(d.парамы); }, d);
    ДЕСК();
    return d;
  }

  D посети(ДекларацияПеременных d)
  {
    if (!ддок(d))
      return d;
    ткст тип = "auto";
    if (d.узелТипа)
      тип = участокТекста(d.узелТипа.типОснова.начало, d.узелТипа.конец);
    foreach (имя; d.имена)
      ДЕКЛ({ пиши(escape(тип), " "); СИМВОЛ(имя.ткт, "переменная", d); }, d);
    ДЕСК();
    return d;
  }

  D посети(ДекларацияИнварианта d)
  {
    if (!ддок(d))
      return d;
    ДЕКЛ({ СИМВОЛ("invariant", "invariant", d); }, d);
    ДЕСК();
    return d;
  }

  D посети(ДекларацияЮниттеста d)
  {
    if (!ддок(d))
      return d;
    ДЕКЛ({ СИМВОЛ("unittest", "unittest", d); }, d);
    ДЕСК();
    return d;
  }

  D посети(ДекларацияОтладки d)
  {
    d.компилированныеДеклы && посетиД(d.компилированныеДеклы);
    return d;
  }

  D посети(ДекларацияВерсии d)
  {
    d.компилированныеДеклы && посетиД(d.компилированныеДеклы);
    return d;
  }

  D посети(ДекларацияСтатическогоЕсли d)
  {
    d.деклыЕсли && посетиД(d.деклыЕсли);
    return d;
  }
}
