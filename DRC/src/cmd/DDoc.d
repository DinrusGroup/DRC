module cmd.DDoc;

import cmd.DDocEmitter,
       cmd.DDocHTML,
       cmd.DDocXML,
       cmd.Highlight;
import drc.doc.Parser,
       drc.doc.Macro,
       drc.doc.Doc;
import drc.lexer.Token,
       drc.lexer.Funcs;
import drc.semantic.Module,
       drc.semantic.Pass1,
       drc.semantic.Symbol,
       drc.semantic.Symbols;
import drc.Compilation;
import drc.Diagnostics;
import drc.Converter;
import drc.SourceText;
import drc.Enums;
import drc.Time;
import common;

import text.Ascii : вЗаг;
import io.File;
import io.FilePath;

/// ddoc команда.
struct КомандаДДок
{
  ткст путьКПапкеНазн;  /// Папка назначения.
  ткст[] макроПути; /// Пути к файлам макросов.
  ткст[] путиКФайлам;  /// Пути к файлам модулей.
  ткст ПутьТкстаМод;  /// Записать в этот файл (если он указан) список модулей.
  ткст расшВыводимогоФайла;  /// Расширение выводимых файлов.
  бул включатьНедокументированное; /// Включать ли недокументированные символы?
  бул писатьРЯР; /// Писать ли РЯР вместо документов на ГЯР?
  бул подробно;  /// Многословность?

  КонтекстКомпиляции контекст; /// Переменные среды компиляции.
  Диагностика диаг;        /// Собрать сообщения об ошибках.
  ПодсветчикСем псвСем;   /// Для подсвечивания сем секций кода DDoc.

  /// Выполняет команду генерации документации.
  проц  пуск()
  {
    // Парсировать файлы макрокоманд и построить иерархию таблицы макросов.
    ТаблицаМакросов мтаблица;
    ПарсерМакросов мпарсер;
    foreach (макроПуть; макроПути)
    {
      auto макрос = мпарсер.разбор(загрузиФайлМакросов(макроПуть, диаг));
      мтаблица = new ТаблицаМакросов(мтаблица);
      мтаблица.вставь(макрос);
    }

    // При DDoc код резделы.
    псвСем = new ПодсветчикСем(диаг, писатьРЯР == нет);
    расшВыводимогоФайла = писатьРЯР ? ".xml" : ".html";

    ткст[][] modFQNs; // Список кортежей (путьКФайлу, пкиМодуля).
    бул генерироватьТекстФайлыМодулей = ПутьТкстаМод !is пусто;

    // Обработать файлы Динрус.
    foreach (путьКФайлу; путиКФайлам)
    {
      auto мод = new Модуль(путьКФайлу, диаг);

      // Разбирать только когда файл не является "DDoc"-файлом.
      if (!ЭмиттерДДок.файлДДок(мод))
      {
        мод.разбор();
        // Нет документации для ошибочных исходников.
        if (мод.естьОшибки)
          continue;
        // Начало семантического анализа.
        auto проходка1 = new СемантическаяПроходка1(мод, контекст);
        проходка1.пуск();

        if (генерироватьТекстФайлыМодулей)
          modFQNs ~= [путьКФайлу, мод.дайПКИ()];
      }
      else // Обычно делается в мод.разбор().
        мод.установиПКИ((new ФПуть(путьКФайлу)).имя());

      // Записать в файл документации.
     пишиФайлДокументации(мод, мтаблица);
    }

    if (генерироватьТекстФайлыМодулей)
      пишиТекстФайлМодулей(modFQNs);
  }

  /// Записывает на диск документацию на модуль.
  /// Параметры:
  ///   мод = обрабатываемый модуль.
  ///   мтаблица = главная среда макросов.
  проц  пишиФайлДокументации(Модуль мод, ТаблицаМакросов мтаблица)
  {
    // Создать собственную макросреду для этого модуля.
    мтаблица = new ТаблицаМакросов(мтаблица);
    // Определить макрокоманду рантайма.
    auto modFQN = мод.дайПКИ();
    мтаблица.вставь("DRC_MODPATH", мод.дайПутьПКИ() ~ "." ~ мод.расширениеФайла());
    мтаблица.вставь("DRC_MODFQN", modFQN);
    мтаблица.вставь("DRC_DOCFILENAME", modFQN ~ расшВыводимогоФайла);
    мтаблица.вставь("TITLE", modFQN);
    auto ткстВрем = Время.вТкст();
    мтаблица.вставь("DATETIME", ткстВрем);
    мтаблица.вставь("YEAR", Время.год(ткстВрем));

    // Создать соответствующий ЭмиттерДДок.
    ЭмиттерДДок эмиттерДДок;
    if (писатьРЯР)
      эмиттерДДок = new РЯРЭмиттерДДок(мод, мтаблица, включатьНедокументированное, псвСем);
    else
      эмиттерДДок = new ГЯРЭмиттерДДок(мод, мтаблица, включатьНедокументированное, псвСем);
    // Запуск эммитера.
    auto ddocText = эмиттерДДок.выдать();
    // Установить макрос BODY на текст, производимый эммитером.
    мтаблица.вставь("BODY", ddocText);
    // Сделать проходку разворачивания макросов.
    auto текстФайла = РаскрывательМакросов.раскрой(мтаблица, "$(DDOC)",
                                         мод.путьКФайлу,
                                         подробно ? диаг : пусто);
    // debug текстФайла ~= "\n<pre>\n" ~ doc.текст ~ "\n</pre>";

    // Записать по целевому пути назначения в файл.
    auto путьНазнач = new ФПуть(путьКПапкеНазн);
    путьНазнач.добавь(мод.дайПКИ() ~ расшВыводимогоФайла);
    // Подробный вывод активности.
    if (подробно) // TODO: создать настройку для этого формат. текста в dilconf.d?
      выдай.форматнс("ddoc {} > {}", мод.путьКФайлу, путьНазнач);
    // наконец, записать файл на жёсткий диск.
    scope файл = new Файл(путьНазнач.вТкст());
    файл.пиши(текстФайла);
  }

  /// Записывает на диск список обработанных модулей.
  /// Параметры:
  ///   списокМодулей = список модулей.
  проц   пишиТекстФайлМодулей(ткст[][] списокМодулей)
  {
    ткст текст;
    foreach (мод; списокМодулей)
      текст ~= мод[0] ~ ", " ~ мод[1] ~ \n;
    scope файл = new Файл(ПутьТкстаМод);
    файл.пиши(текст);
  }

  /// Загружает файл макросов. Преобразует любую кодировку Юникод в UTF-8.
  /// Параметры:
  ///   путьКФайлу = путь к файлу макросов.
  ///   диаг  = для сообщений об ошибках.
  static ткст загрузиФайлМакросов(ткст путьКФайлу, Диагностика диаг)
  {
    auto ист = new ИсходныйТекст(путьКФайлу);
    ист.загрузи(диаг);
    auto текст = ист.данные[0..$-1]; // Исключить '\0'.
    return обеззаразьТекст(текст);
  }
}
