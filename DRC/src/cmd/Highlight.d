/// Author: Aziz Köksal, Vitaly Kulich
/// License: GPL3
/// $(Maturity average)
module cmd.Highlight;

import drc.ast.DefaultVisitor,
       drc.ast.Node,
       drc.ast.Declaration,
       drc.ast.Statement,
       drc.ast.Expression,
       drc.ast.Types;
import drc.lexer.Lexer;
import drc.parser.Parser;
import drc.semantic.Module;
import drc.SourceText;
import drc.Diagnostics;
import SettingsLoader;
import Settings;
import common;

import io.Buffer;
import io.FilePath;
import io.stream.Format;

public alias ФормВывод!(сим) Принт;
/// The highlight команда.
struct КомандаВыделить
{
  /// Опции for the команда.
  enum Опция
  {
    Нет        = 0,
    Токены      = 1,
    Синтаксис      = 1<<1,
    ГЯР        = 1<<2,
    РЯР         = 1<<3,
    ВыводСтрок  = 1<<4
  }
  alias Опция Опции;

  Опции опции; /// команда опции.
  ткст путьКФайлу; /// Файл путь в the module в be highlighted.
  Диагностика диаг;

  /// Adds o в the опции.
  проц  добавь(Опция o)
  {
    опции |= o;
  }

  /// Executes the команда.
  проц  пуск()
  {
    добавь(КомандаВыделить.Опция.Токены);
    if (!(опции & (Опция.РЯР | Опция.ГЯР)))
      добавь(Опция.РЯР); // Дефолт в РЯР.

    auto mapFilePath = опции & Опция.ГЯР ? ГлобальныеНастройки.файлКартыГЯР
                                             : ГлобальныеНастройки.файлКартыРЯР;
    auto карта = ЗагрузчикКартыТегов(диаг).загрузи(mapFilePath);
    auto тэги = new КартаТегов(карта);

    if (диаг.естьИнфо)
      return;

    if (опции & Опция.Синтаксис)
      подсветиСинтаксис(путьКФайлу, тэги, выдай, опции);
    else
      подсветиСемы(путьКФайлу, тэги, выдай, опции);
  }
}

/// Escapes the characters '<', '>' and '&' with Имяd символ entities.
ткст xml_escape(ткст текст)
{
  ткст результат;
  foreach(с; текст)
    switch(с)
    {
      case '<': результат ~= "&тк;";  break;
      case '>': результат ~= "&gt;";  break;
      case '&': результат ~= "&amp;"; break;
      default:  результат ~= с;
    }
  if (результат.length != текст.length)
    return результат;
  // Nothing escaped. Итог илиiginal текст.
  delete результат;
  return текст;
}

/// Maps семы в (форматируй) тксты.
class КартаТегов
{
  ткст[ткст] таблица;
  ткст[TOK.МАКС] таблицаСем;

  this(ткст[ткст] таблица)
  {
    this.таблица = таблица;
    Идентификатор   = this["Идентификатор", "{0}"];
    Ткст       = this["Ткст", "{0}"];
    Сим         = this["Сим", "{0}"];
    Число       = this["Число", "{0}"];
    КСлово      = this["КСлово", "{0}"];
    СтрочКом        = this["СтрочКом", "{0}"];
    БлочКом       = this["БлочКом", "{0}"];
    ГнездКом      = this["ГнездКом", "{0}"];
    Шебанг      = this["Шебанг", "{0}"];
    ГСтрока        = this["ГСтрока", "{0}"];
    Файлспец     = this["Файлспец", "{0}"];
    Нелегал      = this["Нелегал", "{0}"];
    Новстр      = this["НовСтр", "{0}"];
    ОсобаяСема = this["ОсобаяСема", "{0}"];
    Декларация  = this["Декларация", "d"];
    Инструкция    = this["Инструкция", "s"];
    Выражение   = this["Выражение", "в"];
    Тип         = this["Тип", "т"];
    Иное        = this["Иное", "o"];
    КФ          = this["КФ", ""];

    foreach (i, tokStr; семаВТкст)
      if (auto pStr = tokStr in this.таблица)
        таблицаСем[i] = *pStr;
  }

  /// Возвращает значение for ткт, или 'fallback' if ткт is not в таблице.
  ткст opIndex(ткст ткт, ткст fallback = "")
  {
    auto у = ткт in таблица;
    if (у)
      return *у;
    return fallback;
  }

  /// Возвращает значение for лекс in O(1) время.
  ткст opIndex(TOK лекс)
  {
    return таблицаСем[лекс];
  }

  /// Сокращения для быстрого доступа.
  ткст Идентификатор, Ткст, Сим, Число, КСлово, СтрочКом, БлочКом,
         ГнездКом, Шебанг, ГСтрока, Файлспец, Нелегал, Новстр, ОсобаяСема,
         Декларация, Инструкция, Выражение, Тип, Иное, КФ;

  /// Возвращает тэг для категории 'nc'.
  ткст дайТэг(КатегорияУзла nc)
  {
    ткст тэг;
    switch (nc)
    { alias КатегорияУзла NC;
    case NC.Декларация: тэг = Декларация; break;
    case NC.Инструкция:   тэг = Инструкция; break;
    case NC.Выражение:  тэг = Выражение; break;
    case NC.Тип:        тэг = Тип; break;
    case NC.Иное:       тэг = Иное; break;
    default: assert(0);
    }
    return тэг;
  }
}

/// Найти последний случай объекта в субъекте.
/// Возвращает: индекс, если он найден, или -1, если нет.
цел рнайди(ткст субъект, сим объект)
{
  foreach_reverse(i, с; субъект)
    if (с == объект)
      return i;
  return -1;
}

/// Возвращает крат class имя of a class descending из Узел.$(BR)
/// Напр.: drc.ast.Declarations.ДекларацияКласса -> Класс
ткст дайКраткоеИмяКласса(Узел узел)
{
  static сим[][] имя_таблицы;
  if (имя_таблицы is пусто)
    имя_таблицы = new сим[][ВидУзла.max+1]; // Create a new таблица.
  // Найти in таблица.
  ткст имя = имя_таблицы[узел.вид];
  if (имя !is пусто)
    return имя; // Итог cached имя.

  имя = узел.classinfo.имя; // Get the fully qualified имя of the class.
  имя = имя[рнайди(имя, '.')+1 .. $]; // Remove package and module имя.

  бцел длинаСуффикса;
  switch (узел.категория)
  {
  alias КатегорияУзла NC;
  case NC.Декларация:
    длинаСуффикса = "Декларация".length;
    break;
  case NC.Инструкция:
    длинаСуффикса = "Инструкция".length;
    break;
  case NC.Выражение:
    длинаСуффикса = "Выражение".length;
    break;
  case NC.Тип:
    длинаСуффикса = "Тип".length;
    break;
  case NC.Иное:
    break;
  default:
    assert(0);
  }
  // Remove common суффикс.
  имя = имя[0 .. $ - длинаСуффикса];
  // Stилиe the имя в таблице.
  имя_таблицы[узел.вид] = имя;
  return имя;
}

/// Структура расширенной семы.
struct СемаДоп
{
  Сема* сема; /// Сема лексера.
  Узел[] начУзлы; /// начУзлы[n].начало == сема
  Узел[] конУзлы; /// конУзлы[n].конец == сема
}

/// Строит массив элементов СемаДоп.
class ПостроительСемаДоп : ДефолтныйВизитёр
{
  private СемаДоп*[Сема*] таблицаСем;

  СемаДоп[] построй(Узел корень, Сема* first)
  {
    auto сема = first;

    бцел счёт; // чло семы.
    for (; сема; сема = сема.следщ)
      счёт++;
    // Creat the exact число of СемаДоп instances.
    auto toks = new СемаДоп[счёт];
    сема = first;
    foreach (ref tokEx; toks)
    {
      tokEx.сема = сема;
      if (!сема.пробел)
        таблицаСем[сема] = &tokEx;
      сема = сема.следщ;
    }

    super.посетиУ(корень);
    таблицаСем = пусто;
    return toks;
  }

  СемаДоп* дайСемаДоп()(Сема* т)
  {
    auto у = т in таблицаСем;
    assert(у, т.исхТекст~" нет в таблицаСем");
    return *у;
  }

  // Перепись отправь function.
  override Узел отправь(Узел n)
  { assert(n !is пусто);
    auto начало = n.начало;
    if (начало)
    { assert(n.конец);
      auto txbegin = дайСемаДоп(начало);
      auto txend = дайСемаДоп(n.конец);
      txbegin.начУзлы ~= n;
      txend.конУзлы ~= n;
    }
    return super.отправь(n);
  }
}

проц  выведиОшибки(Лексер lx, КартаТегов тэги, Принт принт)
{
  foreach (в; lx.ошибки)
    принт.форматируй(тэги["ОшибкаЛексера"], в.путьКФайлу, в.место, в.столб, xml_escape(в.дайСооб));
}

проц  выведиОшибки(Парсер парсер, КартаТегов тэги, Принт принт)
{
  foreach (в; парсер.ошибки)
    принт.форматируй(тэги["ОшибкаПарсера"], в.путьКФайлу, в.место, в.столб, xml_escape(в.дайСооб));
}

проц  выведиСтрочки(бцел строчки, КартаТегов тэги, Принт принт)
{
  auto форматНомераСтрочки = тэги["НомерСтроки"];
  for (auto номерСтроки = 1; номерСтроки <= строчки; номерСтроки++)
    принт.форматируй(форматНомераСтрочки, номерСтроки);
}

/// Подсвечивает синтаксис в исходнике.
проц  подсветиСинтаксис(ткст путьКФайлу, КартаТегов тэги,
                     Принт принт,
                     КомандаВыделить.Опции опции)
{
  auto парсер = new Парсер(new ИсходныйТекст(путьКФайлу, да));
  auto корень = парсер.старт();
  auto lx = парсер.лексер;

  auto построитель = new ПостроительСемаДоп();
  auto tokenExList = построитель.построй(корень, lx.перваяСема());

  принт.форматируй(тэги["ЗаголовокДок"], (new ФПуть(путьКФайлу)).имя());
  if (lx.ошибки.length || парсер.ошибки.length)
  { // Output ошибка сообщения.
    принт(тэги["НачалоКомп"]);
    выведиОшибки(lx, тэги, принт);
    выведиОшибки(парсер, тэги, принт);
    принт(тэги["КонецКомп"]);
  }

  if (опции & КомандаВыделить.Опция.ВыводСтрок)
  {
    принт(тэги["НачалоНомераСтроки"]);
    выведиСтрочки(lx.номерСтроки, тэги, принт);
    принт(тэги["КонецНомераСтроки"]);
  }

  принт(тэги["НачалоИсходника"]);

  auto tagNodeBegin = тэги["НачалоУзла"];
  auto tagNodeEnd = тэги["КонецУзла"];

  // Iterate over список of семы.
  foreach (ref семаДоп; tokenExList)
  {
    auto сема = семаДоп.сема;

    сема.пп && принт(сема.пробСимволы); // Принт preceding whitespace.
    if (сема.пробел) {
      печатайСему(сема, тэги, принт);
      continue;
    }
    // <узел>
    foreach (узел; семаДоп.начУзлы)
      принт.форматируй(tagNodeBegin, тэги.дайТэг(узел.категория), дайКраткоеИмяКласса(узел));
    // Сема текст.
    печатайСему(сема, тэги, принт);
    // </узел>
    if (опции & КомандаВыделить.Опция.ГЯР)
      foreach_reverse (узел; семаДоп.конУзлы)
        принт(tagNodeEnd);
    else
      foreach_reverse (узел; семаДоп.конУзлы)
        принт.форматируй(tagNodeEnd, тэги.дайТэг(узел.категория));
  }
  принт(тэги["КонецИсходника"]);
  принт(тэги["КонецДок"]);
}

/// Подсвечивает все семы исходного файла.
проц  подсветиСемы(ткст путьКФайлу, КартаТегов тэги,
                     Принт принт,
                     КомандаВыделить.Опции опции)
{
  auto lx = new Лексер(new ИсходныйТекст(путьКФайлу, да));
  lx.сканируйВсе();

  принт.форматируй(тэги["ЗаголовокДок"], (new ФПуть(путьКФайлу)).имя());
  if (lx.ошибки.length)
  {
    принт(тэги["НачалоКомп"]);
    выведиОшибки(lx, тэги, принт);
    принт(тэги["КонецКомп"]);
  }

  if (опции & КомандаВыделить.Опция.ВыводСтрок)
  {
    принт(тэги["НачалоНомераСтроки"]);
    выведиСтрочки(lx.номерСтроки, тэги, принт);
    принт(тэги["КонецНомераСтроки"]);
  }

  принт(тэги["НачалоИсходника"]);
  // Traverse linked список and принт семы.
  for (auto сема = lx.перваяСема(); сема; сема = сема.следщ) {
    сема.пп && принт(сема.пробСимволы); // Принт preceding whitespace.
    печатайСему(сема, тэги, принт);
  }
  принт(тэги["КонецИсходника"]);
  принт(тэги["КонецДок"]);
}

/// Подсвечиватель сем, разработанный для ДДок.
class ПодсветчикСем
{
  КартаТегов тэги;
  this(Диагностика диаг, бул useHTML = да)
  {
    ткст путьКФайлу = ГлобальныеНастройки.файлКартыГЯР;
    if (!useHTML)
      путьКФайлу = ГлобальныеНастройки.файлКартыРЯР;
    auto карта = ЗагрузчикКартыТегов(диаг).загрузи(путьКФайлу);
    тэги = new КартаТегов(карта);
  }

  /// Highlights семы in a DDoc код раздел.
  /// Возвращает: a ткст with the highlighted семы (in ГЯР тэги.)
  ткст highlight(ткст текст, ткст путьКФайлу)
  {
    auto буфер = объБуферРоста(текст.length);
    auto принт = new Принт(Формат, буфер);

    auto lx = new Лексер(new ИсходныйТекст(путьКФайлу, текст));
    lx.сканируйВсе();

    // Traverse linked список and принт семы.
    принт("$(D_Код\n");
    if (lx.ошибки.length)
    { // Output ошибка сообщения.
      // FIXME: CompBegin and CompEnd break the таблица layout.
//       принт(тэги["НачалоКомп"]);
      выведиОшибки(lx, тэги, принт);
//       принт(тэги["КонецКомп"]);
    }
    // Traverse linked список and принт семы.
    for (auto сема = lx.перваяСема(); сема; сема = сема.следщ) {
      сема.пп && принт(сема.пробСимволы); // Принт preceding whitespace.
      печатайСему(сема, тэги, принт);
    }
    принт("\n)");
    return cast(сим[])буфер.срез();
  }
}

/// Prints a сема в the тктeam принт.
проц  печатайСему(Сема* сема, КартаТегов тэги, Принт принт)
{
  switch(сема.вид)
  {
  case TOK.Идентификатор:
    принт.форматируй(тэги.Идентификатор, сема.исхТекст);
    break;
  case TOK.Комментарий:
    ткст formatStr;
    switch (сема.старт[1])
    {
    case '/': formatStr = тэги.СтрочКом; break;
    case '*': formatStr = тэги.БлочКом; break;
    case '+': formatStr = тэги.ГнездКом; break;
    default: assert(0);
    }
    принт.форматируй(formatStr, xml_escape(сема.исхТекст));
    break;
  case TOK.Ткст:
    принт.форматируй(тэги.Ткст, xml_escape(сема.исхТекст));
    break;
  case TOK.СимЛитерал:
    принт.форматируй(тэги.Сим, xml_escape(сема.исхТекст));
    break;
  case TOK.Цел32, TOK.Цел64, TOK.Бцел32, TOK.Бцел64,
       TOK.Плав32, TOK.Плав64, TOK.Плав80,
       TOK.Мнимое32, TOK.Мнимое64, TOK.Мнимое80:
    принт.форматируй(тэги.Число, сема.исхТекст);
    break;
  case TOK.Шебанг:
    принт.форматируй(тэги.Шебанг, xml_escape(сема.исхТекст));
    break;
  case TOK.ХэшСтрочка:
    auto formatStr = тэги.ГСтрока;
    // The текст в be inserted into formatStr.
    auto буфер = объБуферРоста;
    auto print2 = new Принт(Формат, буфер);

    проц  выводитьШС(сим* старт, сим* конец)
    {
      старт != конец && print2(старт[0 .. конец - старт]);
    }

    auto чис = сема.номСтрокиСем;
    if (чис is пусто)
    { // Malfилиmed #line
      принт.форматируй(formatStr, сема.исхТекст);
      break;
    }

    // Принт whitespace between #line and число.
    выводитьШС(сема.старт, чис.старт); // Prints "#line" также.
    печатайСему(чис, тэги, print2); // Принт the число.

    if (auto filespec = сема.семаФайлспецСтроки)
    { // Принт whitespace between число and filespec.
      выводитьШС(чис.конец, filespec.старт);
      print2.форматируй(тэги.Файлспец, xml_escape(filespec.исхТекст));
    }
    // ВИтоге принт the whole сема.
    принт.форматируй(formatStr, cast(сим[])буфер.срез());
    break;
  case TOK.Нелегал:
    принт.форматируй(тэги.Нелегал, сема.исхТекст());
    break;
  case TOK.Новстр:
    принт.форматируй(тэги.Новстр, сема.исхТекст());
    break;
  case TOK.КФ:
    принт(тэги.КФ);
    break;
  default:
    if (сема.кслово())
      принт.форматируй(тэги.КСлово, сема.исхТекст);
    else if (сема.спецСема)
      принт.форматируй(тэги.ОсобаяСема, сема.исхТекст);
    else
      принт(тэги[сема.вид]);
  }
}
