module drc.Messages;

import common;

/// Перечень индексов таблицы сообщений компилятора.
enum ИДС
{  // Сообщения Справки:
  ГлавнаяСправка,
  ГенерироватьСправку,
  СправкаОГрафеИмпорта,
  СправкаОКомпиляции,
  СправкаОДДок,
  СправкаОПодсветке,
  СправкаОСеманализе,
  СправкаОСтатистике,
  СправкаОПереводе,
  
  // Сообщения Лексера:
  НедопустимыйСимвол,
//   InvalidЮникодCharacter,
  НедействительнаяПоследовательностьУТФ8,
  // ''
  НеоконченныйСимвольныйЛитерал,
  ПустойСимвольныйЛитерал,
  // #line
  ОжидалсяИдентификаторСтрокиСпецСем,
  ОжидалосьЦелоеПослеСтрокиСпецСем,
//   ОжидалсяФайлспец,
  НеоконченоеУказаниеФайла,
  НеоконченыйОсобыйТокен,
  // ""
  НеоконченыйТкст,
  // x""
  НеГексСимВГексСтроке,
  НечётноеЧислоЦифрВГексСтроке,
  НеоконченнаяГексСтрока,
  // /* */ /+ +/
  НезавершённыйБлочныйКомментарий,
  НезавершённыйГнездовойКомментарий,
  // `` r""
  НеоконченнаяСыраяСтрока,
  НезавершённаяСтрокаСОбратнымиКавычками,
  // \x \u \U
  НеопределённаяИскейпПоследовательность,
  НевернаяИскейпПоследовательностьЮникод,
  НедостатокГексЦифр,
  // \&[a-zA-Z][a-zA-Z0-9]+;
  НеопределённаяСущностьГТЯР,
  НеоконченнаяСущностьГТЯР,
  НеверноеНачалоСущностиГТЯР,
  // integer overflows
  ПереполнениеДесятичнЗнака,
  ПереполнениеДесятичнЧисла,
  ПереполнениеГексЧисла,
  ПереполнениеБинЧисла,
  ПереполнениеОктЧисла,
  ПереполнениеПлавЧисла,
  ВОктЧислеЕстьДесятичные,
  НетЦифрВГексЧисле,
  НетЦифрВБинЧисле,
  ГексПлавЭкспТребуется,
  ГексПлавЭкспДлжнНачСЦифры,
  ПлавЭкспДлжнНачСЦифры,

  // Сообщения Парсера:
  НайденоИноеЧемОжидалось,
  ПовторяющийсяКлассХранения,
  ПараметрКортежШаблона,
  КонтрактИн,
  КонтрактАут,
  ОтсутствуетТипКомпоновки,
  НеопознанныйТипКомпоновки,
  ОжидалисьКлассыОсновы,
  БазовыйКлассВФорвардДекларации,
}

/// Таблица сообщений компилятора.
private ткст[] сообщенияКомпилятора;

static this()
{
  сообщенияКомпилятора = new ткст[ИДС.max+1];
}

/// Устанавливает сообщения компилятора.
проц  УстановиСообщения(ткст[] сообы)
{
  assert(ИДС.max+1 == сообы.length);
  сообщенияКомпилятора = сообы;
}

/// Возвращает сообщение компилятора для указанного идс.
ткст ДайСооб(ИДС идс)
{
  assert(идс < сообщенияКомпилятора.length);
  return сообщенияКомпилятора[идс];
}

/// Возвращает форматированный текст.
ткст ФорматируйСооб(ИДС идс, ...)
{
  return Формат(_arguments, _argptr, ДайСооб(идс));
}

/// Подборка сообщений об ошибке, пока без ИДС.
struct сооб
{
static:
  // Преобразователь:
  auto НеверныйСимволУТФ16 = "неверный символ UTF-16 '\\u{:X4}'.";
  auto НеверныйСимволУТФ32 = "неверный символ UTF-32 '\\U{:X8}'.";
  auto ФайлУТФ16ДолженДелитьсяНа2 = "байтовая длина исходного файла в UTF-16 должна делиться на 2.";
  auto ФайлУТФ32ДолженДелитьсяНа4 = "байтовая длина исходного файла в UTF-32 должна делиться на 4.";
  // DDoc макрос:
  auto НезаданныйМакросДДок = "макрос ДДок '{}' не задан";
  auto НеоконченныйМакросДДок = "У макроса ДДок '{}' нет закрывающей ')'";
  // Лексер сообщения:
  auto ФайлНеЧитается = "файл модуля не читается";
  auto ФайлОтсутствует = "файл модуля не есть_ли";
  auto НевернаяВосмеричнаяИскейпПоследовательность = "значение восмеричной последовательности уклонения больше 0xFF: '{}'";
  auto НеверноеИмяМодуля = "имя файла '{}' не может использоваться в качестве имени модуля; является неверный или зарезервированный идентификатор Ди.";
  // Парсер сообщения:
  auto НедействительнаяПоследовательностьУТФ8ВТексте = "неверная цепочка UTF-8 в текстовом литерале: '{0}'";
  auto ДекларацияМодуляНеПервая = "декларация модуля допускается только в форме первой декларации в данном файле";
  auto StringPostfixMismatch = "у текстового литерала несоответствующий постфиксный символ";
  auto ExpectedIdAfterTypeDot = "ожидался идентификатор после '(Тип).', а не '{}'";
  auto ОжидалсяИдентификаторМодуля = "ожидался идентификатор модуля, но не '{}'";
  auto НелегальнаяДекларация = "обнаружена нелегальная декларация: {}";
  auto ОжидалосьНазваниеФункции = "ожидалось название функции, а не '{}'";
  auto ОжидалосьНазваниеПеременной = "ожидалось название переменной, а не '{}'";
  auto ОжидалосьТелоФункции = "ожидалось тело функции, а не '{}'";
  auto ПовторяющийсяТипЛинковки = "повторяющийся тип компоновки: {}";
  auto ОжидалсяИдентификаторПрагмы = "ожидался идентификатор прагмы, а не '{}'";
  auto ОжидалосьПсевдоимяМодуля = "ожидался алиас названия модуля, а не '{}'";
  auto ОжидалосьПсевдоимяИмпорта = "ожидался алиас названия, а не '{}'";
  auto ОжидалосьИмяИмпорта = "ожидался идентификатор, а не '{}'";
  auto ОжидалсяЧленПеречня = "ожидался член перечня, а не '{}'";
  auto ОжидалосьТелоПеречня = "ожидалось тело перечня, а не '{}'";
  auto ОжидалосьНазваниеКласса = "ожидалось имя класса, а не '{}'";
  auto ОжидалосьТелоКласса = "ожидалось тело класса, а не '{}'";
  auto ОжидалосьНазваниеИнтерфейса = "ожидалось название интерфейса, а не '{}'";
  auto ОжидалосьТелоИнтерфейса = "ожидалось тело интерфейса, а не '{}'";
  auto ОжидалосьТелоСтруктуры = "ожидалось тело структуры, а не '{}'";
  auto ОжидалосьТелоСоюза = "ожидалось тело союза, а не '{}'";
  auto ОжидалосьНазваниеШаблона = "ожидалось название шаблона, а не '{}'";
  auto ОжидалсяИдентификатор = "ожидался идентификатор, а не '{}'";
  auto НелегальнаяИнструкция = "обнаружена нелегальная инструкция: {}";
  auto ОжидаласьНеПустаяИнструкция = "неожиданная ';', используйте вместо нее {{ }";
  auto ОжидалсяИдентификаторМасштаба = "ожидались 'выход', 'успех' или 'сбой', а не '{}'";
  auto НеверныйИдентификаторМасштаба = "'выход', 'успех', 'сбой' являются вылидными идентификаторами масштаба, а не '{}'";
  auto ExpectedIntegerAfterAlign = "после align ожидалось целое, а не '{}'";
  auto ИнструкцияНелегальныйАсм = "обнаружена нелегальная инструкция на ассемблере: {}";
  auto ОжидалсяИдентификаторДекларатора = "ожидался идентификатор декларатора, а не '{}'";
  auto ОжидалисьПараметрыШаблона = "ожидался один или несколько параметров шаблонов, а не ')'";
  auto ОжидалсяТипИлиВыражение = "ожидался тип или выражение, а не ')'";
  auto ОжидалсяАлиасПараметраШаблона = "ожидалось имя для параметра шаблона alias, а не '{}'";
  auto ОжидалосьИмяДляПараметраШаблонаThis = "ожидалось имя для параметра шаблона 'this', а не '{}'";
  auto ОжидалсяИдентИлиЦел = "ожидался идентификатор или целое, но не '{}'";
  auto НеДостаетCatchИлиВИтоге = "у инструкции try отсутствует тело catch или finally.";
  // Semantic analysis:
  auto МодульНеЗагружен = "не удалось импортировать модуль '{}'";
  auto КонфликтующиеФайлыМодулей = "модуль конфликтует с модулем '{}'";
  auto КонфликтующиеМодульИПакет = "модуль конфликтует с пакетом '{}'";
  auto ВПакетеНетМодуля = "модуль ожидался в пакете '{}'";
  auto НеопределенныйИдентификатор = "неизвестный идентификатор '{}'";
  auto ДеклКонфликтуетСДекл = "декларация '{}' конфликтует с декларацией @{}";
  auto ПеременнаяКонфликтуетСДекл = "переменная '{}' конфликтует с декларацией @{}";
  auto УИнтерфейсаНеДолжноБытьПеременных = "у интерфейса не могут иметься переменные-члены";
  auto АргументСмесиДБТекстом = "аргумент mixin должен принадлежать типу ткст";
  auto DebugSpecModuleLevel = "отладка={} должна быть на уровне модуля";
  auto УровеньВерсииСпецМодуля = "версия={} должна быть на уровне модуля";
}
