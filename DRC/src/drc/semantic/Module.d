/// Author: Aziz Köksal, Vitaly Kulich
/// License: GPL3
/// $(Maturity high)
module drc.semantic.Module;

import drc.ast.Node,
       drc.ast.Declarations;
import drc.parser.Parser;
import drc.lexer.Lexer,
       drc.lexer.IdTable;
import drc.semantic.Symbol,
       drc.semantic.Symbols;
import drc.Location;
import drc.Messages;
import drc.Diagnostics;
import drc.SourceText;
import common;

import io.FilePath;
import io.model;

alias ФайлКонст.СимПутьРазд папРазд;

/// Представляет семантический модуль Динрус и файл-исходник.
class Модуль : СимволМасштаба
{
  ИсходныйТекст исходныйТекст; /// Файл-исходник этого модуля.
  ткст пкиМодуля; /// Полное квалифицированное имя (ПКИ) модуля. Напр.: drc.ast.Node
  ткст имяПакета; /// Напр.: drc.ast
  ткст имяМодуля; /// Напр.: Node

  СложнаяДекларация корень; /// Корень дерева разбора.
  ДекларацияИмпорта[] импорты; /// ДекларацииИмпорта, найденные в этом файле.
  ДекларацияМодуля деклМодуля; /// Опциональная ДекларацияМодуля в этом файле.
  Парсер парсер; /// Парсер, используемые для разбора данного файла.

  /// Указывает проходки, которые были выполнены над данным модулем.
  ///
  /// 0 = никаких проходок$(BR)
  /// 1 = семантическая проходка 1$(BR)
  /// 2 = семантическая проходка 2
  бцел семантическийПроходка;
  Модуль[] модули; /// Импортируемые модули.

  Диагностика диаг; /// Собирает сообщения об ошибках.

  this()
  {
    super(СИМ.Модуль, пусто, пусто);
  }

  /// Строит Модуль объект.
  /// Параметры:
  ///   путьКФайлу = путь к файлу с исходным текстом; загружаемый в конструктор.
  ///   диаг = используется для сбора сообщений об ошибках.
  this(ткст путьКФайлу, Диагностика диаг = пусто)
  {
    this();
    this.исходныйТекст = new ИсходныйТекст(путьКФайлу);
    this.диаг = диаг is пусто ? new Диагностика() : диаг;
    this.исходныйТекст.загрузи(диаг);
  }

  /// Возвращает путь к файлу-исходнику.
  ткст путьКФайлу()
  {
    return исходныйТекст.путьКФайлу;
  }

  /// Возвращает расширение файла: "d" или "di".
  ткст расширениеФайла()
  {
    foreach_reverse(i, с; путьКФайлу)
      if (с == '.')
        return путьКФайлу[i+1..$];
    return "";
  }

  /// Устанавливает парсер, используемый для разбора исходного текста.
  проц  установиПарсер(Парсер парсер)
  {
    this.парсер = парсер;
  }

  /// Разбирает модуль.
  /// Выводит:
  ///   Исключение, если отсутствует ДекларацияМодуля и
  ///   имя модуля является неверным или резервированным идентификатором Динрус.
  проц  разбор()
  {
    if (this.парсер is пусто)
      this.парсер = new Парсер(исходныйТекст, диаг);

    this.корень = парсер.старт();
    this.импорты = парсер.импорты;

    // Устанавливает полное квалифицированное имя данного модуля.
    if (this.корень.отпрыски.length)
    { // деклМодуля будет пусто, если первый узел не является ДекларацияМодуля.
      this.деклМодуля = this.корень.отпрыски[0].Является!(ДекларацияМодуля);
      if (this.деклМодуля)
        this.установиПКИ(деклМодуля.дайПКИ()); // Напр.: drc.ast.Node
    }

    if (!this.пкиМодуля.length)
    { // Взять базовое имя файла как имя модуля.
      auto ткт = (new ФПуть(путьКФайлу)).имя(); // Напр.: Node
      if (!Лексер.действитНерезИдентификатор(ткт))
      {
        auto положение = this.перваяСема().дайПоложениеОшибки();
        auto сооб = Формат(сооб.НеверноеИмяМодуля, ткт);
        диаг ~= new ОшибкаЛексера(положение, сооб);
        ткт = ТаблицаИд.генИдМодуля().ткт;
      }
      this.пкиМодуля = this.имяМодуля = ткт;
    }
    assert(this.пкиМодуля.length);

    // Установить имя символа.
    this.имя = ТаблицаИд.сыщи(this.имяМодуля);
  }

  /// Возвращает первую сему исходного текста модуля.
  Сема* перваяСема()
  {
    return парсер.лексер.перваяСема();
  }

  /// Возвращает начало семы декларации модуля
  /// или, если её не существует, первую сему в исходном тексте.
  Сема* дайСемуДеклМодуля()
  {
    return деклМодуля ? деклМодуля.начало : перваяСема();
  }

  /// Возвращает "да", если в файле-исходнике есть ошибки.
  бул естьОшибки()
  {
    return парсер.ошибки.length || парсер.лексер.ошибки.length;
  }

  /// Возвращает список путей импорта.
  /// Напр.: ["drc/ast/Node", "drc/semantic/Модуль"]
  ткст[] дайПутиИмпорта()
  {
    ткст[] результат;
    foreach (import_; импорты)
      результат ~= import_.дайПКНМодуля(папРазд);
    return результат;
  }

  /// Возвращает полное квалифицированное имя (ПКИ) модуля.
  /// Напр.: drc.ast.Node
  ткст дайПКИ()
  {
    return пкиМодуля;
  }

  /// Устанавливает ПКИ модуля.
  проц  установиПКИ(ткст пкиМодуля)
  {
    бцел i = пкиМодуля.length;
    if (i != 0) // Если у ткст нулевая длина, уменьшение не происходит.
      i--;
    // Найти последнюю точку.
    for (; i != 0 && пкиМодуля[i] != '.'; i--)
    {}
    this.пкиМодуля = пкиМодуля;
    if (i == 0)
      this.имяМодуля = пкиМодуля; // Точки не найдено.
    else
    {
      this.имяПакета = пкиМодуля[0..i];
      this.имяМодуля = пкиМодуля[i+1..$];
    }
  }

  /// Возвращает ПКИ модуля со слешами вместо точек.
  /// Напр.: drc/ast/Node
  ткст дайПутьПКИ()
  {
    ткст ПутьПКИ = пкиМодуля.dup;
    foreach (i, с; ПутьПКИ)
      if (с == '.')
        ПутьПКИ[i] = папРазд;
    return ПутьПКИ;
  }
}
