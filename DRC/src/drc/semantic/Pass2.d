/// Author: Aziz Köksal
/// License: GPL3
/// $(Maturity low)
module drc.semantic.Pass2;

import drc.ast.DefaultVisitor,
       drc.ast.Node,
       drc.ast.Declarations,
       drc.ast.Expressions,
       drc.ast.Statements,
       drc.ast.Types,
       drc.ast.Parameters;
import drc.lexer.Identifier;
import drc.semantic.Symbol,
       drc.semantic.Symbols,
       drc.semantic.Types,
       drc.semantic.Scope,
       drc.semantic.Module,
       drc.semantic.Analysis;
import drc.code.Interpreter;
import drc.parser.Parser;
import drc.SourceText;
import drc.Diagnostics;
import drc.Messages;
import drc.Enums;
import drc.CompilerInfo;
import common;

/// The second pass determines the types of символы and the types
/// of expressions and also evaluates them.
class СемантическаяПроходка2 : ДефолтныйВизитёр
{
  Масштаб масш; /// The current Масштаб.
  Модуль модуль; /// The module в be semantically checked.

  /// Constructs a СемантическаяПроходка2 object.
  /// Параметры:
  ///   модуль = the module в be checked.
  this(Модуль модуль)
  {
    this.модуль = модуль;
  }

  /// Start semantic analysis.
  проц  пуск()
  {
    assert(модуль.корень !is null);
    // Create module Масштаб.
    масш = new Масштаб(null, модуль);
    модуль.семантическийПроходка = 2;
    посети(модуль.корень);
  }

  /// Enters a new Масштаб.
  проц  войдиВМасштаб(СимволМасштаба s)
  {
    масш = масш.войдиВ(s);
  }

  /// Exits the current Масштаб.
  проц  выйдиИзМасштаба()
  {
    масш = масш.выход();
  }

  /// Evaluates в and returns the результат.
  Выражение интерпретируй(Выражение в)
  {
    return Интерпретатор.интерпретируй(в, модуль.диаг);
  }

  /// Creates an ошибка report.
  проц  ошибка(Сема* сема, сим[] форматирСооб, ...)
  {
    auto положение = сема.дайПоложениеОшибки();
    auto сооб = Формат(_arguments, _argptr, форматирСооб);
    модуль.диаг ~= new ОшибкаСемантики(положение, сооб);
  }

  /// Some handy aliases.
  private alias Декларация D;
  private alias Выражение E; /// определено
  private alias Инструкция S; /// определено
  private alias УзелТипа T; /// определено

  /// The current Масштаб символ в use for looking up identifiers.
  /// E.g.:
  /// ---
  /// object.method(); // *) object is looked up in the current Масштаб.
  ///                  // *) идМасштаб is установи if object is a СимволМасштаба.
  ///                  // *) method will be looked up in идМасштаб.
  /// drc.ast.Node.Узел узел; // A fully qualified тип.
  /// ---
  СимволМасштаба идМасштаб;

  /// Searches for a символ.
  Символ ищи(Сема* идСем)
  {
    assert(идСем.вид == TOK.Идентификатор);
    auto ид = идСем.идент;
    Символ символ;

    if (идМасштаб is null)
      символ = масш.ищи(ид);
    else
      символ = идМасштаб.сыщи(ид);

    if (символ is null)
      ошибка(идСем, сооб.НеопределенныйИдентификатор, ид.ткт);
    else if (auto масшСимвол = cast(СимволМасштаба)символ)
      идМасштаб = масшСимвол;

    return символ;
  }

override
{
  D посети(СложнаяДекларация d)
  {
    return super.посети(d);
  }

  D посети(ДекларацияПеречня d)
  {
    d.символ.устОбрабатывается();

    Тип тип = Типы.Цел; // Дефолт в цел.
    if (d.типОснова)
      тип = посетиТ(d.типОснова).тип;
    // Set the enum's base тип.
    d.символ.тип.типОснова = тип;

    // TODO: check base тип. must be basic тип or another enum.

    войдиВМасштаб(d.символ);

    foreach (член; d.члены)
    {
      Выражение финальнЗначение;
      член.символ.устОбрабатывается();
      if (член.значение)
      {
        член.значение = посетиВ(член.значение);
        финальнЗначение = интерпретируй(член.значение);
        if (финальнЗначение is Интерпретатор.НЕИ)
          финальнЗначение = new ЦелВыражение(0, d.символ.тип);
      }
      //else
        // TODO: инкремент a число переменная and assign that в значение.
      член.символ.значение = финальнЗначение;
      член.символ.устОбработан();
    }

    выйдиИзМасштаба();
    d.символ.устОбработан();
    return d;
  }

  D посети(ДекларацияСмеси md)
  {
    if (md.деклы)
      return md.деклы;
    if (md.выражениеСмеси_ли)
    {
      md.аргумент = посетиВ(md.аргумент);
      auto выр = интерпретируй(md.аргумент);
      if (выр is Интерпретатор.НЕИ)
        return md;
      auto ткстВыр = выр.Является!(ТекстовоеВыражение);
      if (ткстВыр is null)
      {
        ошибка(md.начало, сооб.АргументСмесиДБТекстом);
        return md;
      }
      else
      { // Parse the declarations in the ткст.
        auto место = md.начало.дайПоложениеОшибки();
        auto путьКФайлу = место.путьКФайлу;
        auto исходныйТекст = new ИсходныйТекст(путьКФайлу, ткстВыр.дайТекст());
        auto парсер = new Парсер(исходныйТекст, модуль.диаг);
        md.деклы = парсер.старт();
      }
    }
    else
    {
      // TODO: implement template mixin.
    }
    return md.деклы;
  }

  // Тип nodes:

  T посети(ТипТипа t)
  {
    t.в = посетиВ(t.в);
    t.тип = t.в.тип;
    return t;
  }

  T посети(ТипМассив t)
  {
    auto типОснова = посетиТ(t.следщ).тип;
    if (t.ассоциативный_ли)
      t.тип = типОснова.массивИз(посетиТ(t.ассоцТип).тип);
    else if (t.динамический_ли)
      t.тип = типОснова.массивИз();
    else if (t.статический_ли)
    {}
    else
      assert(t.срез_ли);
    return t;
  }

  T посети(ТипУказатель t)
  {
    t.тип = посетиТ(t.следщ).тип.укНа();
    return t;
  }

  T посети(КвалифицированныйТип t)
  {
    if (t.лв.Является!(КвалифицированныйТип) is null)
      идМасштаб = null; // Reset at левый-most тип.
    посетиТ(t.лв);
    посетиТ(t.пв);
    t.тип = t.пв.тип;
    return t;
  }

  T посети(ТипИдентификатор t)
  {
    auto идСема = t.начало;
    auto символ = ищи(идСема);
    // TODO: save символ or its тип in t.
    return t;
  }

  T посети(ТипЭкземплярШаблона t)
  {
    auto идСема = t.начало;
    auto символ = ищи(идСема);
    // TODO: save символ or its тип in t.
    return t;
  }

  T посети(ТипМасштабаМодуля t)
  {
    идМасштаб = модуль;
    return t;
  }

  T посети(ИнтегральныйТип t)
  {
    // A таблица mapping the вид of a сема в its corresponding semantic Тип.
    ТипБазовый[TOK] семВТип = [
      TOK.Сим : Типы.Сим,   TOK.Шим : Типы.Шим,   TOK.Дим : Типы.Дим, TOK.Бул : Типы.Бул,
      TOK.Байт : Типы.Байт,   TOK.Ббайт : Типы.Ббайт,   TOK.Крат : Типы.Крат, TOK.Бкрат : Типы.Бкрат,
      TOK.Цел : Типы.Цел,    TOK.Бцел : Типы.Бцел,    TOK.Дол : Типы.Дол,  TOK.Бдол : Типы.Бдол,
      TOK.Цент : Типы.Цент,   TOK.Бцент : Типы.Бцент,
      TOK.Плав : Типы.Плав,  TOK.Дво : Типы.Дво,  TOK.Реал : Типы.Реал,
      TOK.Вплав : Типы.Вплав, TOK.Вдво : Типы.Вдво, TOK.Вреал : Типы.Вреал,
      TOK.Кплав : Типы.Кплав, TOK.Кдво : Типы.Кдво, TOK.Креал : Типы.Креал, TOK.Проц : Типы.Проц
    ];
    assert(t.лекс in семВТип);
    t.тип = семВТип[t.лекс];
    return t;
  }

  // Выражение nodes:

  E посети(ВыражениеРодит в)
  {
    if (!в.тип)
    {
      в.следщ = посетиВ(в.следщ);
      в.тип = в.следщ.тип;
    }
    return в;
  }

  E посети(ВыражениеЗапятая в)
  {
    if (!в.тип)
    {
      в.лв = посетиВ(в.лв);
      в.пв = посетиВ(в.пв);
      в.тип = в.пв.тип;
    }
    return в;
  }

  E посети(ВыражениеИлиИли)
  { return null; }

  E посети(ВыражениеИИ)
  { return null; }

  E посети(ВыражениеСпецСема в)
  {
    if (в.тип)
      return в.значение;
    switch (в.особаяСема.вид)
    {
    case TOK.СТРОКА, TOK.ВЕРСИЯ:
      в.значение = new ЦелВыражение(в.особаяСема.бцел_, Типы.Бцел);
      break;
    case TOK.ФАЙЛ, TOK.ДАТА, TOK.ВРЕМЯ, TOK.ШТАМПВРЕМЕНИ, TOK.ПОСТАВЩИК:
      в.значение = new ТекстовоеВыражение(в.особаяСема.ткт);
      break;
    default:
      assert(0);
    }
    в.тип = в.значение.тип;
    return в.значение;
  }

  E посети(ВыражениеДоллар в)
  {
    if (в.тип)
      return в;
    в.тип = Типы.Т_мера;
    // if (!inArraySubscript)
    //   ошибка("$ can only be in an массив subscript.");
    return в;
  }

  E посети(ВыражениеНуль в)
  {
    if (!в.тип)
      в.тип = Типы.Проц_ук;
    return в;
  }

  E посети(БулевоВыражение в)
  {
    if (в.тип)
      return в;
    в.значение = new ЦелВыражение(в.вБул(), Типы.Бул);
    в.тип = Типы.Бул;
    return в;
  }

  E посети(ЦелВыражение в)
  {
    if (в.тип)
      return в;

    if (в.число & 0x8000_0000_0000_0000)
      в.тип = Типы.Бдол; // 0xFFFF_FFFF_FFFF_FFFF
    else if (в.число & 0xFFFF_FFFF_0000_0000)
      в.тип = Типы.Дол; // 0x7FFF_FFFF_FFFF_FFFF
    else if (в.число & 0x8000_0000)
      в.тип = Типы.Бцел; // 0xFFFF_FFFF
    else
      в.тип = Типы.Цел; // 0x7FFF_FFFF
    return в;
  }

  E посети(ВыражениеРеал в)
  {
    if (!в.тип)
      в.тип = Типы.Дво;
    return в;
  }

  E посети(ВыражениеКомплекс в)
  {
    if (!в.тип)
      в.тип = Типы.Кдво;
    return в;
  }

  E посети(ВыражениеСим в)
  {
    return в;
  }

  E посети(ТекстовоеВыражение в)
  {
    return в;
  }

  E посети(ВыражениеСмесь me)
  {
    if (me.тип)
      return me.выр;
    me.выр = посетиВ(me.выр);
    auto выр = интерпретируй(me.выр);
    if (выр is Интерпретатор.НЕИ)
      return me;
    auto ткстВыр = выр.Является!(ТекстовоеВыражение);
    if (ткстВыр is null)
     ошибка(me.начало, сооб.АргументСмесиДБТекстом);
    else
    {
      auto место = me.начало.дайПоложениеОшибки();
      auto путьКФайлу = место.путьКФайлу;
      auto исходныйТекст = new ИсходныйТекст(путьКФайлу, ткстВыр.дайТекст());
      auto парсер = new Парсер(исходныйТекст, модуль.диаг);
      выр = парсер.старт2();
      выр = посетиВ(выр); // Check expression.
    }
    me.выр = выр;
    me.тип = выр.тип;
    return me.выр;
  }

  E посети(ВыражениеИмпорта ie)
  {
    if (ie.тип)
      return ie.выр;
    ie.выр = посетиВ(ie.выр);
    auto выр = интерпретируй(ie.выр);
    if (выр is Интерпретатор.НЕИ)
      return ie;
    auto ткстВыр = выр.Является!(ТекстовоеВыражение);
    //if (ткстВыр is null)
    //  ошибка(me.начало, сооб.ImportArgumentMustBeString);
    // TODO: загрузи file
    //ie.выр = new ТекстовоеВыражение(loadImportFile(ткстВыр.дайТекст()));
    return ie.выр;
  }
}
}
