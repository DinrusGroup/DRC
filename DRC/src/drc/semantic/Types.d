/// Author: Aziz Köksal, Vitaly Kulich
/// License: GPL3
/// $(Maturity average)
module drc.semantic.Types;

import drc.semantic.Symbol,
       drc.semantic.TypesEnum;
import drc.lexer.Identifier;
import drc.CompilerInfo;

import common;

/// Базовый тип для всех типовых структур.
abstract class Тип/* : Символ*/
{
  Тип следщ;     /// Следующий тип в структуре типов.
  ТИП тид;       /// ИД типа.
  Символ символ; /// Не пусто, если у типа есть символ.

  this(){}

  /// Строит объект Тип.
  /// Параметры:
  ///   следщ = следщ тип.
  ///   тид = Ид типа
  this(Тип следщ, ТИП тид)
  {
//     this.сид = СИМ.Тип;

    this.следщ = следщ;
    this.тид = тид;
  }

  /// Возвращает "да", если этот тип равен другому.
  бул opEquals(Тип другой)
  {
    // TODO:
    return нет;
  }

  /// Возвращает указатель на тип this.
  ТипУказатель укНа()
  {
    return new ТипУказатель(this);
  }

  /// Возврашает тип динамического массива, используя тип this как его основу.
  ТипДМассив массивИз()
  {
    return new ТипДМассив(this);
  }

  /// Возвращает тип ассоциативного массива, используя тип this как его основу.
  /// Параметры:
  ///   ключ = Тип ключ.
  ТипАМассив массивИз(Тип ключ)
  {
    return new ТипАМассив(this, ключ);
  }

  /// Возвращает байтовый размер для типа this.
  final т_мера размер()
  {
    return МИТаблица.дайРазмер(this);
  }

  /// Размера нет в МИТаблице. Найти через виртуальный метод.
  т_мера размером_()
  {
    return размер();
  }

  /// Возвращает "да", если тип this имеет символ.
  бул естьСимвол()
  {
    return символ !is пусто;
  }

  /// Возвращает тип как ткст.
  abstract ткст вТкст();

  /// Возвращает "да", если тип this есть булев тип.
  бул булев()
  {
    return тид == ТИП.Бул;
  }

  /// Возвращает "да", если тип this есть тип-указатель.
  бул указатель()
  {
    return тид == ТИП.Указатель;
  }

  /// Возвращает "да", если тип this есть целочисленный тип.
  бул интегральный()
  {
    switch (тид)
    {
    case ТИП.Сим, ТИП.Шим, ТИП.Дим, ТИП.Бул, ТИП.Байт, ТИП.Ббайт,
         ТИП.Крат, ТИП.Бкрат, ТИП.Цел, ТИП.Бцел, ТИП.Дол, ТИП.Бдол,
         ТИП.Цент, ТИП.Бцент:
      return да;
    default:
      return нет;
    }
  }

  /// Возвращает "да", если тип this есть дробночисленный тип.
  бул дробный()
  {
    return реальный() || мнимый() || комплексный();
  }

  /// Возвращает "да", если тип this есть реальночисленный тип.
  бул реальный()
  {
    return тид == ТИП.Плав || тид == ТИП.Дво || тид == ТИП.Реал;
  }

  /// Возвращает "да", если тип this есть мнимочисленный тип.
  бул мнимый()
  {
    return тид == ТИП.Вплав || тид == ТИП.Вдво || тид == ТИП.Вреал;
  }

  /// Возвращает "да", если тип this есть комплексночисленный тип.
  бул комплексный()
  {
    return тид == ТИП.Кплав || тид == ТИП.Кдво || тид == ТИП.Креал;
  }
}

/// Все базовые типы. Напр.: цел, сим, реал и т.д.
class ТипБаза : Тип
{
  this(ТИП тип)
  {
    super(пусто, тип);
  }

  ткст вТкст()
  {
    return [
      ТИП.Сим : "сим"[], ТИП.Шим : "шим", ТИП.Дим : "дим",
      ТИП.Бул : "бул", ТИП.Байт : "байт", ТИП.Ббайт : "ббайт",
      ТИП.Крат : "крат", ТИП.Бкрат : "бкрат", ТИП.Цел : "цел",
      ТИП.Бцел : "бцел", ТИП.Дол : "дол", ТИП.Бдол : "бдол",
      ТИП.Цент : "цент", ТИП.Бцент : "бцент", ТИП.Плав : "плав",
      ТИП.Дво : "дво", ТИП.Реал : "реал", ТИП.Вплав : "вплав",
      ТИП.Вдво : "вдво", ТИП.Вреал : "вреал", ТИП.Кплав : "кплав",
      ТИП.Кдво : "кдво", ТИП.Креал : "креал"
    ][this.тид];
  }
}

/// Тип динамический массив.
class ТипДМассив : Тип
{
  this(Тип следщ)
  {
    super(следщ, ТИП.ДМассив);
  }

  ткст вТкст()
  {
    return следщ.вТкст() ~ "[]";
  }
}

/// Тип ассоциативный массив.
class ТипАМассив : Тип
{
  Тип клТип;
  this(Тип следщ, Тип клТип)
  {
    super(следщ, ТИП.АМассив);
    this.клТип = клТип;
  }

  ткст вТкст()
  {
    return следщ.вТкст() ~ "[" ~ клТип.вТкст() ~ "]";
  }
}

/// Тип статический массив.
class ТипСМассив : Тип
{
  т_мера размер;
  this(Тип следщ, т_мера размер)
  {
    super(следщ, ТИП.СМассив);
    this.размер = размер;
  }

  ткст вТкст()
  {
    return Формат("%s[%d]", следщ.вТкст(), размер);
  }
}

/// Тип Указатель.
class ТипУказатель : Тип
{
  this(Тип следщ)
  {
    super(следщ, ТИП.Указатель);
  }

  ткст вТкст()
  {
    return следщ.вТкст() ~ "*";
  }
}

/// Тип Ссылка.
class ТипСсылка : Тип
{
  this(Тип следщ)
  {
    super(следщ, ТИП.Ссылка);
  }

  ткст вТкст()
  { // FIXME: возможная ошибка.
    return следщ.вТкст() ~ "&";
  }
}

/// Тип Перечень.
class ТипПеречень : Тип
{
  this(Символ символ)
  {
    super(типОснова, ТИП.Перечень);
    this.символ = символ;
  }

  /// Установщик базового типа.
  проц  типОснова(Тип тип)
  {
    следщ = тип;
  }

  /// Получатель базового типа.
  Тип типОснова()
  {
    return следщ;
  }

  ткст вТкст()
  {
    return символ.имя.ткт;
  }
}

/// Тип Структура.
class ТипСтруктура : Тип
{
  this(Символ символ)
  {
    super(пусто, ТИП.Структура);
    this.символ = символ;
  }

  ткст вТкст()
  {
    return символ.имя.ткт;
  }
}

/// Тип Класс.
class ТипКласс : Тип
{
  this(Символ символ)
  {
    super(пусто, ТИП.Класс);
    this.символ = символ;
  }

  ткст вТкст()
  {
    return символ.имя.ткт;
  }
}

/// Тип определение типа.
class ТипТипдеф : Тип
{
  this(Тип следщ)
  {
    super(следщ, ТИП.Типдеф);
  }

  ткст вТкст()
  { // TODO:
    return "типдеф";
  }
}

/// Тип Функция.
class ТипФункция : Тип
{
  this(Тип следщ)
  {
    super(следщ, ТИП.Функция);
  }

  ткст вТкст()
  { // TODO:
    return "функция";
  }
}

/// Тип Делегат.
class ТипДелегат : Тип
{
  this(Тип следщ)
  {
    super(следщ, ТИП.Делегат);
  }

  ткст вТкст()
  { // TODO:
    return "делегат";
  }
}

/// Тип Идентификатор.
class ТипИдентификатор : Тип
{
  Идентификатор* идент;
  this(Идентификатор* идент)
  {
    super(пусто, ТИП.Идентификатор);
  }

  ткст вТкст()
  {
    return идент.ткт;
  }
}

/// Тип Экземпляр Шаблона.
class ТипЭкземплярШаблона : Тип
{
  this()
  {
    super(пусто, ТИП.ШЭкземпляр);
  }

  ткст вТкст()
  { // TODO:
    return "шаблон!()";
  }
}

/// Тип Шаблон Кортежа.
class ТипКортеж : Тип
{
  this(Тип следщ)
  {
    super(следщ, ТИП.Кортеж);
  }

  ткст вТкст()
  { // TODO:
    return "кортеж";
  }
}

/// Тип константа. D2.0
class ТипКонстанта : Тип
{
  this(Тип следщ)
  {
    super(следщ, ТИП.Конст);
  }

  ткст вТкст()
  {
    return "константа(" ~ следщ.вТкст() ~ ")";
  }
}

/// Тип Инвариант. D2.0
class ТипИнвариант : Тип
{
  this(Тип следщ)
  {
    super(следщ, ТИП.Конст);
  }

  ткст вТкст()
  {
    return "инвариант(" ~ следщ.вТкст() ~ ")";
  }
}

/// Представляет значение, связанное с Типом.
union Значение
{
  ук  упроц;
  бул   бул_;
  дим  дим_;
  дол   дол_;
  бдол  бдол_;
  цел    цел_;
  бцел   бцел_;
  плав  плав_;
  дво дво_;
  реал   реал_;
  креал  креал_;
}

/// Информация, связанная с Типом.
struct МетаИнфоТип
{
  сим декор; /// Декорирующий символ этого типа.
  бкрат размер; /// Байтовый размер этого типа.
  Значение* дефолтИниц; /// Дефолтное значение инициализации.
}

/// Пространство имён для мета инфо таблицы.
struct МИТаблица
{
static:
  const бкрат РАЗМЕР_НЕ_ДОСТУПЕН = 0; ///Размер недоступен.
  const Значение ЗНОЛЬ = {цел_:0}; /// Значение 0.
  const Значение ЗНУЛЬ = {упроц:пусто}; /// Значение пусто.
  const Значение V0xFF = {дим_:0xFF}; /// Значение 0xFF.
  const Значение V0xFFFF = {дим_:0xFFFF}; /// Значение 0xFFFF.
  const Значение ЗЛОЖЬ = {бул_:нет}; /// Значение нет.
  const Значение ЗНЕЧ = {плав_:плав.nan}; /// Значение NAN (НЧ -НеЧисло).
  const Значение ЗКНЕЧ = {креал_:креал.nan}; /// Значение комплексное НЧ.
  private alias РАЗМЕР_НЕ_ДОСТУПЕН РНД;
  private alias РАЗМЕР_УК РА;
  /// Мета инфо таблица.
  private const МетаИнфоТип метаИнфоТаблица[] = [
    {'?', РНД}, // Ошибка

    {'a', 1, &V0xFF},   // Сим
    {'u', 2, &V0xFFFF},   // Шим
    {'w', 4, &V0xFFFF},   // Дим
    {'b', 1, &ЗЛОЖЬ},   // Бул
    {'g', 1, &ЗНОЛЬ},   // Байт
    {'h', 1, &ЗНОЛЬ},   // Ббайт
    {'s', 2, &ЗНОЛЬ},   // Крат
    {'t', 2, &ЗНОЛЬ},   // Бкрат
    {'i', 4, &ЗНОЛЬ},   // Цел
    {'k', 4, &ЗНОЛЬ},   // Бцел
    {'l', 8, &ЗНОЛЬ},   // Дол
    {'m', 8, &ЗНОЛЬ},   // Бдол
    {'?', 16, &ЗНОЛЬ},  // Цент
    {'?', 16, &ЗНОЛЬ},  // Бцент
    {'f', 4, &ЗНЕЧ},   // Плав
    {'d', 8, &ЗНЕЧ},   // Дво
    {'e', 12, &ЗНЕЧ},  // Реал
    {'o', 4, &ЗНЕЧ},   // Вплав
    {'p', 8, &ЗНЕЧ},   // Вдво
    {'j', 12, &ЗНЕЧ},  // Вреал
    {'q', 8, &ЗКНЕЧ},   // Кплав
    {'r', 16, &ЗКНЕЧ},  // Кдво
    {'c', 24, &ЗКНЕЧ},  // Креал
    {'v', 1},   // проц 

    {'n', РНД},  // Нет

    {'A', РА*2, &ЗНУЛЬ}, // Динамический массив
    {'G', РА*2, &ЗНУЛЬ}, // Статический массив
    {'H', РА*2, &ЗНУЛЬ}, // Ассоциативный массив

    {'E', РНД}, // Перечень
    {'S', РНД}, // Структура
    {'C', РА, &ЗНУЛЬ},  // Класс
    {'T', РНД}, // Типдеф
    {'F', РА},  // Функция
    {'D', РА*2, &ЗНУЛЬ}, // Делегат
    {'P', РА, &ЗНУЛЬ},  // Указатель
    {'R', РА, &ЗНУЛЬ},  // Ссылка
    {'I', РНД}, // Идентификатор
    {'?', РНД}, // Экземпляр шаблона
    {'B', РНД}, // Кортеж
    {'x', РНД}, // Конст, D2
    {'y', РНД}, // Инвариант, D2
  ];
  static assert(метаИнфоТаблица.length == ТИП.max+1);

  /// Возвращает размер типа.
  т_мера дайРазмер(Тип тип)
  {
    auto размер = метаИнфоТаблица[тип.тид].размер;
    if (размер == РАЗМЕР_НЕ_ДОСТУПЕН)
      return тип.размером_();
    return размер;
  }
}

/// Пространство имён для набора предопределенных типов.
struct Типы
{
static:
  /// Базовые предопределенные типы.
  ТипБаза Сим,   Шим,   Дим, Бул,
            Байт,   Ббайт,   Крат, Бкрат,
            Цел,    Бцел,    Дол,  Бдол,
            Цент,   Бцент,
            Плав,  Дво,  Реал,
            Вплав, Вдво, Вреал,
            Кплав, Кдво, Креал, Проц;

  ТипБаза Т_мера; /// Размерный тип.
  ТипБаза Т_дельтаук; /// Тип разницы указателя.
  ТипУказатель Проц_ук; /// Тип указателя на проц.
  ТипБаза Ошибка; /// Тип ошибка.
  ТипБаза Неопределённый; ///Неопределённый тип.
  ТипБаза ПокаНеИзвестен; /// Символ неопределён, но может быть выяснен.

  /// Размещает экземпляр типа ТипБаза и присваивает его к имяТипа.
  template новТБ(ткст имяТипа)
  {
    const новТБ = mixin(имяТипа~" = new ТипБаза(ТИП."~имяТипа~")");
  }

  /// Инициализует предопределенные типы.
  static this()
  {
    новТБ!("Сим");
    новТБ!("Шим");
    новТБ!("Дим");
    новТБ!("Бул");
    новТБ!("Байт");
    новТБ!("Ббайт");
    новТБ!("Крат");
    новТБ!("Бкрат");
    новТБ!("Цел");
    новТБ!("Бцел");
    новТБ!("Дол");
    новТБ!("Бдол");
    новТБ!("Цент");
    новТБ!("Бцент");
    новТБ!("Плав");
    новТБ!("Дво");
    новТБ!("Реал");
    новТБ!("Вплав");
    новТБ!("Вдво");
    новТБ!("Вреал");
    новТБ!("Кплав");
    новТБ!("Кдво");
    новТБ!("Креал");
    новТБ!("Проц");
    version(X86_64)
    {
      Т_мера = Бдол;
      Т_дельтаук = Дол;
    }
    else
    {
      Т_мера = Бцел;
      Т_дельтаук = Цел;
    }
    Проц_ук = Проц.укНа;
    Ошибка = new ТипБаза(ТИП.Ошибка);
    Неопределённый = new ТипБаза(ТИП.Ошибка);
    ПокаНеИзвестен = new ТипБаза(ТИП.Ошибка);
  }
}
