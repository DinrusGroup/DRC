/// Author: Aziz Köksal, Vitaly Kulich
/// License: GPL3
/// $(Maturity low)
/// Описание: Этот модуль присутствует в целях тестирования
/// иного алгоритма проведения семантического анализа,
/// для сравнения с СемантическаяПроходка1 и СемантическаяПроходка2!
module drc.semantic.Passes;

import drc.ast.DefaultVisitor,
       drc.ast.Node,
       drc.ast.Declarations,
       drc.ast.Expressions,
       drc.ast.Statements,
       drc.ast.Types,
       drc.ast.Parameters;
import drc.lexer.IdTable;
import drc.parser.Parser;
import drc.semantic.Symbol,
       drc.semantic.Symbols,
       drc.semantic.Types,
       drc.semantic.Scope,
       drc.semantic.Module,
       drc.semantic.Analysis;
import drc.code.Interpreter;
import drc.Compilation;
import drc.SourceText;
import drc.Diagnostics;
import drc.Messages;
import drc.Enums;
import drc.CompilerInfo;
import common;

/// Some handy aliases.
private alias Декларация Д;
private alias Выражение В; /// определено
private alias Инструкция И; /// определено
private alias УзелТипа Т; /// определено
private alias Параметр П; /// определено
private alias Узел У; /// определено

/// Base class of all другой semantic pass classes.
abstract class СемантическаяПроходка : ДефолтныйВизитёр
{
  Масштаб масш; /// The current Масштаб.
  Модуль модуль; /// The module в be semantically checked.
  КонтекстКомпиляции контекст; /// The compilation контекст.

  /// Строит СемантическаяПроходка объект.
  /// Параметры:
  ///   модуль = the module в be processed.
  ///   контекст = the compilation контекст.
  this(Модуль модуль, КонтекстКомпиляции контекст)
  {
    this.модуль = модуль;
    this.контекст = контекст;
  }

  проц  пуск()
  {

  }

  /// Enters a new Масштаб.
  проц  войдиВМасштаб(СимволМасштаба s)
  {
    масш = масш.войдиВ(s);
  }

  /// Exits the current Масштаб.
  проц  выйдиИзМасштаба()
  {
    масш = масш.выход();
  }

  /// Возвращает да, если является the module Масштаб.
  бул масштабМодуля()
  {
    return масш.символ.Модуль_ли();
  }

  /// Inserts a символ into the current Масштаб.
  проц  вставь(Символ символ)
  {
    вставь(символ, символ.имя);
  }

  /// Inserts a символ into the current Масштаб.
  проц  вставь(Символ символ, Идентификатор* имя)
  {
    auto symX = масш.символ.сыщи(имя);
    if (symX)
      сообщиОКонфликтеСимволов(символ, symX, имя);
    else
      масш.символ.вставь(символ, имя);
    // Установить символ текущего Масштаба как родитель.
    символ.родитель = масш.символ;
  }

  /// Inserts a символ into симМасшт.
  проц  вставь(Символ символ, СимволМасштаба симМасшт)
  {
    auto symX = симМасшт.сыщи(символ.имя);
    if (symX)
      сообщиОКонфликтеСимволов(символ, symX, символ.имя);
    else
      симМасшт.вставь(символ, символ.имя);
    // Установить символ текущего Масштаба как родитель.
    символ.родитель = симМасшт;
  }

  /// Inserts a символ, overloading on the имя, into the current Масштаб.
  проц  вставьПерегрузку(Символ сим)
  {
    auto имя = сим.имя;
    auto сим2 = масш.символ.сыщи(имя);
    if (сим2)
    {
      if (сим2.НаборПерегрузки_ли)
        (cast(НаборПерегрузки)cast(ук)сим2).добавь(сим);
      else
        сообщиОКонфликтеСимволов(сим, сим2, имя);
    }
    else
      // Создать новый набор перегрузки.
      масш.символ.вставь(new НаборПерегрузки(имя, сим.узел), имя);
    // Установить символ текущего Масштаба как родитель.
    сим.родитель = масш.символ;
  }

  /// Отчёт об ошибке: new символ s1 conflicts with existing символ s2.
  проц  сообщиОКонфликтеСимволов(Символ s1, Символ s2, Идентификатор* имя)
  {
    auto место = s2.узел.начало.дайПоложениеОшибки();
    auto локТкст = Формат("{}({},{})", место.путьКФайлу, место.номерСтроки, место.номСтолб);
    ошибка(s1.узел.начало, сооб.ДеклКонфликтуетСДекл, имя.ткт, локТкст);
  }

  /// Ошибка сообщения are repилиted for undefined identifiers if да.
  бул repилиtUndefinedIds;

  /// Incremented when an undefined идентификатор was found.
  бцел undefinedIdsCount;

  /// The символ that must be ignилиed an пропустиped during a символ ищи.
  Символ ignилиeSymbol;

  /// The current Масштаб символ в use for looking up identifiers.
  /// В.g.:
  /// ---
  /// объект.method(); // *) объект is looked up in the current Масштаб.
  ///                  // *) идМасштаб is установи if объект есть СимволМасштаба.
  ///                  // *) method will be looked up in идМасштаб.
  /// drc.ast.Node.Узел узел; // A fully qualified тип.
  /// ---
  СимволМасштаба идМасштаб;

  /// Этот объект is assigned в идМасштаб when a символ сыщи
  /// returned no valid символ.
  static const СимволМасштаба emptyIdScope;
  static this()
  {
    this.emptyIdScope = new СимволМасштаба();
  }

  // Sets a new идМасштаб символ.
  проц  setIdScope(Символ символ)
  {
    if (символ)
      if (auto масшСимвол = cast(СимволМасштаба)символ)
        return идМасштаб = масшСимвол;
    идМасштаб = emptyIdScope;
  }

  /// Searches for a символ.
  Символ ищи(Сема* идСем)
  {
    assert(идСем.вид == TOK.Идентификатор);
    auto ид = идСем.идент;
    Символ символ;

    if (идМасштаб is пусто)
      // Search in the таблица of another символ.
      символ = ignилиeSymbol ?
               масш.ищи(ид, ignилиeSymbol) :
               масш.ищи(ид);
    else
      символ = идМасштаб.сыщи(ид);

    if (символ)
      return символ;

    if (repилиtUndefinedIds)
      ошибка(идСем, сооб.НеопределенныйИдентификатор, ид.ткт);
    undefinedIdsCount++;
    return пусто;
  }

  /// Создаёт отчёт об ошибке.
  проц  ошибка(Сема* сема, ткст форматирСооб, ...)
  {
    if (!модуль.диаг)
      return;
    auto положение = сема.дайПоложениеОшибки();
    auto сооб = Формат(_arguments, _argptr, форматирСооб);
    модуль.диаг ~= new ОшибкаСемантики(положение, сооб);
  }
}

class ПерваяСемантическаяПроходка : СемантическаяПроходка
{
  Модуль delegate(ткст) импортируйМодуль; /// Called when importing a module.

  // Атрибуты:
  ТипКомпоновки типКомпоновки; /// Current linkage тип.
  Защита защита; /// Current защита атрибут.
  КлассХранения классХранения; /// Current stилиage classes.
  бцел размерРаскладки; /// Current align размер.

  /// Строит СемантическаяПроходка объект.
  /// Параметры:
  ///   модуль = the module в be processed.
  ///   контекст = the compilation контекст.
  this(Модуль модуль, КонтекстКомпиляции контекст)
  {
    super(модуль, new КонтекстКомпиляции(контекст));
    this.размерРаскладки = контекст.раскладкаСтруктуры;
  }

  override проц  пуск()
  {
    assert(модуль.корень !is пусто);
    // Create module Масштаб.
    масш = new Масштаб(пусто, модуль);
    модуль.семантическийПроходка = 1;
    посетиУ(модуль.корень);
  }

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                                Declarations                               |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

override
{
  Д посети(СложнаяДекларация d)
  {
    foreach (декл; d.деклы)
      посетиД(декл);
    return d;
  }

  Д посети(НелегальнаяДекларация)
  { assert(0, "семантическая проходка по повреждённому АСД"); return пусто; }

  // Д посети(ПустаяДекларация ed)
  // { return ed; }

  // Д посети(ДекларацияМодуля)
  // { return пусто; }

  Д посети(ДекларацияИмпорта d)
  {
    if (импортируйМодуль is пусто)
      return d;
    foreach (путьПоПКНМодуля; d.дайПКНМодуля(папРазд))
    {
      auto импортированныйМодуль = импортируйМодуль(путьПоПКНМодуля);
      if (импортированныйМодуль is пусто)
        ошибка(d.начало, сооб.МодульНеЗагружен, путьПоПКНМодуля ~ ".d");
      модуль.модули ~= импортированныйМодуль;
    }
    return d;
  }

  Д посети(ДекларацияАлиаса ad)
  {
    return ad;
  }

  Д посети(ДекларацияТипдефа td)
  {
    return td;
  }

  Д посети(ДекларацияПеречня d)
  {
    if (d.символ)
      return d;

    // Создать символ.
    d.символ = new Перечень(d.имя, d);

    бул анонимен = d.символ.анонимен;
    if (анонимен)
      d.символ.имя = ТаблицаИд.генИДАнонПеречня();

    вставь(d.символ);

    auto символРодительскогоМасштаба = масш.символ;
    auto символПеречня = d.символ;
    войдиВМасштаб(d.символ);
    // Declare члены.
    foreach (член; d.члены)
    {
      посетиД(член);

      if (анонимен) // Also вставь в родительский Масштаб if enum is anonymous.
        вставь(член.символ, символРодительскогоМасштаба);

      член.символ.тип = символПеречня.тип; // Присвоить ТипПеречень.
    }
    выйдиИзМасштаба();
    return d;
  }

  Д посети(ДекларацияЧленаПеречня d)
  {
    d.символ = new ЧленПеречня(d.имя, защита, классХранения, типКомпоновки, d);
    вставь(d.символ);
    return d;
  }

  Д посети(ДекларацияКласса d)
  {
    if (d.символ)
      return d;
    // Создать символ.
    d.символ = new Класс(d.имя, d);
    // Вставить в текущий Масштаб.
    вставь(d.символ);
    войдиВМасштаб(d.символ);
    // Продолжаем семанализ.
    d.деклы && посетиД(d.деклы);
    выйдиИзМасштаба();
    return d;
  }

  Д посети(ДекларацияИнтерфейса d)
  {
    if (d.символ)
      return d;
    // Создать символ.
    d.символ = new drc.semantic.Symbols.Интерфейс(d.имя, d);
    // Вставить в текущий Масштаб.
    вставь(d.символ);
    войдиВМасштаб(d.символ);
      // Продолжаем семанализ.
      d.деклы && посетиД(d.деклы);
    выйдиИзМасштаба();
    return d;
  }

  Д посети(ДекларацияСтруктуры d)
  {
    if (d.символ)
      return d;
    // Создать символ.
    d.символ = new Структура(d.имя, d);

    if (d.символ.анонимен)
      d.символ.имя = ТаблицаИд.генАнонСтруктИД();
    // Вставить в текущий Масштаб.
    вставь(d.символ);

    войдиВМасштаб(d.символ);
      // Продолжаем семанализ.
      d.деклы && посетиД(d.деклы);
    выйдиИзМасштаба();

    if (d.символ.анонимен)
      // Вставить члены в родительский Масштаб также.
      foreach (член; d.символ.члены)
        вставь(член);
    return d;
  }

  Д посети(ДекларацияСоюза d)
  {
    if (d.символ)
      return d;
    // Создать символ.
    d.символ = new Союз(d.имя, d);

    if (d.символ.анонимен)
      d.символ.имя = ТаблицаИд.генАнонСоюзИД();

    // Вставить в текущий Масштаб.
    вставь(d.символ);

    войдиВМасштаб(d.символ);
      // Продолжаем семанализ.
      d.деклы && посетиД(d.деклы);
    выйдиИзМасштаба();

    if (d.символ.анонимен)
      // Вставить члены в родительский Масштаб также.
      foreach (член; d.символ.члены)
        вставь(член);
    return d;
  }

  Д посети(ДекларацияКонструктора d)
  {
    auto функц = new Функция(Идент.Ктор, d);
    вставьПерегрузку(функц);
    return d;
  }

  Д посети(ДекларацияСтатическогоКонструктора d)
  {
    auto функц = new Функция(Идент.Ктор, d);
    вставьПерегрузку(функц);
    return d;
  }

  Д посети(ДекларацияДеструктора d)
  {
    auto функц = new Функция(Идент.Дтор, d);
    вставьПерегрузку(функц);
    return d;
  }

  Д посети(ДекларацияСтатическогоДеструктора d)
  {
    auto функц = new Функция(Идент.Дтор, d);
    вставьПерегрузку(функц);
    return d;
  }

  Д посети(ДекларацияФункции d)
  {
    auto функц = new Функция(d.имя, d);
    вставьПерегрузку(функц);
    return d;
  }

  Д посети(ДекларацияПеременных vd)
  {
    // Ошибка if we are in an interface.
    if (масш.символ.Интерфейс_ли && !vd.статический)
      return ошибка(vd.начало, сооб.УИнтерфейсаНеДолжноБытьПеременных), vd;

    // Вставить переменная символы in this declaration into the таблицу символов.
    foreach (i, имя; vd.имена)
    {
      auto переменная = new Переменная(имя, защита, классХранения, типКомпоновки, vd);
      переменная.значение = vd.иниты[i];
      vd.переменные ~= переменная;
      вставь(переменная);
    }
    return vd;
  }

  Д посети(ДекларацияИнварианта d)
  {
    auto функц = new Функция(Идент.Инвариант, d);
    вставь(функц);
    return d;
  }

  Д посети(ДекларацияЮниттеста d)
  {
    auto функц = new Функция(Идент.Юниттест, d);
    вставьПерегрузку(функц);
    return d;
  }

  Д посети(ДекларацияОтладки d)
  {
    if (d.определение)
    { // debug = Ид | Цел
      if (!масштабМодуля())
        ошибка(d.начало, сооб.DebugSpecModuleLevel, d.спец.исхТекст);
      else if (d.спец.вид == TOK.Идентификатор)
        контекст.добавьИдОтладки(d.спец.идент.ткт);
      else
        контекст.уровеньОтладки = d.спец.бцел_;
    }
    else
    { // debug ( Условие )
      if (выборОтладВетви(d.услов, контекст))
        d.компилированныеДеклы = d.деклы;
      else
        d.компилированныеДеклы = d.деклыИначе;
      d.компилированныеДеклы && посетиД(d.компилированныеДеклы);
    }
    return d;
  }

  Д посети(ДекларацияВерсии d)
  {
    if (d.определение)
    { // version = Ид | Цел
      if (!масштабМодуля())
        ошибка(d.начало, сооб.УровеньВерсииСпецМодуля, d.спец.исхТекст);
      else if (d.спец.вид == TOK.Идентификатор)
        контекст.добавьИдВерсии(d.спец.идент.ткт);
      else
        контекст.уровеньВерсии = d.спец.бцел_;
    }
    else
    { // version ( Условие )
      if (выборВерсионВетви(d.услов, контекст))
        d.компилированныеДеклы = d.деклы;
      else
        d.компилированныеДеклы = d.деклыИначе;
      d.компилированныеДеклы && посетиД(d.компилированныеДеклы);
    }
    return d;
  }

  Д посети(ДекларацияШаблона d)
  {
    if (d.символ)
      return d;
    // Создать символ.
    d.символ = new Шаблон(d.имя, d);
    // Вставить в текущий Масштаб.
    вставьПерегрузку(d.символ);
    return d;
  }

  Д посети(ДекларацияНов d)
  {
    auto функц = new Функция(Идент.Нов, d);
    вставь(функц);
    return d;
  }

  Д посети(ДекларацияУдали d)
  {
    auto функц = new Функция(Идент.Удалить, d);
    вставь(функц);
    return d;
  }

  // Атрибуты:

  Д посети(ДекларацияЗащиты d)
  {
    auto сохранённое = защита; // Сохранить.
    защита = d.защ; // Установить.
    посетиД(d.деклы);
    защита = сохранённое; // Восстановить.
    return d;
  }

  Д посети(ДекларацияКлассаХранения d)
  {
    auto сохранённое = классХранения; // Сохранить.
    классХранения = d.классХранения; // Установить.
    посетиД(d.деклы);
    классХранения = сохранённое; // Восстановить.
    return d;
  }

  Д посети(ДекларацияКомпоновки d)
  {
    auto сохранённое = типКомпоновки; // Сохранить.
    типКомпоновки = d.типКомпоновки; // Установить.
    посетиД(d.деклы);
    типКомпоновки = сохранённое; // Восстановить.
    return d;
  }

  Д посети(ДекларацияРазложи d)
  {
    auto сохранённое = размерРаскладки; // Сохранить.
    размерРаскладки = d.размер; // Установить.
    посетиД(d.деклы);
    размерРаскладки = сохранённое; // Восстановить.
    return d;
  }

  Д посети(ДекларацияСтатическогоПодтверди d)
  {
    return d;
  }

  Д посети(ДекларацияСтатическогоЕсли d)
  {
    return d;
  }

  Д посети(ДекларацияСмеси d)
  {
    return d;
  }

  Д посети(ДекларацияПрагмы d)
  {
    if (d.идент is Идент.сооб)
    {
      // TODO
    }
    else
    {
      семантикаПрагмы(масш, d.начало, d.идент, d.арги);
      посетиД(d.деклы);
    }
    return d;
  }
} // override

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                                 Statements                                |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

  /// The current surrounding, breakable statement.
  И breakableStatement;

  И setBS(И s)
  {
    auto old = breakableStatement;
    breakableStatement = s;
    return old;
  }

  проц  restилиeBS(И s)
  {
    breakableStatement = s;
  }

override
{
  И посети(СложнаяИнструкция s)
  {
    foreach (stmnt; s.инстрции)
      посетиИ(stmnt);
    return s;
  }

  И посети(НелегальнаяИнструкция)
  { assert(0, "семантическая проходка по повреждённому АСД"); return пусто; }

  И посети(ПустаяИнструкция s)
  {
    return s;
  }

  И посети(ИнструкцияТелаФункции s)
  {
    return s;
  }

  И посети(ИнструкцияМасштаб s)
  {
//     войдиВМасштаб();
    посетиИ(s.s);
//     выйдиИзМасштаба();
    return s;
  }

  И посети(ИнструкцияСМеткой s)
  {
    return s;
  }

  И посети(ИнструкцияВыражение s)
  {
    return s;
  }

  И посети(ИнструкцияДекларация s)
  {
    return s;
  }

  И посети(ИнструкцияЕсли s)
  {
    return s;
  }

  И посети(ИнструкцияПока s)
  {
    auto сохранённое = setBS(s);
    // TODO:
    restилиeBS(сохранённое);
    return s;
  }

  И посети(ИнструкцияДелайПока s)
  {
    auto сохранённое = setBS(s);
    // TODO:
    restилиeBS(сохранённое);
    return s;
  }

  И посети(ИнструкцияПри s)
  {
    auto сохранённое = setBS(s);
    // TODO:
    restилиeBS(сохранённое);
    return s;
  }

  И посети(ИнструкцияСКаждым s)
  {
    auto сохранённое = setBS(s);
    // TODO:
    // find overload opApply или opApplyReverse.
    restилиeBS(сохранённое);
    return s;
  }

  // D2.0
  И посети(ИнструкцияДиапазонСКаждым s)
  {
    auto сохранённое = setBS(s);
    // TODO:
    restилиeBS(сохранённое);
    return s;
  }

  И посети(ИнструкцияЩит s)
  {
    auto сохранённое = setBS(s);
    // TODO:
    restилиeBS(сохранённое);
    return s;
  }

  И посети(ИнструкцияРеле s)
  {
    auto сохранённое = setBS(s);
    // TODO:
    restилиeBS(сохранённое);
    return s;
  }

  И посети(ИнструкцияДефолт s)
  {
    auto сохранённое = setBS(s);
    // TODO:
    restилиeBS(сохранённое);
    return s;
  }

  И посети(ИнструкцияДалее s)
  {
    return s;
  }

  И посети(ИнструкцияВсё s)
  {
    return s;
  }

  И посети(ИнструкцияИтог s)
  {
    return s;
  }

  И посети(ИнструкцияПереход s)
  {
    return s;
  }

  И посети(ИнструкцияДля s)
  {
    return s;
  }

  И посети(ИнструкцияСинхр s)
  {
    return s;
  }

  И посети(ИнструкцияПробуй s)
  {
    return s;
  }

  И посети(ИнструкцияЛови s)
  {
    return s;
  }

  И посети(ИнструкцияИтожь s)
  {
    return s;
  }

  И посети(ИнструкцияСтражМасштаба s)
  {
    return s;
  }

  И посети(ИнструкцияБрось s)
  {
    return s;
  }

  И посети(ИнструкцияЛетучее s)
  {
    return s;
  }

  И посети(ИнструкцияБлокАсм s)
  {
    foreach (stmnt; s.инструкции.инстрции)
      посетиИ(stmnt);
    return s;
  }

  И посети(ИнструкцияАсм s)
  {
    return s;
  }

  И посети(ИнструкцияАсмРасклад s)
  {
    return s;
  }

  И посети(ИнструкцияНелегальныйАсм)
  { assert(0, "семантическая проходка по повреждённому АСД"); return пусто; }

  И посети(ИнструкцияПрагма s)
  {
    return s;
  }

  И посети(ИнструкцияСмесь s)
  {
    return s;
  }

  И посети(ИнструкцияСтатическоеЕсли s)
  {
    return s;
  }

  И посети(ИнструкцияСтатическоеПодтверди s)
  {
    return s;
  }

  И посети(ИнструкцияОтладка s)
  {
    return s;
  }

  И посети(ИнструкцияВерсия s)
  {
    return s;
  }
} // override

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                                Expressions                                |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

  /// Determines whether в issue an ошибка when a символ couldn'т be found.
  бул errилиOnUndefinedSymbol;
  //бул errилиOnUnknownSymbol;

  /// Отчёт об ошибке if 'e' is типа бул.
  проц  errилиЕслиBool(Выражение в)
  {
    ошибка(в.начало, "такая операция для типа бул не определена");
  }

  /// Returns a call выражение if 'e' overrides
  /// an операторwith the имя 'ид'.
  /// Параметры:
  ///   в = the binary выражение в be checked.
  ///   ид = the имя of the overload function.
  Выражение найдиПерегрузку(УнарноеВыражение в, Идентификатор* ид)
  {
    // TODO:
    // check в for struct или class
    // ищи for function Имяd ид
    // return call выражение: в.opXYZ()
    return пусто;
  }

  /// Returns a call выражение if 'e' overrides
  /// an оператор with the имя 'ид' или 'id_r'.
  /// Параметры:
  ///   в = the binary выражение в be checked.
  ///   ид = the имя of the overload function.
  ///   id_r = the имя of the reverse overload function.
  Выражение найдиПерегрузку(БинарноеВыражение в, Идентификатор* ид, Идентификатор* id_r)
  {
    // TODO:
    return пусто;
  }

override
{
  В посети(НелегальноеВыражение)
  { assert(0, "семантическая проходка по повреждённому АСД"); return пусто; }

  В посети(ВыражениеУсловия в)
  {
    return в;
  }

  В посети(ВыражениеЗапятая в)
  {
    if (!в.естьТип)
    {
      в.лв = посетиВ(в.лв);
      в.пв = посетиВ(в.пв);
      в.тип = в.пв.тип;
    }
    return в;
  }

  В посети(ВыражениеИлиИли в)
  {
    return в;
  }

  В посети(ВыражениеИИ в)
  {
    return в;
  }

  В посети(ВыражениеИли в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opOr, Идент.opOr_r))
      return o;
    return в;
  }

  В посети(ВыражениеИИли в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opXили, Идент.opXили_r))
      return o;
    return в;
  }

  В посети(ВыражениеИ в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opAnd, Идент.opAnd_r))
      return o;
    return в;
  }

  В посети(ВыражениеРавно в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opEquals, пусто))
      return o;
    return в;
  }

  В посети(ВыражениеРавенство в)
  {
    return в;
  }

  В посети(ВыражениеОтнош в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opCmp, пусто))
      return o;
    return в;
  }

  В посети(ВыражениеВхо в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opIn, Идент.opIn_r))
      return o;
    return в;
  }

  В посети(ВыражениеЛСдвиг в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opShl, Идент.opShl_r))
      return o;
    return в;
  }

  В посети(ВыражениеПСдвиг в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opShr, Идент.opShr_r))
      return o;
    return в;
  }

  В посети(ВыражениеБПСдвиг в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opUShr, Идент.opUShr_r))
      return o;
    return в;
  }

  В посети(ВыражениеПлюс в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opAdd, Идент.opAdd_r))
      return o;
    return в;
  }

  В посети(ВыражениеМинус в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opSub, Идент.opSub_r))
      return o;
    return в;
  }

  В посети(ВыражениеСоедини в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opCat, Идент.opCat_r))
      return o;
    return в;
  }

  В посети(ВыражениеУмножь в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opMul, Идент.opMul_r))
      return o;
    return в;
  }

  В посети(ВыражениеДели в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opDiv, Идент.opDiv_r))
      return o;
    return в;
  }

  В посети(ВыражениеМод в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opMod, Идент.opMod_r))
      return o;
    return в;
  }

  В посети(ВыражениеПрисвой в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opAssign, пусто))
      return o;
    // TODO: also check for opIndexAssign and opSliceAssign.
    return в;
  }

  В посети(ВыражениеПрисвойЛСдвиг в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opShlAssign, пусто))
      return o;
    return в;
  }

  В посети(ВыражениеПрисвойПСдвиг в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opShrAssign, пусто))
      return o;
    return в;
  }

  В посети(ВыражениеПрисвойБПСдвиг в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opUShrAssign, пусто))
      return o;
    return в;
  }

  В посети(ВыражениеПрисвойИли в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opOrAssign, пусто))
      return o;
    return в;
  }

  В посети(ВыражениеПрисвойИ в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opAndAssign, пусто))
      return o;
    return в;
  }

  В посети(ВыражениеПрисвойПлюс в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opAddAssign, пусто))
      return o;
    return в;
  }

  В посети(ВыражениеПрисвойМинус в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opSubAssign, пусто))
      return o;
    return в;
  }

  В посети(ВыражениеПрисвойДел в)
  {
    auto o = найдиПерегрузку(в, Идент.opDivAssign, пусто);
    if (o)
      return o;
    return в;
  }

  В посети(ВыражениеПрисвойУмн в)
  {
    auto o = найдиПерегрузку(в, Идент.opMulAssign, пусто);
    if (o)
      return o;
    return в;
  }

  В посети(ВыражениеПрисвойМод в)
  {
    auto o = найдиПерегрузку(в, Идент.opModAssign, пусто);
    if (o)
      return o;
    return в;
  }

  В посети(ВыражениеПрисвойИИли в)
  {
    auto o = найдиПерегрузку(в, Идент.opXилиAssign, пусто);
    if (o)
      return o;
    return в;
  }

  В посети(ВыражениеПрисвойСоед в)
  {
    auto o = найдиПерегрузку(в, Идент.opCatAssign, пусто);
    if (o)
      return o;
    return в;
  }

  В посети(ВыражениеАдрес в)
  {
    if (в.естьТип)
      return в;
    в.в = посетиВ(в.в);
    в.тип = в.в.тип.укНа();
    return в;
  }

  В посети(ВыражениеПреИнкр в)
  {
    if (в.естьТип)
      return в;
    // TODO: rewrite в в+=1
    в.в = посетиВ(в.в);
    в.тип = в.в.тип;
    errилиЕслиBool(в.в);
    return в;
  }

  В посети(ВыражениеПреДекр в)
  {
    if (в.естьТип)
      return в;
    // TODO: rewrite в в-=1
    в.в = посетиВ(в.в);
    в.тип = в.в.тип;
    errилиЕслиBool(в.в);
    return в;
  }

  В посети(ВыражениеПостИнкр в)
  {
    if (в.естьТип)
      return в;
    if (auto o = найдиПерегрузку(в, Идент.opPostInc))
      return o;
    в.в = посетиВ(в.в);
    в.тип = в.в.тип;
    errилиЕслиBool(в.в);
    return в;
  }

  В посети(ВыражениеПостДекр в)
  {
    if (в.естьТип)
      return в;
    if (auto o = найдиПерегрузку(в, Идент.opPostDec))
      return o;
    в.в = посетиВ(в.в);
    в.тип = в.в.тип;
    errилиЕслиBool(в.в);
    return в;
  }

  В посети(ВыражениеДереф в)
  {
    if (в.естьТип)
      return в;
  version(D2)
    if (auto o = найдиПерегрузку(в, Идент.opStar))
      return o;
    в.в = посетиВ(в.в);
    в.тип = в.в.тип.следщ;
    if (!в.в.тип.указатель)
    {
      ошибка(в.в.начало,
        "dereference оператор '*x' не определён для выражения типа '{}'",
        в.в.тип.вТкст());
      в.тип = Типы.Ошибка;
    }
    // TODO:
    // if (в.в.тип.isVoid)
    //   ошибка();
    return в;
  }

  В посети(ВыражениеЗнак в)
  {
    if (в.естьТип)
      return в;
    if (auto o = найдиПерегрузку(в, в.отриц ? Идент.opNeg : Идент.opPos))
      return o;
    в.в = посетиВ(в.в);
    в.тип = в.в.тип;
    errилиЕслиBool(в.в);
    return в;
  }

  В посети(ВыражениеНе в)
  {
    if (в.естьТип)
      return в;
    в.в = посетиВ(в.в);
    в.тип = Типы.Бул;
    // TODO: в.в must be convertible в бул.
    return в;
  }

  В посети(ВыражениеКомп в)
  {
    if (в.естьТип)
      return в;
    if (auto o = найдиПерегрузку(в, Идент.opCom))
      return o;
    в.в = посетиВ(в.в);
    в.тип = в.в.тип;
    if (в.тип.дробный || в.тип.булев)
    {
      ошибка(в.начало, "ОПЕРАТОР '~x' не определён для типа '{}'",  в.тип.вТкст());
      в.тип = Типы.Ошибка;
    }
    return в;
  }

  В посети(ВыражениеВызов в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opCall))
      return o;
    return в;
  }

  В посети(ВыражениеНов в)
  {
    return в;
  }

  В посети(ВыражениеНовАнонКласс в)
  {
    return в;
  }

  В посети(ВыражениеУдали в)
  {
    return в;
  }

  В посети(ВыражениеКаст в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opCast))
      return o;
    return в;
  }

  В посети(ВыражениеИндекс в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opIndex))
      return o;
    return в;
  }

  В посети(ВыражениеСрез в)
  {
    if (auto o = найдиПерегрузку(в, Идент.opSlice))
      return o;
    return в;
  }

  В посети(ВыражениеТочка в)
  {
    if (в.естьТип)
      return в;
    бул resetIdScope = идМасштаб is пусто;
    // TODO:
    resetIdScope && (идМасштаб = пусто);
    return в;
  }

  В посети(ВыражениеМасштабМодуля в)
  {
    if (в.естьТип)
      return в;
    бул resetIdScope = идМасштаб is пусто;
    идМасштаб = модуль;
    в.в = посетиВ(в.в);
    в.тип = в.в.тип;
    resetIdScope && (идМасштаб = пусто);
    return в;
  }

  В посети(ВыражениеИдентификатор в)
  {
    if (в.естьТип)
      return в;
    debug(sema) выдай.форматнс("", в);
    auto идСема = в.идСема();
    в.символ = ищи(идСема);
    return в;
  }

  В посети(ВыражениеЭкземплярШаблона в)
  {
    if (в.естьТип)
      return в;
    debug(sema) выдай.форматнс("", в);
    auto идСема = в.идСема();
    в.символ = ищи(идСема);
    return в;
  }

  В посети(ВыражениеСпецСема в)
  {
    if (в.естьТип)
      return в.значение;
    switch (в.особаяСема.вид)
    {
    case TOK.СТРОКА, TOK.ВЕРСИЯ:
      в.значение = new ЦелВыражение(в.особаяСема.бцел_, Типы.Бцел);
      break;
    case TOK.ФАЙЛ, TOK.ДАТА, TOK.ВРЕМЯ, TOK.ШТАМПВРЕМЕНИ, TOK.ПОСТАВЩИК:
      в.значение = new ТекстовоеВыражение(в.особаяСема.ткт);
      break;
    default:
      assert(0);
    }
    в.тип = в.значение.тип;
    return в.значение;
  }

  В посети(ВыражениеЭтот в)
  {
    return в;
  }

  В посети(ВыражениеСупер в)
  {
    return в;
  }

  В посети(ВыражениеНуль в)
  {
    if (!в.естьТип)
      в.тип = Типы.Проц_ук;
    return в;
  }

  В посети(ВыражениеДоллар в)
  {
    if (в.естьТип)
      return в;
    в.тип = Типы.Т_мера;
    // if (!inМассивSubscript)
    //   ошибка("$ can only be in an массив subscript.");
    return в;
  }

  В посети(БулевоВыражение в)
  {
    assert(в.естьТип);
    return в.значение;
  }

  В посети(ЦелВыражение в)
  {
    if (в.естьТип)
      return в;

    if (в.число & 0x8000_0000_0000_0000)
      в.тип = Типы.Бдол; // 0xFFFF_FFFF_FFFF_FFFF
    else if (в.число & 0xFFFF_FFFF_0000_0000)
      в.тип = Типы.Дол; // 0x7FFF_FFFF_FFFF_FFFF
    else if (в.число & 0x8000_0000)
      в.тип = Типы.Бцел; // 0xFFFF_FFFF
    else
      в.тип = Типы.Цел; // 0x7FFF_FFFF
    return в;
  }

  В посети(ВыражениеРеал в)
  {
    if (!в.естьТип)
      в.тип = Типы.Дво;
    return в;
  }

  В посети(ВыражениеКомплекс в)
  {
    if (!в.естьТип)
      в.тип = Типы.Кдво;
    return в;
  }

  В посети(ВыражениеСим в)
  {
    assert(в.естьТип);
    return в.значение;
  }

  В посети(ТекстовоеВыражение в)
  {
    assert(в.естьТип);
    return в;
  }

  В посети(ВыражениеЛитералМассива в)
  {
    return в;
  }

  В посети(ВыражениеЛитералАМассива в)
  {
    return в;
  }

  В посети(ВыражениеПодтверди в)
  {
    return в;
  }

  В посети(ВыражениеСмесь в)
  {
    return в;
  }

  В посети(ВыражениеИмпорта в)
  {
    return в;
  }

  В посети(ВыражениеТипа в)
  {
    return в;
  }

  В посети(ВыражениеИдТипаТочка в)
  {
    return в;
  }

  В посети(ВыражениеИдТипа в)
  {
    return в;
  }

  В посети(ВыражениеЯвляется в)
  {
    return в;
  }

  В посети(ВыражениеРодит в)
  {
    if (!в.естьТип)
    {
      в.следщ = посетиВ(в.следщ);
      в.тип = в.следщ.тип;
    }
    return в;
  }

  В посети(ВыражениеЛитералФункции в)
  {
    return в;
  }

  В посети(ВыражениеТрактовки в) // D2.0
  {
    return в;
  }

  В посети(ВыражениеИницПроц в)
  {
    return в;
  }

  В посети(ВыражениеИницМассива в)
  {
    return в;
  }

  В посети(ВыражениеИницСтруктуры в)
  {
    return в;
  }

  В посети(ВыражениеТипАсм в)
  {
    return в;
  }

  В посети(ВыражениеСмещениеАсм в)
  {
    return в;
  }

  В посети(ВыражениеСегАсм в)
  {
    return в;
  }

  В посети(ВыражениеАсмПослеСкобки в)
  {
    return в;
  }

  В посети(ВыражениеАсмСкобка в)
  {
    return в;
  }

  В посети(ВыражениеЛокальногоРазмераАсм в)
  {
    return в;
  }

  В посети(ВыражениеАсмРегистр в)
  {
    return в;
  }
} // override

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                                   Типы                                   |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

override
{
  Т посети(НелегальныйТип)
  { assert(0, "семантическая проходка по повреждённому АСД"); return пусто; }

  Т посети(ИнтегральныйТип т)
  {
    // A таблица mapping the вид of a сема в its cилиresponding semantic Тип.
    ТипБаза[TOK] семВТип = [
      TOK.Сим : Типы.Сим,   TOK.Шим : Типы.Шим,   TOK.Дим : Типы.Дим, TOK.Бул : Типы.Бул,
      TOK.Байт : Типы.Байт,   TOK.Ббайт : Типы.Ббайт,   TOK.Крат : Типы.Крат, TOK.Бкрат : Типы.Бкрат,
      TOK.Цел : Типы.Цел,    TOK.Бцел : Типы.Бцел,    TOK.Дол : Типы.Дол,  TOK.Бдол : Типы.Бдол,
      TOK.Цент : Типы.Цент,   TOK.Бцент : Типы.Бцент,
      TOK.Плав : Типы.Плав,  TOK.Дво : Типы.Дво,  TOK.Реал : Типы.Реал,
      TOK.Вплав : Типы.Вплав, TOK.Вдво : Типы.Вдво, TOK.Вреал : Типы.Вреал,
      TOK.Кплав : Типы.Кплав, TOK.Кдво : Типы.Кдво, TOK.Креал : Типы.Креал, TOK.Проц : Типы.Проц
    ];
    assert(т.лекс in семВТип);
    т.тип = семВТип[т.лекс];
    return т;
  }

  Т посети(КвалифицированныйТип т)
  {
    // Reset идМасштаб at the конец if this the корень КвалифицированныйТип.
    бул resetIdScope = идМасштаб is пусто;
//     if (т.лв.Является!(КвалифицированныйТип) is пусто)
//       идМасштаб = пусто; // Reset at левый-most тип.
    посетиТ(т.лв);
    // Присвоить the символ of the левый-hand сторона в идМасштаб.
    setIdScope(т.лв.символ);
    посетиТ(т.пв);
//     setIdScope(т.пв.символ);
    // Присвоить члены of the правый-hand сторона в тип this.
    т.тип = т.пв.тип;
    т.символ = т.пв.символ;
    // Reset идМасштаб.
    resetIdScope && (идМасштаб = пусто);
    return т;
  }

  Т посети(ТМасштабМодуля т)
  {
    идМасштаб = модуль;
    return т;
  }

  Т посети(ТИдентификатор т)
  {
    auto идСема = т.начало;
    auto символ = ищи(идСема);
    // TODO: save символ или its тип in т.
    return т;
  }

  Т посети(ТТип т)
  {
    т.в = посетиВ(т.в);
    т.тип = т.в.тип;
    return т;
  }

  Т посети(ТЭкземплярШаблона т)
  {
    auto идСема = т.начало;
    auto символ = ищи(идСема);
    // TODO: save символ или its тип in т.
    return т;
  }

  Т посети(ТУказатель т)
  {
    т.тип = посетиТ(т.следщ).тип.укНа();
    return т;
  }

  Т посети(ТМассив т)
  {
    auto типОснова = посетиТ(т.следщ).тип;
    if (т.ассоциативный)
      т.тип = типОснова.массивИз(посетиТ(т.ассоцТип).тип);
    else if (т.динамический)
      т.тип = типОснова.массивИз();
    else if (т.статический)
    {}
    else
      assert(т.срез);
    return т;
  }

  Т посети(ТФункция т)
  {
    return т;
  }

  Т посети(ТДелегат т)
  {
    return т;
  }

  Т посети(ТУказательНаФункСи т)
  {
    return т;
  }

  Т посети(ТипКлассОснова т)
  {
    return т;
  }

  Т посети(ТКонст т) // D2.0
  {
    return т;
  }

  Т посети(ТИнвариант т) // D2.0
  {
    return т;
  }
} // override

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                                 Параметры                                |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

override
{
  У посети(Параметр у)
  {
    return у;
  }

  У посети(Параметры у)
  {
    return у;
  }

  У посети(ПараметрАлиасШаблона у)
  {
    return у;
  }

  У посети(ПараметрТипаШаблона у)
  {
    return у;
  }

  У посети(ПараметрЭтотШаблона у) // D2.0
  {
    return у;
  }

  У посети(ПараметрШаблонЗначения у)
  {
    return у;
  }

  У посети(ПараметрКортежШаблона у)
  {
    return у;
  }

  У посети(ПараметрыШаблона у)
  {
    return у;
  }

  У посети(АргументыШаблона у)
  {
    return у;
  }
} // override
}
