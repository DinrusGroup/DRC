
module drc.semantic.Analysis;

import drc.ast.Node,
       drc.ast.Expressions;
import drc.semantic.Scope;
import drc.lexer.IdTable;
import drc.Compilation;
import common;

/// Общая семантика для декларации прагм и инструкций.
проц  семантикаПрагмы(Масштаб масш, Сема* локПрагмы,
                    Идентификатор* идент,
                    Выражение[] арги)
{
  if (идент is Идент.сооб)
    прагма_сооб(масш, локПрагмы, арги);
  else if (идент is Идент.биб)
    прагма_биб(масш, локПрагмы, арги);
  // else
  //   масш.ошибка(начало, "нераспознанная прагма");
}

/// Оценивает прагма сообщение.
проц  прагма_сооб(Масштаб масш, Сема* локПрагмы, Выражение[] арги)
{
  if (арги.length == 0)
    return /*масш.ошибка(локПрагмы, "в прагме ожидались аргументы выражения")*/;

  foreach (арг; арги)
  {
    auto в = арг/+.evaluate()+/;
    if (в is пусто)
    {
      // масш.ошибка(в.начало, "выражение нельзя оценить во время компиляции");
    }
    else if (auto ткстВыр = в.Является!(ТекстовоеВыражение))
      // Вывести текст на стандартный вывод.
      выдай(ткстВыр.дайТекст());
    else
    {
      // масш.ошибка(в.начало, "выражение должно оцениваться как ткст");
    }
  }
  // Напечатать нс в конце.
  выдай('\n');
}

/// Оценивает прагму биб.
проц  прагма_биб(Масштаб масш, Сема* локПрагмы, Выражение[] арги)
{
  if (арги.length != 1)
    return /*масш.ошибка(локПрагмы, "в прагме ожидался один аргумент выражения")*/;

  auto в = арги[0]/+.evaluate()+/;
  if (в is пусто)
  {
    // масш.ошибка(в.начало, "выражение нельзя оценить во время компиляции");
  }
  else if (auto ткстВыр = в.Является!(ТекстовоеВыражение))
  {
    // TODO: собрать пути к библиотекам в Модуль?
    // масш.модуль.addLibrary(ткстВыр.дайТекст());
  }
  else
  {
    // масш.ошибка(в.начало, "выражение должно оцениваться как ткст");
  }
}

/// Возвращает "да", если первая ветвь if (отладочной декларации/инструкции); или
/// "нет", если должна быть вкомпилирована ветвь else.
бул выборОтладВетви(Сема* услов, КонтекстКомпиляции контекст)
{
  if (услов)
  {
    if (услов.вид == TOK.Идентификатор)
    {
      if (контекст.найдиИдОтладки(услов.идент.ткт))
        return да;
    }
    else if (услов.бцел_ <= контекст.уровеньОтладки)
      return да;
  }
  else if (1 <= контекст.уровеньОтладки)
    return да;
  return нет;
}

/// Возвращает "да", если первая ветвь if (отладочной декларации/инструкции); или
/// "нет", если должна быть вкомпилирована ветвь else.
бул выборВерсионВетви(Сема* услов, КонтекстКомпиляции контекст)
{
  assert(услов);
  if (услов.вид == TOK.Идентификатор || услов.вид == TOK.Юниттест)
  {
    if (контекст.найдиИдВерсии(услов.идент.ткт))
      return да;
  }
  else if (услов.бцел_ >= контекст.уровеньВерсии)
    return да;
  return нет;
}
