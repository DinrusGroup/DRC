/// Author: Aziz Köksal, Vitaly Kulich
/// License: GPL3
/// $(Maturity average)
module drc.semantic.Symbols;

import drc.ast.Node,
       drc.ast.Expression;
import drc.semantic.Symbol,
       drc.semantic.SymbolTable,
       drc.semantic.Types;
import drc.lexer.IdTable;
import drc.Enums;
import common;

/// Символ, имеющий собственный Масштаб с таблицей символов.
class СимволМасштаба : Символ
{
  ТаблицаСимволов таблицаСимволов; /// Таблица символов.
  Символ[] члены; /// Символы членов(в лексическом порядке.)

  /// Строит СимволМасштаба объект.
  this(СИМ сид, Идентификатор* имя, Узел узел)
  {
    super(сид, имя, узел);
  }

  /// Строит СимволМасштаба объект с СИМ.Масштаб ид.
  this(Идентификатор* имя = Идент.Пусто, Узел узел = пусто)
  {
    super(СИМ.Масштаб, имя, узел);
  }

  /// Найти имя в таблице.
  Символ сыщи(Идентификатор* имя)
  {
    return таблицаСимволов.сыщи(имя);
  }

  /// Найти имя в таблице.
  Символ сыщи(ткст имя)
  {
    auto ид = ТаблицаИд.сыщи(имя);
    return ид ? таблицаСимволов.сыщи(ид) : пусто;
  }

  /// Вставить символ в таблицу.
  проц  вставь(Символ s, Идентификатор* имя)
  {
    таблицаСимволов.вставь(s, имя);
    члены ~= s;
  }
}

/// У агрегатов бывают члены-функции и поля.
abstract class Агрегат : СимволМасштаба
{
  Тип тип;
  Функция[] функции;
  Переменная[] поля;

  this(СИМ сид, Идентификатор* имя, Узел узел)
  {
    super(сид, имя, узел);
  }

  override проц  вставь(Символ s, Идентификатор* идент)
  {
    if (s.Переменная_ли)
      // Добавить переменную в поля.
      поля ~= cast(Переменная)cast(ук)s;
    else if (s.Функция_ли)
      // Добавить функцию в функции.
      функции ~= cast(Функция)cast(ук)s;
    super.вставь(s, идент);
  }
}

/// атр class символ.
class Класс : Агрегат
{
  this(Идентификатор* имя, Узел classNode)
  {
    super(СИМ.Класс, имя, classNode);
    this.тип = new  drc.semantic.Types.ТипКласс(this);
  }
}

/// An interface символ.
class Интерфейс : Агрегат
{
  this(Идентификатор* имя, Узел узелИнтерфейса)
  {
    super(СИМ.Интерфейс, имя, узелИнтерфейса);
    this.тип = new  drc.semantic.Types.ТипКласс(this);
  }
}

/// атр struct символ.
class Структура : Агрегат
{
  бул анонимен;
  this(Идентификатор* имя, Узел structNode)
  {
    super(СИМ.Структура, имя, structNode);
    this.тип = new  drc.semantic.Types.ТипСтруктура(this);
    this.анонимен = имя is пусто;
  }
}

/// атр union символ.
class Союз : Агрегат
{
  бул анонимен;
  this(Идентификатор* имя, Узел unionNode)
  {
    super(СИМ.Союз, имя, unionNode);
    this.тип = new  drc.semantic.Types.ТипСтруктура(this);
    this.анонимен = имя is пусто;
  }
}

/// An enum символ.
class Перечень : СимволМасштаба
{
  drc.semantic.Types.ТипПеречень тип;
  бул анонимен;
  this(Идентификатор* имя, Узел enumNode)
  {
    super(СИМ.Перечень, имя, enumNode);
    this.тип = new  drc.semantic.Types.ТипПеречень(this);
    this.анонимен = имя is пусто;
  }

  проц  установиТип( drc.semantic.Types.ТипПеречень тип)
  {
    this.тип = тип;
  }
}

/// атр template символ.
class Шаблон : СимволМасштаба
{
  this(Идентификатор* имя, Узел узелШаблона)
  {
    super(СИМ.Шаблон, имя, узелШаблона);
  }
}

/// атр function символ.
class Функция : СимволМасштаба
{
  Защита защ; /// The защита.
  КлассХранения кхр; /// The stилиage classes.
  ТипКомпоновки типКомпоновки; /// The linkage тип.

  Тип типВозврата;
  Переменная[] парамы;

  this(Идентификатор* имя, Узел узелФункции)
  {
    super(СИМ.Функция, имя, узелФункции);
  }
}

/// атр переменная символ.
class Переменная : Символ
{
  Защита защ; /// The защита.
  КлассХранения кхр; /// The stилиage classes.
  ТипКомпоновки типКомпоновки; /// The linkage тип.

  Тип тип; /// The тип of this переменная.
  Выражение значение; /// The значение of this переменная.

  this(Идентификатор* имя,
       Защита защ, КлассХранения кхр, ТипКомпоновки типКомпоновки,
       Узел узелПеременной)
  {
    super(СИМ.Переменная, имя, узелПеременной);

    this.защ = защ;
    this.кхр = кхр;
    this.типКомпоновки = типКомпоновки;
  }
}

/// An enum член символ.
class ЧленПеречня : Переменная
{
  this(Идентификатор* имя,
       Защита защ, КлассХранения кхр, ТипКомпоновки типКомпоновки,
       Узел узелЧленаПеречня)
  {
    super(имя, защ, кхр, типКомпоновки, узелЧленаПеречня);
    this.сид = СИМ.ЧленПеречня;
  }
}

/// An alias символ.
class Алиас : Символ
{
  this(Идентификатор* имя, Узел узелАлиаса)
  {
    super(СИМ.Алиас, имя, узелАлиаса);
  }
}

/// атр список of символы that share the same идентификатор.
///
/// These can be functions, templates and aggregates with template parameter lists.
class НаборПерегрузки : Символ
{
  Символ[] символы;

  this(Идентификатор* имя, Узел узел)
  {
    super(СИМ.НаборПерегрузки, имя, узел);
  }

  проц  добавь(Символ s)
  {
    символы ~= s;
  }
}
