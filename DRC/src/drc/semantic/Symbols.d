/// Author: Aziz Köksal
/// License: GPL3
/// $(Maturity average)
module drc.semantic.Symbols;

import drc.ast.Node,
       drc.ast.Expression;
import drc.semantic.Symbol,
       drc.semantic.SymbolTable,
       drc.semantic.Types;
import drc.lexer.IdTable;
import drc.Enums;
import common;

/// A символ that has its own Масштаб with a символ таблица.
class СимволМасштаба : Символ
{
  ТаблицаСимволов таблицаСимволов; /// The символ таблица.
  Символ[] члены; /// The член символы (in lexical order.)

  /// Строит СимволМасштаба объект.
  this(СИМ сид, Идентификатор* имя, Узел узел)
  {
    super(сид, имя, узел);
  }

  /// Строит СимволМасштаба объект with the СИМ.Масштаб ID.
  this(Идентификатор* имя = Идент.Пусто, Узел узел = null)
  {
    super(СИМ.Масштаб, имя, узел);
  }

  /// Look up имя in the таблица.
  Символ сыщи(Идентификатор* имя)
  {
    return таблицаСимволов.сыщи(имя);
  }

  /// Look up имя in the таблица.
  Символ сыщи(ткст имя)
  {
    auto ид = ТаблицаИд.сыщи(имя);
    return ид ? таблицаСимволов.сыщи(ид) : null;
  }

  /// Insert a символ into the таблица.
  проц  вставь(Символ s, Идентификатор* имя)
  {
    таблицаСимволов.вставь(s, имя);
    члены ~= s;
  }
}

/// Aggregates have function and field члены.
abstract class Агрегат : СимволМасштаба
{
  Тип тип;
  Функция[] funcs;
  Переменная[] fields;

  this(СИМ сид, Идентификатор* имя, Узел узел)
  {
    super(сид, имя, узел);
  }

  override проц  вставь(Символ s, Идентификатор* идент)
  {
    if (s.Переменная_ли)
      // Append переменная в fields.
      fields ~= cast(Переменная)cast(ук)s;
    else if (s.Функция_ли)
      // Append function в funcs.
      funcs ~= cast(Функция)cast(ук)s;
    super.вставь(s, идент);
  }
}

/// A class символ.
class Класс : Агрегат
{
  this(Идентификатор* имя, Узел classNode)
  {
    super(СИМ.Класс, имя, classNode);
    this.тип = new ТКласс(this);
  }
}

/// An interface символ.
class Интерфейс : Агрегат
{
  this(Идентификатор* имя, Узел узелИнтерфейса)
  {
    super(СИМ.Интерфейс, имя, узелИнтерфейса);
    this.тип = new ТКласс(this);
  }
}

/// A struct символ.
class Структура : Агрегат
{
  бул анонимен_ли;
  this(Идентификатор* имя, Узел structNode)
  {
    super(СИМ.Структура, имя, structNode);
    this.тип = new ТСтруктура(this);
    this.анонимен_ли = имя is null;
  }
}

/// A union символ.
class Союз : Агрегат
{
  бул анонимен_ли;
  this(Идентификатор* имя, Узел unionNode)
  {
    super(СИМ.Союз, имя, unionNode);
    this.тип = new ТСтруктура(this);
    this.анонимен_ли = имя is null;
  }
}

/// An enum символ.
class Перечень : СимволМасштаба
{
  ПереченьТип тип;
  бул анонимен_ли;
  this(Идентификатор* имя, Узел enumNode)
  {
    super(СИМ.Перечень, имя, enumNode);
    this.тип = new ПереченьТип(this);
    this.анонимен_ли = имя is null;
  }

  проц  установиТип(ПереченьТип тип)
  {
    this.тип = тип;
  }
}

/// A template символ.
class Шаблон : СимволМасштаба
{
  this(Идентификатор* имя, Узел узелШаблона)
  {
    super(СИМ.Шаблон, имя, узелШаблона);
  }
}

/// A function символ.
class Функция : СимволМасштаба
{
  Защита защ; /// The защита.
  КлассХранения кхр; /// The storage classes.
  ТипКомпоновки типКомпоновки; /// The linkage тип.

  Тип типВозврата;
  Переменная[] парамы;

  this(Идентификатор* имя, Узел узелФункции)
  {
    super(СИМ.Функция, имя, узелФункции);
  }
}

/// A переменная символ.
class Переменная : Символ
{
  Защита защ; /// The защита.
  КлассХранения кхр; /// The storage classes.
  ТипКомпоновки типКомпоновки; /// The linkage тип.

  Тип тип; /// The тип of this переменная.
  Выражение значение; /// The значение of this переменная.

  this(Идентификатор* имя,
       Защита защ, КлассХранения кхр, ТипКомпоновки типКомпоновки,
       Узел узелПеременной)
  {
    super(СИМ.Переменная, имя, узелПеременной);

    this.защ = защ;
    this.кхр = кхр;
    this.типКомпоновки = типКомпоновки;
  }
}

/// An enum член символ.
class ЧленПеречня : Переменная
{
  this(Идентификатор* имя,
       Защита защ, КлассХранения кхр, ТипКомпоновки типКомпоновки,
       Узел узелЧленаПеречня)
  {
    super(имя, защ, кхр, типКомпоновки, узелЧленаПеречня);
    this.сид = СИМ.ЧленПеречня;
  }
}

/// An alias символ.
class Алиас : Символ
{
  this(Идентификатор* имя, Узел узелАлиаса)
  {
    super(СИМ.Алиас, имя, узелАлиаса);
  }
}

/// A список of символы that share the same identifier.
///
/// These can be functions, templates and aggregates with template parameter lists.
class НаборПерегрузки : Символ
{
  Символ[] символы;

  this(Идентификатор* имя, Узел узел)
  {
    super(СИМ.НаборПерегрузки, имя, узел);
  }

  проц  добавь(Символ s)
  {
    символы ~= s;
  }
}
