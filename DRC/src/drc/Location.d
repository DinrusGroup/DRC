/// Author: Aziz Köksal
/// License: GPL3
/// $(Maturity high)
module drc.Location;

import drc.lexer.Funcs;
import drc.Unicode;

/// Представляет положение в тексте исходника.
final class Положение
{
  сим[] путьКФайлу; /// Путь к файлу.
  т_мера номСтр; /// Номер строки.
  сим* началоСтроки, в; /// Используется для вычисления столбца.

  static бцел ШИРИНА_ТАБ = 4; /// Дефолтная ширина символа табулятора.

  /// Передает параметры второму конструктору.
  this(сим[] путьКФайлу, т_мера номСтр)
  {
    установи(путьКФайлу, номСтр);
  }

  /// Конструирует объект Положение.
  this(сим[] путьКФайлу, т_мера номСтр, сим* началоСтроки, сим* в)
  {
    установи(путьКФайлу, номСтр, началоСтроки, в);
  }

  проц  установи(сим[] путьКФайлу, т_мера номСтр)
  {
    установи(путьКФайлу, номСтр, null, null);
  }

  проц  установи(сим[] путьКФайлу, т_мера номСтр, сим* началоСтроки, сим* в)
  {
    this.путьКФайлу  = путьКФайлу;
    установи(номСтр, началоСтроки, в);
  }

  проц  установи(т_мера номСтр, сим* началоСтроки, сим* в)
  {
    assert(началоСтроки <= в);
    this.номСтр   = номСтр;
    this.началоСтроки = началоСтроки;
    this.в        = в;
  }

  проц  установиПутьКФайлу(сим[] путьКФайлу)
  {
    this.путьКФайлу = путьКФайлу;
  }

  /// Используется простой метод для подсчёта числа символов в тексте.
  ///
 /// Примечание: Составные символы Unicode и прочие особые символы
 /// в расчёт не принимаются.
  /// Параметры:
  ///   ширинаТаб = сирина символа-табулятора.
  бцел вычислиСтолбец(бцел ширинаТаб = Положение.ШИРИНА_ТАБ)
  {
    бцел столб;
    auto p = началоСтроки;
    if (!p)
      return 0;
    for (; p <= в; p++)
    {
      assert(delegate ()
        {
          // Check that there is no новстр between p and в.
          // But 'в' may point в a новстр.
          if (p != в && новСтр_ли(*p))
            return нет;
          if (в-p >= 2 && новСтрЮ_ли(p))
            return нет;
          return да;
        }() == да
      );

      // Skip this байт if it is a trail байт of a UTF-8 sequence.
      if (ведомыйБайт_ли(*p))
        continue; // *p == 0b10xx_xxxx

      // Only счёт ASCII characters and the first байт of a UTF-8 sequence.
      if (*p == '\t')
        столб += ширинаТаб;
      else
        столб++;
    }
    return столб;
  }
  alias вычислиСтолбец номСтолб;
}
