
module drc.lexer.Funcs;

import drc.Unicode : юАльфа;

const дим _Z_ = 26; /// Control+Z.

/// Возвращает: да, если d является строкой Юникод или разделителем параграфа.
бул симНовСтрЮ(дим d)
{
  return d == РСд || d == РАд;
}

/// Возвращает: да, если у указывает на строку или разделитель параграфа.
бул новСтрЮ(сим* у)
{
  return *у == РС[0] && у[1] == РС[1] && (у[2] == РС[2] || у[2] == РА[2]);
}

/// Возвращает: да, если у указывает на начало новой строки Новстр.
/// $(PRE
/// Новстр := "\n" | "\r" | "\r\n" | РС | РА
/// РС := "\u2028"
/// РА := "\u2029"
/// )
бул новСтр(сим* у)
{
  return *у == '\n' || *у == '\r' || новСтрЮ(у);
}

/// Возвращает: да, если с является символом Новстр.
бул новСтр(дим с)
{
  return с == '\n' || с == '\r' || симНовСтрЮ(с);
}

/// Возвращает: да, если у указыват на символ КФ.
/// $(PRE
/// КФ := "\0" | _Z_
/// _Z_ := "\x1A"
/// )
бул кф(дим с)
{
  return с == 0 || с == _Z_;
}

/// Возвращает: да, если у указывает на первый символ КонецСтроки.
/// $(PRE КонецСтроки := Новстр | КФ)
бул конецСтроки(сим* у)
{
  return новСтр(у) || кф(*у);
}

/// Сканирует символ Новстр и устанавливает у на символ после него.
/// Возвращает: да, если найдено или нет в противном случае.
бул сканируйНовСтр(ref сим* у)
in { assert(у); }
body
{
  switch (*у)
  {
  case '\r':
    if (у[1] == '\n')
      ++у;
  case '\n':
    ++у;
    break;
  default:
    if (новСтрЮ(у))
      у += 3;
    else
      return нет;
  }
  return да;
}

/// Сканирует символ Новстр и устанавливает у на символ после него.
/// Возвращает: да, если найдено или нет в противном случае.
бул сканируйНовСтр(ref сим* у, сим* конец)
in { assert(у && у < конец); }
body
{
  switch (*у)
  {
  case '\r':
    if (у+1 < конец && у[1] == '\n')
      ++у;
  case '\n':
    ++у;
    break;
  default:
    if (у+2 < конец && новСтрЮ(у))
      у += 3;
    else
      return нет;
  }
  return да;
}

/// Сканирует Новстр в обратном направлении и устанавливает конец
/// на первом символе нс.
/// Возвращает: да, если найдено или нет в противном случае.
бул сканируйНовСтрРеверс(сим* начало, ref сим* конец)
{
  switch (*конец)
  {
  case '\n':
    if (начало <= конец-1 && конец[-1] == '\r')
      конец--;
  case '\r':
    break;
  case РС[2], РА[2]:
    if (начало <= конец-2 && конец[-1] == РС[1] && конец[-2] == РС[0]) {
      конец -= 2;
      break;
    }
  // fall through
  default:
    return нет;
  }
  return да;
}

/// Сканирует идентификатор Динрус.
/// Параметры:
///   ссыл_ук = точка начала.
///   конец = точка окончания.
/// Возвращает: идентификатор, если он действителен (устанавливает ссыл_ук на 1 после ид,) или
///          пусто, если недействителен (оставляет неизменным ссыл_ук.)
ткст сканируйИдентификатор(ref сим* ссыл_ук, сим* конец)
in { assert(ссыл_ук && ссыл_ук < конец); }
body
{
  auto у = ссыл_ук;
  if (начсим(*у) || юАльфа(у, конец)) // НачалоИд
  {
    do // СимвИд*
      у++;
    while (у < конец && (идент(*у) || юАльфа(у, конец)))
    auto идентификатор = ссыл_ук[0 .. у-ссыл_ук];
    ссыл_ук = у;
    return идентификатор;
  }
  return пусто;
}

/// Таблица свойств символов ASCII.
static const цел таблук[256] = [
 0, 0, 0, 0, 0, 0, 0, 0, 0,32, 0,32,32, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
32, 0, 0x2200, 0, 0, 0, 0, 0x2700, 0, 0, 0, 0, 0, 0, 0, 0,
 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 0, 0, 0, 0, 0, 0x3f00,
 0,12,12,12,12,12,12, 8, 8, 8, 8, 8, 8, 8, 8, 8,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0x5c00, 0, 0,16,
 0, 0x70c, 0x80c,12,12,12, 0xc0c, 8, 8, 8, 8, 8, 8, 8, 0xa08, 8,
 8, 8, 0xd08, 8, 0x908, 8, 0xb08, 8, 8, 8, 8, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
];

/// Перечень флагов свойств символов.
enum СвойствоС
{
       Восмиричный = 1,    /// 0-7
       Десятичный = 1<<1, /// 0-9
         Гекс = 1<<2, /// 0-9a-fA-F
       Буква = 1<<3, /// a-zA-Z
  Подчерк = 1<<4, /// _
  Пробельный = 1<<5  /// ' ' \t \v \f
}

const бцел EVMask = 0xFF00; // Bit mask for escape значение.

private alias СвойствоС CP;
/// Возвращает: "да", если с есть восмиричное число.
цел восмир(сим с) { return таблук[с] & CP.Восмиричный; }
/// Возвращает: "да", если с есть десятичное число.
цел цифра(сим с) { return таблук[с] & CP.Десятичный; }
/// Возвращает: "да", если с есть 16-ричное число.
цел гекс(сим с) { return таблук[с] & CP.Гекс; }
/// Возвращает: "да", если с есть буква.
цел буква(сим с) { return таблук[с] & CP.Буква; }
/// Возвращает: "да", если с есть числобуквенное значение.
цел цифробукв(сим с) { return таблук[с] & (CP.Буква | CP.Десятичный); }
/// Возвращает: "да", если с is начало D идентификатора (только ASCII.)
цел начсим(сим с) { return таблук[с] & (CP.Буква | CP.Подчерк); }
/// Возвращает: "да", если с есть D  символ идентификатора(только ASCII.)
цел идент(сим с) { return таблук[с] & (CP.Буква | CP.Подчерк | CP.Десятичный); }
/// Возвращает: "да", если с есть пробельный символ.
цел пбел(сим с) { return таблук[с] & CP.Пробельный; }
/// Возвращает: искейпное значение для с.
цел сим8еск(сим с) { return таблук[с] >> 8; /*(таблук[с] & EVMask) >> 8;*/ }
/// Возвращает: "да", если с есть ASCII символ.
цел аски(бцел с) { return с < 128; }

version(gen_ptable)
static this()
{
  alias таблук у;
  assert(у.length == 256);
  // Инициализируем таблицу свойств символов.
  for (цел i; i < у.length; ++i)
  {
    у[i] = 0; // Reset
    if ('0' <= i && i <= '7')
      у[i] |= CP.Восмиричный;
    if ('0' <= i && i <= '9')
      у[i] |= CP.Десятичный | CP.Гекс;
    if ('a' <= i && i <= 'f' || 'A' <= i && i <= 'F')
      у[i] |= CP.Гекс;
    if ('a' <= i && i <= 'z' || 'A' <= i && i <= 'Z')
      у[i] |= CP.Буква;
    if (i == '_')
      у[i] |= CP.Подчерк;
    if (i == ' ' || i == '\t' || i == '\v' || i == '\f')
      у[i] |= CP.Пробельный;
  }
  // Сохраним значения искейп-последовательности во втором байте.
  assert(СвойствоС.max <= ббайт.max, "флаги свойств символа и байт искеп-значения нахлёстываются.");
  у['\''] |= 39 << 8;
  у['"'] |= 34 << 8;
  у['?'] |= 63 << 8;
  у['\\'] |= 92 << 8;
  у['a'] |= 7 << 8;
  у['b'] |= 8 << 8;
  у['f'] |= 12 << 8;
  у['n'] |= 10 << 8;
  у['r'] |= 13 << 8;
  у['t'] |= 9 << 8;
  у['v'] |= 11 << 8;
  // Выведем литерал форматированного массива.
  ткст массив = "[\n";
  foreach (i, с; таблук)
  {
    массив ~= Формат((с>255?" 0x{0:x},":"{0,2},"), с) ~ (((i+1) % 16) ? "":"\n");
  }
  массив[$-2..$] = "\n]";
  выдай(массив).нс;
}
