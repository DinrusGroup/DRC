module drc.lexer.Token;

import drc.lexer.Identifier, drc.lexer.Funcs, drc.Location;
import cidrus : malloc, free;
import exception, common;

public import drc.lexer.TokensEnum;

/// Сема (англ. token) -  цепочка символов, формируемая лексическим анализатором.
struct Сема
{ /// Флаги, устанавливаемые Лексером.
  enum Флаги : бкрат
  {
    Нет,
    Пробельный = 1, /// Знаки с этим флагом игнорируются Парсером.
  }

  TOK вид; /// Вид семы.
  Флаги флаги; /// Флаги семы.
  /// Указатели на следующую и предыдущую семы (дважды линкованный список.)
  Сема* следщ, предш;

  /// Начало пробельных символов перед семой. Нулл, если их нет.
  /// TODO: удалить для сохранения пространства; можно заменить на 'предш.конец'.
  сим* пп;
  сим* старт; /// Указывает на первый символ семы.
  сим* конец;   /// На +1 символ после окончания семы.

  /// Данные, ассоциированные с данной семой.
  /// TODO: убрать структуры данных; успользовать только указатели, чтобы уменьшить
  /// размер Сема.sizeof.
  union
  {
    /// Для нс семы.
    ДанныеНовСтр нс;
    /// Для #line семы.
    struct
    {
      Сема* номСтрокиСем; /// номер строки #line
      Сема* семаФайлспецСтроки; ///файлспец номера строки #line
    }
    /// Значение семы ткст.
    struct
    {
      ткст ткт; /// Ткст, оканчивающийся на ноль. (Ноль входит в длину length.)
      сим pf;    /// Постфикс 'конст', 'w', 'd' или 0 для none.
    version(D2)
      Сема* ткт_семы; /++ Указывает в конец содержимого сема ткст, сохраненного как
                          дважды линкованный список. Последняя сема всегда = '}' или
                          КФ в случае, если в конце исходного текста находится "q{" КФ.
                      +/
    }
    Идентификатор* идент; /// Для ключевых слов и идентификаторов.
    дим  дим_;   /// Значение символа (dchar).
    дол   дол_;    /// Целочисленное значение дол (long).
    бдол  бдол_;   /// Целочисленное значение беззначного дол (бдол).
    цел    цел_;     /// Целочисленное значение (цел).
    бцел   бцел_;    /// Беззначное целочисленное значение (бцел).
    плав  плав_;   /// Значение плав (float).
    дво дво_;  /// Значение дво (дво).
    реал   реал_;    /// Значение реал (real).
  }

  /// Возвращает текст семы.
  ткст исхТекст()
  {
    assert(старт && конец);
    return старт[0 .. конец - старт];
  }

  /// Возвращает предшествующие семе пробелы.
  ткст пробСимволы()
  {
    assert(пп && старт);
    return пп[0 .. старт - пп];
  }

  /// Находит следующую непробельную сему.
  /// Возвращает: 'эту' сему, если предыдущая является TOK.ГОЛОВА или пусто (пусто).
  Сема* следщНепроб()
  out(сема)
  {
    assert(сема !is пусто);
  }
  body
  {
    auto сема = следщ;
    while (сема !is пусто && сема.пробел)
      сема = сема.следщ;
    if (сема is пусто || сема.вид == TOK.КФ)
      return this;
    return сема;
  }

  /// Находит предшествующую непробельную сему.
  /// Возвращает: 'эту' сему, если предыдущая является TOK.ГОЛОВА или пусто.
  Сема* предшНепроб()
  out(сема)
  {
    assert(сема !is пусто);
  }
  body
  {
    auto сема = предш;
    while (сема !is пусто && сема.пробел)
      сема = сема.предш;
    if (сема is пусто || сема.вид == TOK.ГОЛОВА)
      return this;
    return сема;
  }

  /// Возвращает текстовое определение вида данной семы.
  static ткст вТкст(TOK вид)
  {
    return семаВТкст[вид];
  }

  /// Добавляет Флаги.Пробельный в this.флаги.
  проц  установиФлагПробельные()
  {
    this.флаги |= Флаги.Пробельный;
  }

  /// Возвращает да, если это сема, внутри которой могут быть символы новой строки.
  ///
  /// Могут быть блочными и гнездовыми комментариями и любым ткстовым литералом,
  /// кроме текстовых литералов искейпа.
  бул многострок()
  {
    return вид == TOK.Ткст && старт[0] != '\\' ||
           вид == TOK.Комментарий && старт[1] != '/';
  }

  /// Возвращает да, если является сема-ключевое слово.
  бул кслово()
  {
    return НачалоКС <= вид && вид <= КонецКС;
  }

  /// Возвращает да, если является сема интегрального типа.
  бул интегральныйТип()
  {
    return НачалоИнтегральногоТипа <= вид && вид <= КонецИнтегральногоТипа;
  }

  /// Возвращает да, если является сема пробела.
  бул пробел()
  {
    return !!(флаги & Флаги.Пробельный);
  }

  /// Возвращает да, если является особой семой.
  бул спецСема()
  {
    return НачалоСпецСем <= вид && вид <= КонецСпецСем;
  }

version(D2)
{
  /// Возвращает да, если является литералом текста семы.
  бул семаСтроковогоЛитерала()
  {
    return вид == TOK.Ткст && ткт_семы !is пусто;
  }
}

  /// Возвращает "да", если эта сема начинает ДефиницияДекларации.
  бул началоДефДекл()
  {
    return семаНачалаДеклДеф(вид);
  }

  /// Возвращает "да", если эта сема начинает Инструкция.
  бул началоИнстр()
  {
    return семаНачалаИнстр(вид);
  }

  /// Возвращает "да", если this сема начинает ИнструкцияАсм.
  бул началоАсмИнстр()
  {
    return семаНачалаАсмИнстр(вид);
  }

  цел opEquals(TOK вид2)
  {
    return вид == вид2;
  }

  цел opCmp(Сема* пв)
  {
    return старт < пв.старт;
  }

  /// Возвращает положение данной семы.
  Положение дайПоложение(бул реальноеПоложение)()
  {
    auto т_поиск = this.предш;
    // Найти предш. нс сема.
    while (т_поиск.вид != TOK.Новстр)
      т_поиск = т_поиск.предш;
    static if (реальноеПоложение)
    {
      auto путьКФайлу  = т_поиск.нс.путиКФайлам.исхПуть;
      auto номерСтроки   = т_поиск.нс.ориНомСтр;
    }
    else
    {
      auto путьКФайлу  = т_поиск.нс.путиКФайлам.устПуть;
      auto номерСтроки   = т_поиск.нс.ориНомСтр - т_поиск.нс.устНомСтр;
    }
    auto началоСтроки = т_поиск.конец;
    // Определить действительное начало и номер строки.
    while (1)
    {
      т_поиск = т_поиск.следщ;
      if (т_поиск == this)
        break;
      // Многострочные семы требуется ресканировать на новстры.
      if (т_поиск.многострок)
      {
        auto у = т_поиск.старт, конец = т_поиск.конец;
        while (у != конец)
          if (сканируйНовСтр(у))
          {
            началоСтроки = у;
            ++номерСтроки;
          }
          else
            ++у;
      }
    }
    return new Положение(путьКФайлу, номерСтроки, началоСтроки, this.старт);
  }

  alias дайПоложение!(да) дайРеальноеПоложение;
  alias дайПоложение!(нет) дайПоложениеОшибки;

  бцел счётСтрок()
  {
    бцел счёт = 1;
    if (this.многострок)
    {
      auto у = this.старт, конец = this.конец;
      while (у != конец)
      {
        if (сканируйНовСтр(у) == '\n')
          ++счёт;
        else
          ++у;
      }
    }
    return счёт;
  }

  /// Выводит исходный текст, заключенный между левой и правой семами.
  static ткст участокТекста(Сема* левый, Сема* правый)
  {
    assert(левый.конец <= правый.старт || левый is правый );
    return левый.старт[0 .. правый.конец - левый.старт];
  }

  /// Использует malloc() , чтобы размещать память под сему.
  new(т_мера размер)
  {
    ук у = malloc(размер);
    if (у is пусто)
      throw new ВнеПамИскл(__FILE__, __LINE__);
    // TODO: В Сема.иниц должны быть все нули.
    // Может, использовать calloc(), чтобы избежать этой строки?
    *cast(Сема*)у = Сема.init;
    return у;
  }

  /// Удалить сему, используя free().
  delete(ук у)
  {
    auto сема = cast(Сема*)у;
    if (сема)
    {
      if(сема.вид == TOK.ХэшСтрочка)
        сема.разрушьСемуХэшСтроки();
      else
      {
      version(D2)
        if (сема.семаСтроковогоЛитерала)
          сема.разрушьЛитералСтрокиСемы();
      }
    }
    free(у);
  }

  проц  разрушьСемуХэшСтроки()
  {
    assert(вид == TOK.ХэшСтрочка);
    delete номСтрокиСем;
    delete семаФайлспецСтроки;
  }

version(D2)
{
  проц  разрушьЛитералСтрокиСемы()
  {
    assert(вид == TOK.Ткст);
    assert(старт && *старт == 'q' && старт[1] == '{');
    assert(ткт_семы !is пусто);
    auto tok_it = ткт_семы;
    auto tok_del = ткт_семы;
    while (tok_it && tok_it.вид != TOK.КФ)
    {
      tok_it = tok_it.следщ;
      assert(tok_del && tok_del.вид != TOK.КФ);
      delete tok_del;
      tok_del = tok_it;
    }
  }
}
}

/// Данные, связанные с нс семы.
struct ДанныеНовСтр
{
  struct ФПути
  {
    ткст исхПуть;   /// Оригинальный путь к исходному тексту.
    ткст устПуть;   /// Путь, установленный #line.
  }
  ФПути* путиКФайлам;
  бцел ориНомСтр;  /// Действительное число строк в исходном тексте.
  бцел устНомСтр;  ///Дельта числа строк, установленная #line.
}

/// Возвращает "да", если эта сема начинает ДефиницияДекларации.
бул семаНачалаДеклДеф(TOK лекс)
{
  switch (лекс)
  {
  alias TOK T;
  case  T.Расклад, T.Прагма, T.Экспорт, T.Приватный, T.Пакет, T.Защищённый,
        T.Публичный, T.Экстерн, T.Устаревший, T.Перепись, T.Абстрактный,
        T.Синхронизованный, T.Статический, T.Окончательный, T.Конст, T.Инвариант/*D 2.0*/,
        T.Авто, T.Масштаб, T.Алиас, T.Типдеф, T.Импорт, T.Перечень, T.Класс,
        T.Интерфейс, T.Структура, T.Союз, T.Этот, T.Тильда, T.Юниттест, T.Отладка,
        T.Версия, T.Шаблон, T.Нов, T.Удалить, T.Смесь, T.ТочкаЗапятая,
        T.Идентификатор, T.Точка, T.Типа:
    return да;
  default:
    if (НачалоИнтегральногоТипа <= лекс && лекс <= КонецИнтегральногоТипа)
      return да;
  }
  return нет;
}

/// Возвращает "да", если эта сема начинает Инструкция.
бул семаНачалаИнстр(TOK лекс)
{
  switch (лекс)
  {
  alias TOK T;
  case  T.Расклад, T.Экстерн, T.Окончательный, T.Конст, T.Авто, T.Идентификатор, T.Точка,
        T.Типа, T.Если, T.Пока, T.Делай, T.При, T.ДляВсех, T.ДляВсех_реверс,
        T.Щит, T.Реле, T.Дефолт, T.Далее, T.Всё, T.Итог, T.Переход,
        T.Для, T.Синхронизованный, T.Пробуй, T.Брось, T.Масштаб, T.Волатайл, T.Асм,
        T.Прагма, T.Смесь, T.Статический, T.Отладка, T.Версия, T.Алиас, T.ТочкаЗапятая,
        T.Перечень, T.Класс, T.Интерфейс, T.Структура, T.Союз, T.ЛФСкобка, T.Типдеф,
        T.Этот, T.Супер, T.Нуль, T.Истина, T.Ложь, T.Цел32, T.Цел64, T.Бцел32,
        T.Бцел64, T.Плав32, T.Плав64, T.Плав80, T.Мнимое32,
        T.Мнимое64, T.Мнимое80, T.СимЛитерал, T.Ткст, T.ЛКвСкобка,
        T.Функция, T.Делегат, T.Подтвердить, T.Импорт, T.Идтипа, T.Является, T.ЛСкобка,
        T.Трэтс/*D2.0*/, T.ИБинарное, T.ПлюсПлюс, T.МинусМинус, T.Умножь,
        T.Минус, T.Плюс, T.Не, T.Тильда, T.Нов, T.Удалить, T.Каст:
    return да;
  default:
    if (НачалоИнтегральногоТипа <= лекс && лекс <= КонецИнтегральногоТипа ||
        НачалоСпецСем <= лекс && лекс <= КонецСпецСем)
      return да;
  }
  return нет;
}

/// Возвращает "да", если эта сема начинает ИнструкцияАсм.
бул семаНачалаАсмИнстр(TOK лекс)
{
  switch(лекс)
  {
  alias TOK T;
  case T.Вхо, T.Цел, T.Вых, T.Идентификатор, T.Расклад, T.ТочкаЗапятая:
    return да;
  default:
  }
  return нет;
}
