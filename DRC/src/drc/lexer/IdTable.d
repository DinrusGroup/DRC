module drc.lexer.IdTable;

import drc.lexer.TokensEnum,
       drc.lexer.IdentsGenerator,
       drc.lexer.Keywords;
import common;

public import drc.lexer.Identifier,
              drc.lexer.IdentsEnum;

/// Неймспейс для предопределенных идентификаторов.
struct Идент
{
  const static
  {
    mixin(генерируйЧленыИдент());
  }

  /// Возвращает массив предопределенных идентификаторов.
  static Идентификатор*[] всеИды()
  {
    return __всеИды;
  }
}

/// Глобальная таблица для размещения и получения идентификаторов.
struct ТаблицаИд
{
static:
  /// Набор общих, предопределенных идентификаторов для быстрых поисков.
  private Идентификатор*[ткст] статическаяТаблица;
  /// Таблица, растущая с каждым новым уникальным идентификатором.
  private Идентификатор*[ткст] растущаяТаблица;

  /// Загружает ключевые слова и предопределенные идентификаторы в статическую таблицу.
  static this()
  {
    foreach (ref k; г_зарезервированныеИды)
      статическаяТаблица[k.ткт] = &k;
    foreach (ид; Идент.всеИды())
      статическаяТаблица[ид.ткт] = ид;
    статическаяТаблица.rehash;
  }

  /// Ищет ткстИда в обеих таблицах.
  Идентификатор* сыщи(ткст ткстИда)
  {
    auto ид = вСтатической(ткстИда);
    if (ид)
      return ид;
    return вРастущей(ткстИда);
  }

  /// Ищет ткстИда в статической таблице.
  Идентификатор* вСтатической(ткст ткстИда)
  {
    auto ид = ткстИда in статическаяТаблица;
    return ид ? *ид : пусто;
  }

  alias Идентификатор* function(ткст ткстИда) ФункцияПоиска;
  /// Ищет ткстИда в растущей таблице.
  ФункцияПоиска вРастущей = &_inGrowing_unsafe; // Дефолт на небезопасную функцию.

  /// Устанавливает режим безопасности нити для растущей таблицы.
  проц  установиНитебезопасность(бул b)
  {
    if (b)
      вРастущей = &_inGrowing_safe;
    else
      вРастущей = &_inGrowing_unsafe;
  }

  /// Возвращает да, если доступ к растущей таблице нитебезопасен.
  бул нитебезопасно()
  {
    return вРастущей is &_inGrowing_safe;
  }

  /// Ищет ткстИда в таблице.
  ///
  /// Добавляет ткстИда в таблицу, если он не найден.
  private Идентификатор* _inGrowing_unsafe(ткст ткстИда)
  out(ид)
  { assert(ид !is пусто); }
  body
  {
    auto ид = ткстИда in растущаяТаблица;
    if (ид)
      return *ид;
    auto newID = Идентификатор(ткстИда, TOK.Идентификатор);
    растущаяТаблица[ткстИда] = newID;
    return newID;
  }

  /// Находит ткстИда в таблице.
  ///
  /// Добавляет ткстИда в таблицу, если он не найден.
  /// Доступ к структуре данных синхронизируется.
  private Идентификатор* _inGrowing_safe(ткст ткстИда)
  {
    synchronized
      return _inGrowing_unsafe(ткстИда);
  }

  /+
  Идентификатор* addIdentifiers(сим[][] idStrings)
  {
    auto ids = new Идентификатор*[idStrings.length];
    foreach (i, ткстИда; idStrings)
    {
      Идентификатор** ид = ткстИда in tabulatedIds;
      if (!ид)
      {
        auto newID = Идентификатор(TOK.Идентификатор, ткстИда);
        tabulatedIds[ткстИда] = newID;
        ид = &newID;
      }
      ids[i] = *ид;
    }
  }
  +/

  static бцел анонСчёт; /// Счётчик анонимных идентификаторов.

  /// Генерирует анонимный идентификатор.
  ///
  /// Объединяет префикс с анонСчёт.
  /// Этот идентификатор не вставляется в таблицу.
  Идентификатор* генБезымянныйИД(ткст префикс)
  {
    ++анонСчёт;
    auto x = анонСчёт;
    // Конвертировать счёт в ткст и добавить его в ткт.
    ткст чис;
    do
      чис = cast(сим)('0' + (x % 10)) ~ чис;
    while (x /= 10);
    return Идентификатор(префикс ~ чис, TOK.Идентификатор);
  }

  /// Генерирует идентификатор для анонимного перечня.
  Идентификатор* генИДАнонПеречня()
  {
    return генБезымянныйИД("__anonenum");
  }

  /// Генерирует идентификатор для анонимного класса.
  Идентификатор* генАнонКлассИД()
  {
    return генБезымянныйИД("__anonclass");
  }

  /// Генерирует идентификатор для анонимной структуры.
  Идентификатор* генАнонСтруктИД()
  {
    return генБезымянныйИД("__anonstruct");
  }

  /// Генерирует идентификатор для анонимного союза.
  Идентификатор* генАнонСоюзИД()
  {
    return генБезымянныйИД("__anonunion");
  }

  /// Генерирует идентификатор для модуля, у которого нет соответствующего имени.
  Идентификатор* генИдМодуля()
  {
    return генБезымянныйИД("__module");
  }
}

unittest
{
  // TODO: пиши benchmark.
  // Single таблица

  // Single таблица. synchronized

  // Two tables.

  // Two tables. synchronized
}
