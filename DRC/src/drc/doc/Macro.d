/// Author: Aziz Köksal, Vitaly Kulich
/// License: GPL3
/// $(Maturity high)
module drc.doc.Macro;

import drc.doc.Parser;
import drc.lexer.Funcs;
import drc.Unicode;
import drc.Diagnostics;
import drc.Messages;
import common;

/// Класс макроса ДДок.
class Макрос
{
  ткст имя; /// Имя этого макроса.
  ткст текст; /// Текст подстановки.
  бцел callLevel;  /// Уровень рекурсивного вызова.
  /// Строит объект Макрос.
  this (ткст имя, ткст текст)
  {
    this.имя = имя;
    this.текст = текст;
  }
}

/// Мапирует имена макросов в объекты Макрос.
///
/// ТаблицыМакросов могут сцепляться, выстраивая линейную иерархию.
/// Определения макросов в текущей таблице переписывает их в родительских таблицах.
class ТаблицаМакросов
{
  /// Родитель в данной иерархии.Или пусто, если это корень.
  ТаблицаМакросов родитель;
  Макрос[ткст] таблица; /// Ассоциативный массив с определениями макросов.

  /// Строит экземпляр ТаблицаМакросов.
  this(ТаблицаМакросов родитель = пусто)
  {
    this.родитель = родитель;
  }

  /// Вставляет макрос m в таблицу.
  /// Переписывает текущий макрос, если он есть.
  проц  вставь(Макрос m)
  {
    таблица[m.имя] = m;
  }

  /// Вставляет массив макросов в таблицу.
  проц  вставь(Макрос[] макрос)
  {
    foreach (m; макрос)
      вставь(m);
  }

  /// Создаёт макрос, используя имя и текст, и вставляет его в таблицу.
  проц  вставь(ткст имя, ткст текст)
  {
    вставь(new Макрос(имя, текст));
  }

  /// Создаёт макрос, используя имя[n] и текст[n], и вставляет его в таблицу.
  проц  вставь(ткст[] имена, ткст[] тексты)
  {
    assert(имена.length == тексты.length);
    foreach (i, имя; имена)
      вставь(имя, тексты[i]);
  }

  /// Выполняет поиск макроса.
  ///
  /// Если макрос не найден в данной таблице, ищи
  /// продолжает поиск вверх по иерархии таблицы.
  /// Возвращает: найденный макрос или пусто.
  Макрос ищи(ткст имя)
  {
    auto pmacro = имя in таблица;
    if (pmacro)
      return *pmacro;
    if (!корень())
      return родитель.ищи(имя);
    return пусто;
  }

  /// Возвращает: да, если это корень иерархии.
  бул корень()
  { return родитель is пусто; }
}

/// Разбирает текст с определениями макросов.
struct ПарсерМакросов
{
  Макрос[] разбор(ткст текст)
  {
    ПарсерЗначенияИдентификатора парсер;
    auto идзначения = парсер.разбор(текст);
    auto макрос = new Макрос[идзначения.length];
    foreach (i, идзначение; идзначения)
      макрос[i] = new Макрос(идзначение.идент, идзначение.значение);
    return макрос;
  }

  /// Сканирует вызов макроса. Напр.: &#36;(DDOC)
  /// Возвращает: указатель, установленный на один сим после закрывающей скобки,
  /// или пусто, если это не вызов макроса.
  static сим* сканируйМакрос(сим* у, сим* конецТекста)
  {
    assert(*у == '$');
    if (у+2 < конецТекста && у[1] == '(')
    {
      у += 2;
      if (сканируйИдентификатор(у, конецТекста))
      {
        РаскрывательМакросов.сканируйАргументы(у, конецТекста);
        у != конецТекста && у++; // Пропустим ')'.
        return у;
      }
    }
    return пусто;
  }
}

/// Разворачивает макрос ДДок в текст.
struct РаскрывательМакросов
{
  ТаблицаМакросов мтаблица; /// Используется для поиска макроса.
  Диагностика диаг; /// Собирает предупреждающие сообщения.
  ткст путьКФайлу; /// Используется в предупреждающих сообщениях.

  /// Начинает раскрытие макроса.
  static ткст раскрой(ТаблицаМакросов мтаблица, ткст текст, ткст путьКФайлу,
                       Диагностика диаг = пусто)
  {
    РаскрывательМакросов me;
    me.мтаблица = мтаблица;
    me.диаг = диаг;
    me.путьКФайлу = путьКФайлу;
    return me.раскройМакрос(текст);
  }

  /// Выводит предупреждающее сообщение.
  проц  предупреждение(ткст сооб, ткст macroИмя)
  {
    сооб = Формат(сооб, macroИмя);
    if (диаг)
      диаг ~= new Предупреждение(new Положение(путьКФайлу, 0), сооб);
  }

  /// Разворачивает в текст макрос из таблицы.
  ткст раскройМакрос(ткст текст, ткст предшArg0 = пусто/+, бцел depth = 1000+/)
  {
    // if (depth == 0)
    //   return  текст;
    // depth--;
    ткст результат;
    сим* у = текст.ptr;
    сим* конецТекста = у + текст.length;
    сим* конецМакроса = у;
    while (у+3 < конецТекста) // minimum 4 chars: $(x)
    {
      if (*у == '$' && у[1] == '(')
      {
        // Копировать ткст между макрос.
        if (конецМакроса != у)
          результат ~= сделайТекст(конецМакроса, у);
        у += 2;
        if (auto macroИмя = сканируйИдентификатор(у, конецТекста))
        {
          // Получить аргументы.
          auto аргиМакроса = сканируйАргументы(у, конецТекста);
          if (у == конецТекста)
          {
            предупреждение(сооб.НеоконченныйМакросДДок, macroИмя);
            результат ~= "$(" ~ macroИмя ~ " ";
          }
          else
            у++;
          конецМакроса = у; // Point past ')'.

          auto macro_ = мтаблица.ищи(macroИмя);
          if (macro_)
          { // Ignилиe recursive macro if:
            auto macroArg0 = аргиМакроса.length ? аргиМакроса[0] : пусто;
            if (macro_.callLevel != 0 &&
                (аргиМакроса.length == 0/+ || // У макроса нет аргументов.
                 предшArg0 == macroArg0+/)) // macroArg0 equals предшious арг0.
            { continue; }
            macro_.callLevel++;
            // Развенуть аргументы в текст макроса.
            auto развёрнутыйТекст = разверниАргументы(macro_.текст, аргиМакроса);
            результат ~= раскройМакрос(развёрнутыйТекст, macroArg0/+, depth+/);
            macro_.callLevel--;
          }
          else
          {
            предупреждение(сооб.НезаданныйМакросДДок, macroИмя);
            //результат ~= сделайТекст(macroИмя.ptr-2, конецМакроса);
          }
          continue;
        }
      }
      у++;
    }
    if (конецМакроса == текст.ptr)
      return текст; // Макросов не найдено. Итог - оригинальный текст.
    if (конецМакроса < конецТекста)
      результат ~= сделайТекст(конецМакроса, конецТекста);
    return результат;
  }

  /// Сканирует до закрывающей скобки. Устанавливает у на один символ после неё.
  /// Возвращает: [арг0, arg1, arg2 ...].
  static сим[][] сканируйАргументы(ref сим* у, сим* конецТекста)
  out(арги) { assert(арги.length != 1); }
  body
  {
    // D specs: "Текст аргументов может содержать гнездовые скобки,
    //           "" или '' тксты, комментарии, тэги."
    бцел уровень = 1; // Гнездовой уровень скобок.
    сим[][] арги;

    // Пропустить замыкающие пробелы.
    while (у < конецТекста && пбел(*у))
      у++;

    сим* началоАрг0 = у; // Весь список аргументов.
    сим* началоАрга = у;
  ГлавныйЦикл:
    while (у < конецТекста)
    {
      switch (*у)
      {
      case ',':
        if (уровень != 1) // Ignилиe comma if внутри ().
          break;
        // Add a new аргумент.
        арги ~= сделайТекст(началоАрга, у);
        while (++у < конецТекста && пбел(*у)) // Пропустим spaces.
        {}
        началоАрга = у;
        continue;
      case '(':
        уровень++;
        break;
      case ')':
        if (--уровень == 0)
          break ГлавныйЦикл;
        break;
      // Commented out: causes too many problems in the expansion pass.
      // case '"', '\'':
      //   auto с = *у;
      //   while (++у < конецТекста && *у != с) // Scan в следщ " или '.
      //   {}
      //   assert(*у == с || у == конецТекста);
      //   if (у == конецТекста)
      //     break ГлавныйЦикл;
      //   break;
      case '<':
        у++;
        if (у+2 < конецТекста && *у == '!' && у[1] == '-' && у[2] == '-') // <!--
        {
          у += 2; // Point в 2nd '-'.
          // Scan в закрывающий "-->".
          while (++у < конецТекста)
            if (у+2 < конецТекста && *у == '-' && у[1] == '-' && у[2] == '>') {
              у += 2; // Point в '>'.
              break;
            }
        } // <тэг ...> или </тэг>
        else if (у < конецТекста && (буква(*у) || *у == '/'))
          while (++у < конецТекста && *у != '>') // Пропустим в закрывающий '>'.
          {}
        else
          continue ГлавныйЦикл;
        assert(у <= конецТекста);
        if (у == конецТекста)
          break ГлавныйЦикл;
        assert(*у == '>');
        break;
      default:
      }
      у++;
    }
    assert(*у == ')' && уровень == 0 || у == конецТекста);
    if (началоАрг0 == у)
      return пусто;
    // арг0 spans the whole аргумент список.
    auto арг0 = сделайТекст(началоАрг0, у);
    // Add last аргумент.
    арги ~= сделайТекст(началоАрга, у);
    return арг0 ~ арги;
  }

  /// Expands "&#36;+", "&#36;0" - "&#36;9" with арги[n] in текст.
  /// Параметры:
  ///   текст = the текст в сканируй for аргумент placeholders.
  ///   арги = the first element, арги[0], is the whole аргумент ткст and
  ///          the following elements are slices into it.$(BR)
  ///          The массив is empty if there are no arguments.
  ткст разверниАргументы(ткст текст, сим[][] арги)
  in { assert(арги.length != 1, "ожидалось нуль или больше 1 аргумента"); }
  body
  {
    ткст результат;
    сим* у = текст.ptr;
    сим* конецТекста = у + текст.length;
    сим* конецМестодержателя = у;

    while (у+1 < конецТекста)
    {
      if (*у == '$' && (*++у == '+' || цифра(*у)))
      {
        // Copy ткст between аргумент placeholders.
        if (конецМестодержателя != у-1)
          результат ~= сделайТекст(конецМестодержателя, у-1);
        конецМестодержателя = у+1; // Установить new placeholder конец.

        if (арги.length == 0)
          continue;

        if (*у == '+')
        { // $+ = $2 в $n
          if (арги.length > 2)
            результат ~= сделайТекст(арги[2].ptr, арги[0].ptr + арги[0].length);
        }
        else
        { // 0 - 9
          бцел nthArg = *у - '0';
          if (nthArg < арги.length)
            результат ~= арги[nthArg];
        }
      }
      у++;
    }
    if (конецМестодержателя == текст.ptr)
      return текст; // No placeholders found. Итог илиiginal текст.
    if (конецМестодержателя < конецТекста)
      результат ~= сделайТекст(конецМестодержателя, конецТекста);
    return результат;
  }
}
