/// Author: Aziz Köksal
/// License: GPL3
/// $(Maturity very high)
module drc.doc.Parser;

import drc.lexer.Funcs;
import drc.Unicode;
import common;

/// A пара of тксты.
class ЗначениеИдентификатора
{
  ткст идент;
  ткст значение;
  this (ткст идент, ткст значение)
  {
    this.идент = идент;
    this.значение = значение;
  }
}

/// Parses текст in the form of:
/// <pre>
/// идент = значение
/// ident2 = значение2
///          more текст
/// </pre>
struct ПарсерЗначенияИдентификатора
{
  сим* p; /// Current pointer.
  сим* конецТекста;

  /// Parses the текст into a список of IdentValues.
  /// All newlines in текст must be converted в '\n'.
  ЗначениеИдентификатора[] разбор(ткст текст)
  {
    if (!текст.length)
      return null;

    p = текст.ptr;
    конецТекста = p + текст.length;

    ЗначениеИдентификатора[] идзначения;

    ткст идент, следщИдент;
    сим* началоТела = p, началоСледщТела;

    // Init.
    найдиСледщИдент(идент, началоТела);
    // Далее.
    while (найдиСледщИдент(следщИдент, началоСледщТела))
    {
      идзначения ~= new ЗначениеИдентификатора(идент, телоТекста(началоТела, следщИдент.ptr));
      идент = следщИдент;
      началоТела = началоСледщТела;
    }
    // Add last идент значение.
    идзначения ~= new ЗначениеИдентификатора(идент, телоТекста(началоТела, конецТекста));
    return идзначения;
  }

  /// Strips off leading and trailing whitespace characters.
  /// Возвращает: the текст body, or null if empty.
  static сим[] телоТекста(сим* начало, сим* конец)
  {
    while (начало < конец && (пбел_ли(*начало) || *начало == '\n'))
      начало++;
    // The body of A is empty when в.g.:
    // A =
    // B = some текст
    // ^- начало and конец point в B (or в this.конецТекста in the 2nd case.)
    if (начало is конец)
      return null;
    // Remove trailing whitespace.
    while (пбел_ли(*--конец) || *конец == '\n')
    {}
    конец++;
    return сделайТекст(начало, конец);
  }

  /// Finds the следщ "Идентификатор =".
  /// Параметры:
  ///   идент = установи в Идентификатор.
  ///   началоТела = установи в the beginning of the текст body (whitespace пропустиped.)
  /// Возвращает: да if found.
  бул найдиСледщИдент(ref ткст идент, ref сим* началоТела)
  {
    while (p < конецТекста)
    {
      пропустиПробельные();
      if (p is конецТекста)
        break;
      assert(p < конецТекста && (аски_ли(*p) || ведущийБайт_ли(*p)));
      идент = сканируйИдентификатор(p, конецТекста);
      пропустиПробельные();
      if (идент && p < конецТекста && *p == '=')
      {
        началоТела = ++p;
        пропустиСтроку();
        return да;
      }
      пропустиСтроку();
    }
    assert(p is конецТекста);
    return нет;
  }

  проц  пропустиПробельные()
  {
    while (p < конецТекста && пбел_ли(*p))
      p++;
  }

  проц  пропустиСтроку()
  {
    while (p < конецТекста && *p != '\n')
      p++;
    while (p < конецТекста && *p == '\n')
      p++;
  }
}

/// Returns a ткст slice ranging из начало в конец.
сим[] сделайТекст(сим* начало, сим* конец)
{
  assert(начало && конец && начало <= конец);
  return начало[0 .. конец - начало];
}

unittest
{
  выдай("Тестируем drc.doc.Parser.\n");
  сим[] текст = "A =
B = текст
C =
 <b>текст</b>
  D = $(LINK www.drc.com)
E=<
F = G = H
Äş=??
A6İ=µ
End=";

  ЗначениеИдентификатора iv(ткст s1, ткст s2)
  {
    return new ЗначениеИдентификатора(s1, s2);
  }

  auto results = [
    iv("A", ""),
    iv("B", "текст"),
    iv("C", "<b>текст</b>"),
    iv("D", "$(LINK www.drc.com)"),
    iv("E", "<"),
    iv("F", "G = H"),
    iv("Äş", "??"),
    iv("A6İ", "µ"),
    iv("End", ""),
  ];

  auto парсер = ПарсерЗначенияИдентификатора();
  foreach (i, parsed; парсер.разбор(текст))
  {
    auto ожидаемое = results[i];
    assert(parsed.идент == ожидаемое.идент,
           Формат("Парсирован идент '{}', но ожидался '{}'.",
                  parsed.идент, ожидаемое.идент));
    assert(parsed.значение == ожидаемое.значение,
           Формат("Парсировано значение '{}', но ожидался '{}'.",
                  parsed.значение, ожидаемое.значение));
  }
}
