/// Author: Aziz Köksal, Vitaly Kulich
/// License: GPL3
/// $(Maturity very high)
module  drc.ast.Visitor;

import drc.ast.Node,
       drc.ast.Declarations,
       drc.ast.Expressions,
       drc.ast.Statements,
       drc.ast.Types,
       drc.ast.Parameters;

/// Генерирует методы визита.
///
/// Напр.:
/// ---
/// Декларация посети(ДекларацияКласса){return пусто;};
/// Выражение посети(ВыражениеЗапятая){return пусто;};
/// ---
ткст генерируйМетодыВизита()
{
  ткст текст;
  foreach (имяКласса; г_именаКлассов)
    текст ~= "типВозврата!(\""~имяКласса~"\") посети("~имяКласса~" узел){return узел;}\n";
  return текст;
}
// pragma(сооб, generateAbтктactVisitMethods());

/// Получает соответствующий тип возврата для предложенного класса.
template типВозврата(ткст имяКласса)
{
  static if (is(typeof(mixin(имяКласса)) : Декларация))
    alias Декларация типВозврата;
  else
  static if (is(typeof(mixin(имяКласса)) : Инструкция))
    alias Инструкция типВозврата;
  else
  static if (is(typeof(mixin(имяКласса)) : Выражение))
    alias Выражение типВозврата;
  else
  static if (is(typeof(mixin(имяКласса)) : УзелТипа))
    alias УзелТипа типВозврата;
  else
    alias Узел типВозврата;
}

/// Генерирует функции, выполняющие вторичную отправку.
///
/// Напр.:
/// ---
/// Выражение посетиВыражениеЗапятая(Визитёр визитёр, ВыражениеЗапятая с)
/// { визитёр.посети(с); /* Вторичная отправка. */ }
/// ---
/// Эквивалентом в традиционном духе визитёра был бы:
/// ---
/// class ВыражениеЗапятая : Выражение
/// {
///   проц  прими(Визитёр визитёр)
///   { визитёр.посети(this); }
/// }
/// ---
ткст генерируйФункцииОтправки()
{
  ткст текст;
  foreach (имяКласса; г_именаКлассов)
    текст ~= "типВозврата!(\""~имяКласса~"\") посети"~имяКласса~"(Визитёр визитёр, "~имяКласса~" с)\n"
            "{ return визитёр.посети(с); }\n";
  return текст;
}
// pragma(сооб, генерируйФункцииОтправки());

/++
 Генерирует массив указателей на функцию.

 ---
 [
   cast(проц *)&посетиВыражениеЗапятая,
   // и т.д.
 ]
 ---
+/
ткст генерируйВТаблицу()
{
  ткст текст = "[";
  foreach (имяКласса; г_именаКлассов)
    текст ~= "cast(ук)&посети"~имяКласса~",\n";
  return текст[0..$-2]~"]"; // срез away last ",\n"
}
// pragma(сооб, генерируйВТаблицу());

/// Реализует вариацию образца визитёр.
///
/// Наследуется классами, которым нужно обходить синтактическое дерево Ди
/// и выполнять вычисления, трансформации и прочие вещи над ним.
abstract class Визитёр
{
  mixin(генерируйМетодыВизита());

  static
    mixin(генерируйФункцииОтправки());

  //private const _dispatch_vtable = 0;

  // Это необходимо, поскольку компилятор помещает
  // данный массив в сегмент статических данных.
  mixin("private const _dispatch_vtable = " ~ генерируйВТаблицу() ~ ";");

  /// Таблица с указателями на функции второй отправки.
  static const отправь_втаблицу = _dispatch_vtable;
  static assert(отправь_втаблицу.length == г_именаКлассов.length,
                "длина втаблицы не соответствует числу классов");

  /// Ищет функцию второй отправки для n и возвращает её.
  Узел function(Визитёр, Узел) дайФункциюОтправки()(Узел n)
  {
    return cast(Узел function(Визитёр, Узел))отправь_втаблицу[n.вид];
  }

  /// Главная и первая функция отправки.
  Узел отправь(Узел n)
  { // Вторая отправка выполняется в вызванной функции.
    return дайФункциюОтправки(n)(this, n);
  }

final:
  Декларация посети(Декларация n)
  { return посетиД(n); }
  Инструкция посети(Инструкция n)
  { return посетиИ(n); }
  Выражение посети(Выражение n)
  { return посетиВ(n); }
  УзелТипа посети(УзелТипа n)
  { return посетиТ(n); }
  Узел посети(Узел n)
  { return посетиУ(n); }

  Декларация посетиД(Декларация n)
  {
    return cast(Декларация)cast(ук)отправь(n);
  }

  Инструкция посетиИ(Инструкция n)
  {
    return cast(Инструкция)cast(ук)отправь(n);
  }

  Выражение посетиВ(Выражение n)
  {
    return cast(Выражение)cast(ук)отправь(n);
  }

  УзелТипа посетиТ(УзелТипа n)
  {
    return cast(УзелТипа)cast(ук)отправь(n);
  }

  Узел посетиУ(Узел n)
  {
    return отправь(n);
  }
}
