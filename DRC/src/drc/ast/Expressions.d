/// Author: Aziz Köksal
/// License: GPL3
/// $(Maturity high)
module drc.ast.Expressions;

public import drc.ast.Expression;
import drc.ast.Node,
       drc.ast.Types,
       drc.ast.Declarations,
       drc.ast.Statements,
       drc.ast.Parameters,
       drc.ast.NodeCopier;
import drc.lexer.Identifier;
import drc.semantic.Types;
import common;

class НелегальноеВыражение : Выражение
{
  this()
  {
    mixin(установить_вид);
  }
  mixin(методКопирования);
}

abstract class БинарноеВыражение : Выражение
{
  Выражение лв; /// Left-hand сторона выражение.
  Выражение пв; /// Right-hand сторона выражение.
  Сема* лекс;
  this(Выражение лв, Выражение пв, Сема* лекс)
  {
    добавьОтпрыски([лв, пв]);
    this.лв = лв;
    this.пв = пв;
    this.лекс = лекс;
  }
  mixin(бинарноеВыражениеМетодаКопирования);
}

class ВыражениеУсловия : БинарноеВыражение
{
  Выражение условие;
  this(Выражение условие, Выражение левый, Выражение правый, Сема* лекс)
  {
    добавьОтпрыск(условие);
    super(левый, правый, лекс);
    mixin(установить_вид);
    this.условие = условие;
  }
  mixin(методКопирования);
}

class ВыражениеЗапятая : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеИлиИли : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеИИ : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеИли : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеИИли : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеИ : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

abstract class ВыражениеСравни : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
  }
}

class ВыражениеРавно : ВыражениеСравни
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

/// Выражение "!"? "is" Выражение
class ВыражениеРавенство : ВыражениеСравни
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеОтнош : ВыражениеСравни
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеВхо : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеЛСдвиг : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеПСдвиг : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеБПСдвиг : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеПлюс : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеМинус : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеСоедини : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеУмножь : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеДели : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеМод : БинарноеВыражение
{
  this(Выражение левый, Выражение правый, Сема* лекс)
  {
    super(левый, правый, лекс);
    mixin(установить_вид);
  }
}

class ВыражениеПрисвой : БинарноеВыражение
{
  this(Выражение левый, Выражение правый)
  {
    super(левый, правый, null);
    mixin(установить_вид);
  }
}
class ВыражениеПрисвойЛСдвиг : БинарноеВыражение
{
  this(Выражение левый, Выражение правый)
  {
    super(левый, правый, null);
    mixin(установить_вид);
  }
}
class ВыражениеПрисвойПСдвиг : БинарноеВыражение
{
  this(Выражение левый, Выражение правый)
  {
    super(левый, правый, null);
    mixin(установить_вид);
  }
}
class ВыражениеПрисвойБПСдвиг : БинарноеВыражение
{
  this(Выражение левый, Выражение правый)
  {
    super(левый, правый, null);
    mixin(установить_вид);
  }
}
class ВыражениеПрисвойИли : БинарноеВыражение
{
  this(Выражение левый, Выражение правый)
  {
    super(левый, правый, null);
    mixin(установить_вид);
  }
}
class ВыражениеПрисвойИ : БинарноеВыражение
{
  this(Выражение левый, Выражение правый)
  {
    super(левый, правый, null);
    mixin(установить_вид);
  }
}
class ВыражениеПрисвойПлюс : БинарноеВыражение
{
  this(Выражение левый, Выражение правый)
  {
    super(левый, правый, null);
    mixin(установить_вид);
  }
}
class ВыражениеПрисвойМинус : БинарноеВыражение
{
  this(Выражение левый, Выражение правый)
  {
    super(левый, правый, null);
    mixin(установить_вид);
  }
}
class ВыражениеПрисвойДел : БинарноеВыражение
{
  this(Выражение левый, Выражение правый)
  {
    super(левый, правый, null);
    mixin(установить_вид);
  }
}
class ВыражениеПрисвойУмн : БинарноеВыражение
{
  this(Выражение левый, Выражение правый)
  {
    super(левый, правый, null);
    mixin(установить_вид);
  }
}
class ВыражениеПрисвойМод : БинарноеВыражение
{
  this(Выражение левый, Выражение правый)
  {
    super(левый, правый, null);
    mixin(установить_вид);
  }
}
class ВыражениеПрисвойИИли : БинарноеВыражение
{
  this(Выражение левый, Выражение правый)
  {
    super(левый, правый, null);
    mixin(установить_вид);
  }
}
class ВыражениеПрисвойСоед : БинарноеВыражение
{
  this(Выражение левый, Выражение правый)
  {
    super(левый, правый, null);
    mixin(установить_вид);
  }
}

/// ВыражениеТочка := Выражение '.' Выражение
class ВыражениеТочка : БинарноеВыражение
{
  this(Выражение левый, Выражение правый)
  {
    super(левый, правый, null);
    mixin(установить_вид);
  }
}

/*++++++++++++++++++++
+ Unary Expressions: +
++++++++++++++++++++*/

abstract class УнарноеВыражение : Выражение
{
  Выражение в; // TODO: rename 'e' в 'следщ', 'unary', 'выр' or 'sube' etc.
  this(Выражение в)
  {
    добавьОтпрыск(в);
    this.в = в;
  }
  mixin(унарноеВыражениеМетодаКопирования);
}

class ВыражениеАдрес : УнарноеВыражение
{
  this(Выражение в)
  {
    super(в);
    mixin(установить_вид);
  }
}

class ВыражениеПреИнкр : УнарноеВыражение
{
  this(Выражение в)
  {
    super(в);
    mixin(установить_вид);
  }
}

class ВыражениеПреДекр : УнарноеВыражение
{
  this(Выражение в)
  {
    super(в);
    mixin(установить_вид);
  }
}

class ВыражениеПостИнкр : УнарноеВыражение
{
  this(Выражение в)
  {
    super(в);
    mixin(установить_вид);
  }
}

class ВыражениеПостДекр : УнарноеВыражение
{
  this(Выражение в)
  {
    super(в);
    mixin(установить_вид);
  }
}

class ВыражениеДереф : УнарноеВыражение
{
  this(Выражение в)
  {
    super(в);
    mixin(установить_вид);
  }
}

class ВыражениеЗнак : УнарноеВыражение
{
  this(Выражение в)
  {
    super(в);
    mixin(установить_вид);
  }

  бул положит_ли()
  {
    assert(начало !is null);
    return начало.вид == TOK.Плюс;
  }

  бул отриц_ли()
  {
    assert(начало !is null);
    return начало.вид == TOK.Минус;
  }
}

class ВыражениеНе : УнарноеВыражение
{
  this(Выражение в)
  {
    super(в);
    mixin(установить_вид);
  }
}

class ВыражениеКомп : УнарноеВыражение
{
  this(Выражение в)
  {
    super(в);
    mixin(установить_вид);
  }
}

class ВыражениеВызов : УнарноеВыражение
{
  Выражение[] арги;
  this(Выражение в, Выражение[] арги)
  {
    super(в);
    mixin(установить_вид);
    добавьОпцОтпрыски(арги);
    this.арги = арги;
  }
}

class ВыражениеНов : /*Unary*/Выражение
{
  Выражение[] новАрги;
  УзелТипа тип;
  Выражение[] кторАрги;
  this(/*Выражение в, */Выражение[] новАрги, УзелТипа тип, Выражение[] кторАрги)
  {
    /*super(в);*/
    mixin(установить_вид);
    добавьОпцОтпрыски(новАрги);
    добавьОтпрыск(тип);
    добавьОпцОтпрыски(кторАрги);
    this.новАрги = новАрги;
    this.тип = тип;
    this.кторАрги = кторАрги;
  }
  mixin(методКопирования);
}

class ВыражениеНовАнонКласс : /*Unary*/Выражение
{
  Выражение[] новАрги;
  ТипКлассОснова[] основы;
  Выражение[] кторАрги;
  СложнаяДекларация деклы;
  this(/*Выражение в, */Выражение[] новАрги, ТипКлассОснова[] основы, Выражение[] кторАрги, СложнаяДекларация деклы)
  {
    /*super(в);*/
    mixin(установить_вид);
    добавьОпцОтпрыски(новАрги);
    добавьОпцОтпрыски(основы);
    добавьОпцОтпрыски(кторАрги);
    добавьОтпрыск(деклы);

    this.новАрги = новАрги;
    this.основы = основы;
    this.кторАрги = кторАрги;
    this.деклы = деклы;
  }
  mixin(методКопирования);
}

class ВыражениеУдали : УнарноеВыражение
{
  this(Выражение в)
  {
    super(в);
    mixin(установить_вид);
  }
}

class ВыражениеКаст : УнарноеВыражение
{
  УзелТипа тип;
  this(Выражение в, УзелТипа тип)
  {
    добавьОтпрыск(тип); // Add тип before super().
    super(в);
    mixin(установить_вид);
    this.тип = тип;
  }
  mixin(методКопирования);
}

class ВыражениеИндекс : УнарноеВыражение
{
  Выражение[] арги;
  this(Выражение в, Выражение[] арги)
  {
    super(в);
    mixin(установить_вид);
    добавьОтпрыски(арги);
    this.арги = арги;
  }
  mixin(методКопирования);
}

class ВыражениеСрез : УнарноеВыражение
{
  Выражение левый, правый;
  this(Выражение в, Выражение левый, Выражение правый)
  {
    super(в);
    mixin(установить_вид);
    assert(левый ? (правый !is null) : правый is null);
    if (левый)
      добавьОтпрыски([левый, правый]);

    this.левый = левый;
    this.правый = правый;
  }
  mixin(методКопирования);
}

/// Модуль Масштаб operator: '.' (ВыражениеИдентификатор|ВыражениеЭкземплярШаблона)
class ВыражениеМасштабМодуля : УнарноеВыражение
{
  this(Выражение в)
  {
    super(в);
    assert(в.вид == ВидУзла.ВыражениеИдентификатор ||
           в.вид == ВидУзла.ВыражениеЭкземплярШаблона
    );
    mixin(установить_вид);
  }
}

/*++++++++++++++++++++++
+ Primary Expressions: +
++++++++++++++++++++++*/

class ВыражениеИдентификатор : Выражение
{
  Идентификатор* идент;
  this(Идентификатор* идент)
  {
    mixin(установить_вид);
    this.идент = идент;
  }

  Сема* идСема()
  {
    assert(начало !is null);
    return начало;
  }

  mixin(методКопирования);
}

class ВыражениеЭкземплярШаблона : Выражение
{
  Идентификатор* идент;
  АргументыШаблона шарги;
  this(Идентификатор* идент, АргументыШаблона шарги)
  {
    mixin(установить_вид);
    добавьОпцОтпрыск(шарги);
    this.идент = идент;
    this.шарги = шарги;
  }

  Сема* идСема()
  {
    assert(начало !is null);
    return начало;
  }

  mixin(методКопирования);
}

class ВыражениеСпецСема : Выражение
{
  Сема* особаяСема;
  this(Сема* особаяСема)
  {
    mixin(установить_вид);
    this.особаяСема = особаяСема;
  }

  Выражение значение; /// The выражение created in the semantic phase.

  mixin(методКопирования);
}

class ВыражениеЭтот : Выражение
{
  this()
  {
    mixin(установить_вид);
  }
  mixin(методКопирования);
}

class ВыражениеСупер : Выражение
{
  this()
  {
    mixin(установить_вид);
  }
  mixin(методКопирования);
}

class ВыражениеНуль : Выражение
{
  this()
  {
    mixin(установить_вид);
  }

  this(Тип тип)
  {
    this();
    this.тип = тип;
  }

  mixin(методКопирования);
}

class ВыражениеДоллар : Выражение
{
  this()
  {
    mixin(установить_вид);
  }
  mixin(методКопирования);
}

class БулевоВыражение : Выражение
{
  ЦелВыражение значение; /// ЦелВыражение of тип бул.

  this(бул значение)
  {
    mixin(установить_вид);
    // Some semantic computation here.
    this.значение = new ЦелВыражение(значение, Типы.Бул);
    this.тип = Типы.Бул;
  }

  бул вБул()
  {
    assert(начало !is null);
    return начало.вид == TOK.Истина ? да : нет;
  }

  mixin(методКопирования);
}

class ЦелВыражение : Выражение
{
  бдол число;

  this(бдол число, Тип тип)
  {
    mixin(установить_вид);
    this.число = число;
    this.тип = тип;
  }

  this(Сема* сема)
  {
    // Some semantic computation here.
    auto тип = Типы.Цел; // Should be most common case.
    switch (сема.вид)
    {
    // case TOK.Цел32:
    //   тип = Типы.Цел; break;
    case TOK.Бцел32:
      тип = Типы.Бцел; break;
    case TOK.Цел64:
      тип = Типы.Дол; break;
    case TOK.Бцел64:
      тип = Типы.Бдол; break;
    default:
      assert(сема.вид == TOK.Цел32);
    }
    this(сема.бдол_, тип);
  }

  mixin(методКопирования);
}

class ВыражениеРеал : Выражение
{
  реал число;

  this(реал число, Тип тип)
  {
    mixin(установить_вид);
    this.число = число;
    this.тип = тип;
  }

  this(Сема* сема)
  {
    // Some semantic computation here.
    auto тип = Типы.Дво; // Most common case?
    switch (сема.вид)
    {
    case TOK.Плав32:
      тип = Типы.Плав; break;
    // case TOK.Плав64:
    //   тип = Типы.Дво; break;
    case TOK.Плав80:
      тип = Типы.Реал; break;
    case TOK.Мнимое32:
      тип = Типы.Вплав; break;
    case TOK.Мнимое64:
      тип = Типы.Вдво; break;
    case TOK.Мнимое80:
      тип = Типы.Вреал; break;
    default:
      assert(сема.вид == TOK.Плав64);
    }
    this(сема.реал_, тип);
  }

  mixin(методКопирования);
}


/// Этот выражение holds a complex число.
/// It is only created in the semantic phase.
class ВыражениеКомплекс : Выражение
{
  креал число;
  this(креал число, Тип тип)
  {
    mixin(установить_вид);
    this.число = число;
    this.тип = тип;
  }
  mixin(методКопирования);
}

class ВыражениеСим : Выражение
{
  ЦелВыражение значение; // ЦелВыражение of тип Сим/Шим/Дим.
//  дим символ; // Replaced by значение.
  this(дим символ)
  {
    mixin(установить_вид);
//    this.символ = символ;
    // Some semantic computation here.
    if(символ <= 0xFF)
      this.тип = Типы.Сим;
    else if(символ <= 0xFFFF)
      this.тип = Типы.Шим;
    else
      this.тип = Типы.Дим;

    this.значение = new ЦелВыражение(символ, this.тип);
  }
  mixin(методКопирования);
}

class ТекстовоеВыражение : Выражение
{
  ббайт[] ткт;   /// The ткст данные.
  Тип типСим; /// The символ тип of the ткст.

  this(ббайт[] ткт, Тип типСим)
  {
    mixin(установить_вид);
    this.ткт = ткт;
    this.типСим = типСим;
    this.тип = new СМассивТип(типСим, ткт.length);
  }

  this(ткст ткт)
  {
    this(cast(ббайт[])ткт, Типы.Сим);
  }

  this(шим[] ткт)
  {
    this(cast(ббайт[])ткт, Типы.Шим);
  }

  this(дим[] ткт)
  {
    this(cast(ббайт[])ткт, Типы.Дим);
  }

  /// Возвращает ткст excluding the terminating 0.
  ткст дайТекст()
  {
    // TODO: convert в ткст if типСим !is Типы.Сим.
    return cast(сим[])ткт[0..$-1];
  }

  mixin(методКопирования);
}

class ВыражениеЛитералМассива : Выражение
{
  Выражение[] значения;
  this(Выражение[] значения)
  {
    mixin(установить_вид);
    добавьОпцОтпрыски(значения);
    this.значения = значения;
  }
  mixin(методКопирования);
}

class ВыражениеЛитералАМассива : Выражение
{
  Выражение[] ключи, значения;
  this(Выражение[] ключи, Выражение[] значения)
  {
    assert(ключи.length == значения.length);
    mixin(установить_вид);
    foreach (i, key; ключи)
      добавьОтпрыски([key, значения[i]]);
    this.ключи = ключи;
    this.значения = значения;
  }
  mixin(методКопирования);
}

class ВыражениеПодтверди : Выражение
{
  Выражение выр, сооб;
  this(Выражение выр, Выражение сооб)
  {
    mixin(установить_вид);
    добавьОтпрыск(выр);
    добавьОпцОтпрыск(сооб);
    this.выр = выр;
    this.сооб = сооб;
  }
  mixin(методКопирования);
}

class ВыражениеСмесь : Выражение
{
  Выражение выр;
  this(Выражение выр)
  {
    mixin(установить_вид);
    добавьОтпрыск(выр);
    this.выр = выр;
  }
  mixin(методКопирования);
}

class ВыражениеИмпорта : Выражение
{
  Выражение выр;
  this(Выражение выр)
  {
    mixin(установить_вид);
    добавьОтпрыск(выр);
    this.выр = выр;
  }
  mixin(методКопирования);
}

class ВыражениеТипа : Выражение
{
  УзелТипа тип;
  this(УзелТипа тип)
  {
    mixin(установить_вид);
    добавьОтпрыск(тип);
    this.тип = тип;
  }
  mixin(методКопирования);
}

class ВыражениеИдТипаТочка : Выражение
{
  УзелТипа тип;
  Идентификатор* идент;
  this(УзелТипа тип, Идентификатор* идент)
  {
    mixin(установить_вид);
    добавьОтпрыск(тип);
    this.тип = тип;
    this.идент = идент;
  }
  mixin(методКопирования);
}

class ВыражениеИдТипа : Выражение
{
  УзелТипа тип;
  this(УзелТипа тип)
  {
    mixin(установить_вид);
    добавьОтпрыск(тип);
    this.тип = тип;
  }
  mixin(методКопирования);
}

class ВыражениеЯвляется : Выражение
{
  УзелТипа тип;
  Идентификатор* идент;
  Сема* опцСема, спецСема;
  УзелТипа типСпец;
  ПараметрыШаблона шпарамы; // D 2.0
  this(УзелТипа тип, Идентификатор* идент, Сема* опцСема, Сема* спецСема,
       УзелТипа типСпец, typeof(шпарамы) шпарамы)
  {
    mixin(установить_вид);
    добавьОтпрыск(тип);
    добавьОпцОтпрыск(типСпец);
  version(D2)
    добавьОпцОтпрыск(шпарамы);
    this.тип = тип;
    this.идент = идент;
    this.опцСема = опцСема;
    this.спецСема = спецСема;
    this.типСпец = типСпец;
    this.шпарамы = шпарамы;
  }
  mixin(методКопирования);
}

class ВыражениеЛитералФункции : Выражение
{
  УзелТипа типВозврата;
  Параметры парамы;
  ИнструкцияТелаФункции телоФунк;

  this()
  {
    mixin(установить_вид);
    добавьОпцОтпрыск(типВозврата);
    добавьОпцОтпрыск(парамы);
    добавьОтпрыск(телоФунк);
  }

  this(УзелТипа типВозврата, Параметры парамы, ИнструкцияТелаФункции телоФунк)
  {
    this.типВозврата = типВозврата;
    this.парамы = парамы;
    this.телоФунк = телоФунк;
    this();
  }

  this(ИнструкцияТелаФункции телоФунк)
  {
    this.телоФунк = телоФунк;
    this();
  }

  mixin(методКопирования);
}

/// ParenthesisExpression := "(" Выражение ")"
class ВыражениеРодит : Выражение
{
  Выражение следщ;
  this(Выражение следщ)
  {
    mixin(установить_вид);
    добавьОтпрыск(следщ);
    this.следщ = следщ;
  }
  mixin(методКопирования);
}

// version(D2)
// {
class ВыражениеТрактовки : Выражение
{
  Идентификатор* идент;
  АргументыШаблона шарги;
  this(typeof(идент) идент, typeof(шарги) шарги)
  {
    mixin(установить_вид);
    добавьОпцОтпрыск(шарги);
    this.идент = идент;
    this.шарги = шарги;
  }
  mixin(методКопирования);
}
// }

class ВыражениеИницПроц : Выражение
{
  this()
  {
    mixin(установить_вид);
  }
  mixin(методКопирования);
}

class ВыражениеИницМассива : Выражение
{
  Выражение[] ключи;
  Выражение[] значения;
  this(Выражение[] ключи, Выражение[] значения)
  {
    assert(ключи.length == значения.length);
    mixin(установить_вид);
    foreach (i, key; ключи)
    {
      добавьОпцОтпрыск(key); // The key is optional in ArrayInitializers.
      добавьОтпрыск(значения[i]);
    }
    this.ключи = ключи;
    this.значения = значения;
  }
  mixin(методКопирования);
}

class ВыражениеИницСтруктуры : Выражение
{
  Идентификатор*[] иденты;
  Выражение[] значения;
  this(Идентификатор*[] иденты, Выражение[] значения)
  {
    assert(иденты.length == значения.length);
    mixin(установить_вид);
    добавьОпцОтпрыски(значения);
    this.иденты = иденты;
    this.значения = значения;
  }
  mixin(методКопирования);
}

class ВыражениеТипАсм : УнарноеВыражение
{
  this(Выражение в)
  {
    super(в);
    mixin(установить_вид);
  }
}

class ВыражениеСмещениеАсм : УнарноеВыражение
{
  this(Выражение в)
  {
    super(в);
    mixin(установить_вид);
  }
}

class ВыражениеСегАсм : УнарноеВыражение
{
  this(Выражение в)
  {
    super(в);
    mixin(установить_вид);
  }
}

class ВыражениеАсмПослеСкобки : УнарноеВыражение
{
  Выражение e2; /// Выражение in brackets: в [ e2 ]
  this(Выражение в, Выражение e2)
  {
    super(в);
    mixin(установить_вид);
    добавьОтпрыск(e2);
    this.e2 = e2;
  }
  mixin(методКопирования);
}

class ВыражениеАсмСкобка : Выражение
{
  Выражение в;
  this(Выражение в)
  {
    mixin(установить_вид);
    добавьОтпрыск(в);
    this.в = в;
  }
  mixin(методКопирования);
}

class ВыражениеЛокальногоРазмераАсм : Выражение
{
  this()
  {
    mixin(установить_вид);
  }
  mixin(методКопирования);
}

class ВыражениеАсмРегистр : Выражение
{
  Идентификатор* регистр;
  цел число; // ST(0) - ST(7) or FS:0, FS:4, FS:8
  this(Идентификатор* регистр, цел число = -1)
  {
    mixin(установить_вид);
    this.регистр = регистр;
    this.число = число;
  }
  mixin(методКопирования);
}
