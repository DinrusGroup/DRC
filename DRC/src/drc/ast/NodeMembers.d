module drc.ast.NodeЧленs;

import drc.ast.NodesEnum;

private alias ВидУзла N;

ткст генТаблицуЧленов()
{ //pragma(сооб, "генТаблицуЧленов()");
  сим[][][] т = [];
  // т.length = г_именаКлассов.length;
  // Установка длины не работает в CTFs. Над этим нужно работать:
  // FIXME: remove this when dmd issue #2337 has been resolved.
  for (бцел i; i < г_именаКлассов.length; i++)
    т ~= [[]];
  assert(т.length == г_именаКлассов.length);

  т[N.СложнаяДекларация] = ["деклы[]"];
  т[N.ПустаяДекларация] = т[N.НелегальнаяДекларация] =
  т[N.ДекларацияМодуля] = т[N.ДекларацияИмпорта] = [];
  т[N.ДекларацияАлиаса] = т[N.ДекларацияТипдефа] = ["декл"];
  т[N.ДекларацияПеречня] = ["типОснова?", "члены[]"];
  т[N.ДекларацияЧленаПеречня] = ["тип?", "значение?"];
  т[N.ДекларацияКласса] = т[N.ДекларацияИнтерфейса] = ["основы[]", "деклы?"];
  т[N.ДекларацияСтруктуры] = т[N.ДекларацияСоюза] = ["деклы?"];
  т[N.ДекларацияКонструктора] = ["парамы", "телоФунк"];
  т[N.ДекларацияСтатическогоКонструктора] = т[N.ДекларацияДеструктора] =
  т[N.ДекларацияСтатическогоДеструктора] = т[N.ДекларацияИнварианта] =
  т[N.ДекларацияЮниттеста] = ["телоФунк"];
  т[N.ДекларацияФункции] = ["типВозврата?", "парамы", "телоФунк"];
  т[N.ДекларацияПеременных] = ["узелТипа?", "иниты[?]"];
  т[N.ДекларацияОтладки] = т[N.ДекларацияВерсии] = ["деклы?", "деклыИначе?"];
  т[N.ДекларацияСтатическогоЕсли] = ["условие", "деклыЕсли", "деклыИначе?"];
  т[N.ДекларацияСтатическогоПодтверди] = ["условие", "сообщение?"];
  т[N.ДекларацияШаблона] = ["шпарамы", "констрейнт?", "деклы"];
  т[N.ДекларацияНов] = т[N.ДекларацияУдали] = ["парамы", "телоФунк"];
  т[N.ДекларацияЗащиты] = т[N.ДекларацияКлассаХранения] =
  т[N.ДекларацияКомпоновки] = т[N.ДекларацияРазложи] = ["деклы"];
  т[N.ДекларацияПрагмы] = ["арги[]", "деклы"];
  т[N.ДекларацияСмеси] = ["выражШаблон?", "аргумент?"];
  // Выражения:
  т[N.НелегальноеВыражение] = т[N.ВыражениеИдентификатор] =
  т[N.ВыражениеСпецСема] = т[N.ВыражениеЭтот] =
  т[N.ВыражениеСупер] = т[N.ВыражениеНуль] =
  т[N.ВыражениеДоллар] = т[N.БулевоВыражение] =
  т[N.ЦелВыражение] = т[N.ВыражениеРеал] = т[N.ВыражениеКомплекс] =
  т[N.ВыражениеСим] = т[N.ВыражениеИницПроц] =
  т[N.ВыражениеЛокальногоРазмераАсм] = т[N.ВыражениеАсмРегистр] = [];
  // БинарныеВыражения:
  т[N.ВыражениеУсловия] = ["условие", "лв", "пв"];
  т[N.ВыражениеЗапятая] = т[N.ВыражениеИлиИли] = т[N.ВыражениеИИ] =
  т[N.ВыражениеИли] = т[N.ВыражениеИИли] = т[N.ВыражениеИ] =
  т[N.ВыражениеРавно] = т[N.ВыражениеРавенство] = т[N.ВыражениеОтнош] =
  т[N.ВыражениеВхо] = т[N.ВыражениеЛСдвиг] = т[N.ВыражениеПСдвиг] =
  т[N.ВыражениеБПСдвиг] = т[N.ВыражениеПлюс] = т[N.ВыражениеМинус] =
  т[N.ВыражениеСоедини] = т[N.ВыражениеУмножь] = т[N.ВыражениеДели] =
  т[N.ВыражениеМод] = т[N.ВыражениеПрисвой] = т[N.ВыражениеПрисвойЛСдвиг] =
  т[N.ВыражениеПрисвойПСдвиг] = т[N.ВыражениеПрисвойБПСдвиг] =
  т[N.ВыражениеПрисвойИли] = т[N.ВыражениеПрисвойИ] =
  т[N.ВыражениеПрисвойПлюс] = т[N.ВыражениеПрисвойМинус] =
  т[N.ВыражениеПрисвойДел] = т[N.ВыражениеПрисвойУмн] =
  т[N.ВыражениеПрисвойМод] = т[N.ВыражениеПрисвойИИли] =
  т[N.ВыражениеПрисвойСоед] = т[N.ВыражениеТочка] = ["лв", "пв"];
  // УнарныеВыражения:
  т[N.ВыражениеАдрес] = т[N.ВыражениеПреИнкр] = т[N.ВыражениеПреДекр] =
  т[N.ВыражениеПостИнкр] = т[N.ВыражениеПостДекр] = т[N.ВыражениеДереф] =
  т[N.ВыражениеЗнак] = т[N.ВыражениеНе] = т[N.ВыражениеКомп] =
  т[N.ВыражениеВызов] = т[N.ВыражениеУдали] = т[N.ВыражениеМасштабМодуля] =
  т[N.ВыражениеТипАсм] = т[N.ВыражениеСмещениеАсм] =
  т[N.ВыражениеСегАсм] = ["в"];
  т[N.ВыражениеКаст] = ["тип", "в"];
  т[N.ВыражениеИндекс] = ["в", "арги[]"];
  т[N.ВыражениеСрез] = ["в", "левый?", "правый?"];
  т[N.ВыражениеАсмПослеСкобки] = ["в", "e2"];
  т[N.ВыражениеНов] = ["новАрги[]", "тип", "кторАрги[]"];
  т[N.ВыражениеНовАнонКласс] = ["новАрги[]", "основы[]", "кторАрги[]", "деклы"];
  т[N.ВыражениеАсмСкобка] = ["в"];
  т[N.ВыражениеЭкземплярШаблона] = ["шарги?"];
  т[N.ВыражениеЛитералМассива] = ["значения[]"];
  т[N.ВыражениеЛитералАМассива] = ["ключи[]", "значения[]"];
  т[N.ВыражениеПодтверди] = ["выр", "сооб?"];
  т[N.ВыражениеСмесь] = т[N.ВыражениеИмпорта] = ["выр"];
  т[N.ВыражениеТипа] = т[N.ВыражениеИдТипаТочка] =
  т[N.ВыражениеИдТипа] = ["тип"];
  т[N.ВыражениеЯвляется] = ["тип", "типСпец?", "шпарамы?"];
  т[N.ВыражениеЛитералФункции] = ["типВозврата?", "парамы?", "телоФунк"];
  т[N.ВыражениеРодит] = ["следщ"];//paren
  т[N.ВыражениеТрактовки] = ["шарги"];//traits
  т[N.ВыражениеИницМассива] = ["ключи[?]", "значения[]"];
  т[N.ВыражениеИницСтруктуры] = ["значения[]"];
  т[N.ТекстовоеВыражение] = [],
  // Инструкции:
  т[N.НелегальнаяИнструкция] = т[N.ПустаяИнструкция] =
  т[N.ИнструкцияДалее] = т[N.ИнструкцияВсё] =//break
  т[N.ИнструкцияАсмРасклад] = т[N.ИнструкцияНелегальныйАсм] = [];
  т[N.СложнаяИнструкция] = ["инстрции[]"];
  т[N.ИнструкцияТелаФункции] = ["телоФунк?", "телоВхо?", "телоВых?"];
  т[N.ИнструкцияМасштаб] = т[N.ИнструкцияСМеткой] = ["s"];
  т[N.ИнструкцияВыражение] = ["в"];
  т[N.ИнструкцияДекларация] = ["декл"];
  т[N.ИнструкцияЕсли] = ["переменная?", "условие?", "телоЕсли", "телоИначе?"];
  т[N.ИнструкцияПока] = ["условие", "телоПока"];
  т[N.ИнструкцияДелайПока] = ["телоДелай", "условие"];
  т[N.ИнструкцияПри] = ["иниц?", "условие?", "инкремент?", "телоПри"];//for
  т[N.ИнструкцияСКаждым] = ["парамы", "агрегат", "телоПри"];
  т[N.ИнструкцияДиапазонСКаждым] = ["парамы", "нижний", "верхний", "телоПри"];
  т[N.ИнструкцияЩит] = ["условие", "телоЩит"];
  т[N.ИнструкцияРеле] = ["значения[]", "телоРеле"];
  т[N.ИнструкцияДефолт] = ["телоДефолта"];
  т[N.ИнструкцияИтог] = ["в?"];
  т[N.ИнструкцияПереход] = ["вырРеле?"];
  т[N.ИнструкцияДля] = ["в", "телоДля"];//with
  т[N.ИнструкцияСинхр] = ["в?", "телоСинхр"];//synchronized
  т[N.ИнструкцияПробуй] = ["телоПробуй", "телаЛови[]", "телоИтожь?"];//try
  т[N.ИнструкцияЛови] = ["парам?", "телоЛови"];//catch
  т[N.ИнструкцияИтожь] = ["телоИтожь"];//finally
  т[N.ИнструкцияСтражМасштаба] = ["телоМасштаба"];
  т[N.ИнструкцияБрось] = ["в"];
  т[N.ИнструкцияЛетучее] = ["телоЛетучего?"];//volatile
  т[N.ИнструкцияБлокАсм] = ["инструкции"];
  т[N.ИнструкцияАсм] = ["операнды[]"];
  т[N.ИнструкцияПрагма] = ["арги[]", "телоПрагмы"];
  т[N.ИнструкцияСмесь] = ["выражШаблон"];
  т[N.ИнструкцияСтатическоеЕсли] = ["условие", "телоЕсли", "телоИначе?"];
  т[N.ИнструкцияСтатическоеПодтверди] = ["условие", "сообщение?"];
  т[N.ИнструкцияОтладка] = т[N.ИнструкцияВерсия] = ["телоГлавного", "телоИначе?"];
  // УзлыТипов:
  т[N.НелегальныйТип] = т[N.ИнтегральныйТип] =
  т[N.ТМасштабМодуля] = т[N.ТИдентификатор] = [];
  т[N.КвалифицированныйТип] = ["лв", "пв"];
  т[N.ТТип] = ["в"];
  т[N.ТЭкземплярШаблона] = ["шарги?"];
  т[N.ТМассив] = ["следщ", "ассоцТип?", "e1?", "e2?"];
  т[N.ТФункция] = т[N.ТДелегат] = ["типВозврата", "парамы"];
  т[N.ТУказательНаФункСи] = ["следщ", "парамы?"];
  т[N.ТУказатель] = т[N.ТипКлассОснова] =
  т[N.ТКонст] = т[N.ТИнвариант] = ["следщ"];
  // Параметры:
  т[N.Параметр] = ["тип?", "дефЗначение?"];
  т[N.Параметры] = т[N.ПараметрыШаблона] =
  т[N.АргументыШаблона] = ["отпрыски[]"];
  т[N.ПараметрАлиасШаблона] = т[N.ПараметрТипаШаблона] =
  т[N.ПараметрЭтотШаблона] = ["типСпец?", "дефТип?"];
  т[N.ПараметрШаблонЗначения] = ["типЗначение", "спецЗначение?", "дефЗначение?"];
  т[N.ПараметрКортежШаблона] = [];

  ткст код = "[";
  // Итерировать по элементам в таблице и создать массив.
  foreach (m; т)
  {
    if (!m.length) {
      код ~= "[],";
      continue; // Нет членов, добавить "[]," и продолжить.
    }
    код ~= '[';
    foreach (n; m)
      код ~= `"` ~ n ~ `",`;
    код[код.length-1] = ']'; // Переписать последнюю запятую.
    код ~= ',';
  }
  код[код.length-1] = ']'; // Переписать последнюю запятую.
  return код;
}

/// Таблица со списком всех субмодулей всех классов, наследующих от Узел.
static const сим[][][/+ВидУзла.max+1+/] г_таблицаЧленов = mixin(генТаблицуЧленов());

/// Вспомогательная функция, разбирающая особые тксты в г_таблицаЧленов.
///
/// Базовый синтаксис:
/// $(PRE
/// Член := Массив | Массив2 | ОпционныйУзел | Узел | Код
/// Массив := Идентификатор "[]"
/// Массив2 := Идентификатор "[?]"
/// ОпционныйУзел := Идентификатор "?"
/// Узел := Идентификатор
/// Код := "%" ЛюбойСим*
/// $(MODLINK2 drc.lexer.Identifier, Идентификатор)
/// )
/// Параметры:
///   члены = разбираемые член-тксты.
/// Возвращает:
///   массив кортежей (Имя, Тип), где Имя - точное имя члена
///   а Тип может быть одним из таких значений: "[]", "[?]", "?", "" или "%".
сим[][2][] разборЧленов(сим[][] члены)
{
  сим[][2][] результат;
  foreach (член; члены)
    if (член.length > 2 && член[$-2..$] == "[]")
      результат ~= [член[0..$-2], "[]"]; // Убрать завершающее '[]'.
    else if (член.length > 3 && член[$-3..$] == "[?]")
      результат ~= [член[0..$-3], "[?]"]; // Убрать завершающее '[?]'.
    else if (член[$-1] == '?')
      результат ~= [член[0..$-1], "?"]; // Убрать завершающее '?'.
    else if (член[0] == '%')
      результат ~= [член[1..$], "%"]; // Убрать предшествующее '%'.
    else
      результат ~= [член, ""]; //Убирать нечего.
  return результат;
}
