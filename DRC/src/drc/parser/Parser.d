/// Author: Aziz Köksal
/// License: GPL3
/// $(Maturity very high)
module drc.parser.Parser;

import drc.lexer.Lexer,
       drc.lexer.IdTable;
import drc.ast.Node,
       drc.ast.Declarations,
       drc.ast.Statements,
       drc.ast.Expressions,
       drc.ast.Types,
       drc.ast.Parameters;
import drc.Messages;
import drc.Diagnostics;
import drc.Enums;
import drc.CompilerInfo;
import drc.SourceText;
import drc.Unicode;
import common;

import core.Vararg;

/// Парсер производит полный разбор дерева путём исследования
/// списка сем, предоставляемого Лексером.
class Парсер
{
  Лексер лексер; /// Используется для "лексирования" исходного кода.
  Сема* сема; /// Текущая непробельная сема.
  Сема* предыдущСема; /// Предыдущая непробельная сема.

  Диагностика диаг;
  ОшибкаПарсера[] ошибки; /// Массив сообщений об ошибках парсера.

  ДекларацияИмпорта[] импорты; /// ДекларацииИмпорта в исходном тексте.

  /// Атрибуты оцениваются на фазе парсирования.
  /// TODO: будет удалено. СемантическаяПроходка1 прозводит обработку атрибутов.
  ТипКомпоновки типКомпоновки;
  Защита защита; /// определено
  КлассХранения классХранения; /// определено
  бцел размерРаскладки = РАЗМЕР_РАСКЛАДКИ_ПО_УМОЛЧАНИЮ; /// определено

  private alias TOK T; /// Часто используется данным классом.
  private alias УзелТипа Тип;

  /// Строит объект Парсер.
  /// Параметры:
  ///   исхТекст = the UTF-8 source код.
  ///   диаг = используется для сбора сообщений об ошибке.
  this(ИсходныйТекст исхТекст, Диагностика диаг = null)
  {
    this.диаг = диаг;
    лексер = new Лексер(исхТекст, диаг);
  }

  /// Переходит к первой семе.
  protected проц  иниц()
  {
    далее();
    предыдущСема = сема;
  }

  /// Переходит к следующей семе.
  проц  далее()
  {
    предыдущСема = сема;
    do
    {
      лексер.следщСема();
      сема = лексер.сема;
    } while (сема.пробел_ли) // Skip whitespace
  }

  /// Запускает парсер и возвращает парсированные декларации.
  СложнаяДекларация старт()
  {
    иниц();
    auto начало = сема;
    auto деклы = new СложнаяДекларация;
    if (сема.вид == T.Модуль)
      деклы ~= разборДекларацииМодуля();
    деклы.добавьОпцОтпрыски(разборДефиницииДеклараций());
    установи(деклы, начало);
    return деклы;
  }

  /// Запускает парсер и возвращает парсированные выражения.
  Выражение старт2()
  {
    иниц();
    return разборВыражения();
  }

  // Members related в the method пробуй_().
  бцел пробуем; /// Больше than 0 if Парсер is in пробуй_().
  бцел счётОшибок; /// Используется для отслеживания числа ошибок при обороте пробуй_().

  /// Этот method executes the delegate методРазбора and when an ошибка occurred
  /// the state of the лексер and парсер is restored.
  /// Возвращает: the return значение of методРазбора().
  ТипИтога пробуй_(ТипИтога)(ТипИтога delegate() методРазбора, out бул успех)
  {
    // Save члены.
    auto старСема     = this.сема;
    auto старПредшСема = this.предыдущСема;
    auto старСчёт     = this.счётОшибок;

    ++пробуем;
    auto результат = методРазбора();
    --пробуем;
    // Check if an ошибка occurred.
    if (счётОшибок != старСчёт)
    { // Restore члены.
      сема       = старСема;
      предыдущСема   = старПредшСема;
      лексер.сема = старСема;
      счётОшибок  = старСчёт;
      успех = нет;
    }
    else
      успех = да;
    return результат;
  }

  /// Вызывает неудачное завершение текущего вызова пробуй_().
  проц  провал_пробы()
  {
    assert(пробуем);
    счётОшибок++;
  }

  /// Устанавливает начало и конец семы узла синтактического древа.
  Класс установи(Класс)(Класс узел, Сема* начало)
  {
    узел.установиСемы(начало, this.предыдущСема);
    return узел;
  }

  ///Устанавливает начало и конец семы узла синтактического древа.
  Класс установи(Класс)(Класс узел, Сема* начало, Сема* конец)
  {
    узел.установиСемы(начало, конец);
    return узел;
  }

  /// Returns да if установи() has been called on a узел.
  static бул узелУстановлен(Узел узел)
  {
    return узел.начало !is null && узел.конец !is null;
  }

  /// Возвращает вид следующей семы.
  TOK возьмиСледщ()
  {
    Сема* следщ = сема;
    do
      лексер.возьми(следщ);
    while (следщ.пробел_ли) // Skip whitespace
    return следщ.вид;
  }

  /// Возвращает род семы, следующей за t.
  TOK возьмиПосле(ref Сема* t)
  {
    assert(t !is null);
    do
      лексер.возьми(t);
    while (t.пробел_ли) // Skip whitespace
    return t.вид;
  }

  /// Проверяет теущую сему на соответствие k по виду и возвращает да.
  бул проверено()(TOK k) // Templatized, so it's inlined.
  {
    return сема.вид == k ? (далее(), да) : нет;
  }

  /// Проверяет, чтобы текущая сема была ожидаемого вида,
  /// затем приступает за следующую сему.
  проц  пропусти()(TOK ожидаемыйВид)
  {
    assert(сема.вид == ожидаемыйВид /+|| *(цел*).иниц+/, сема.исхТекст());
    далее();
  }

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                       Методы парсинга деклараций                         |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

  Декларация разборДекларацииМодуля()
  {
    auto начало = сема;
    пропусти(T.Модуль);
    ПКИМодуля пкиМодуля;
    do
      пкиМодуля ~= требуетсяИдентификатор(сооб.ОжидалсяИдентификаторМодуля);
    while (проверено(T.Точка))
    требуется(T.ТочкаЗапятая);
    return установи(new ДекларацияМодуля(пкиМодуля), начало);
  }

  /// Парсирует "Дефиниции Деклараций" (определения объявлений) до конца файла.
  /// $(PRE
  /// DeclDefs :=
  ///     DeclDef
  ///     DeclDefs
  /// )
  Декларация[] разборДефиницииДеклараций()
  {
    Декларация[] деклы;
    while (сема.вид != T.КФ)
      деклы ~= разборДефиницииДекларации();
    return деклы;
  }

  /// Парсирует тело шаблона, класса, интерфейса структуры или союза.
  /// $(PRE
  /// DeclDefsBlock :=
  ///     { }
  ///     { DeclDefs }
  /// )
  СложнаяДекларация разборТелаДефиницииДекларации()
  {
    // Save attributes.
    auto типКомпоновки  = this.типКомпоновки;
    auto защита   = this.защита;
    auto классХранения = this.классХранения;
    // Clear attributes.
    this.типКомпоновки  = ТипКомпоновки.Нет;
    this.защита   = Защита.Нет;
    this.классХранения = КлассХранения.Нет;

    // Parse body.
    auto начало = сема;
    auto деклы = new СложнаяДекларация;
    требуется(T.ЛФСкобка);
    while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
      деклы ~= разборДефиницииДекларации();
    требуетсяЗакрыв(T.ПФСкобка, начало);
    установи(деклы, начало);

    // Restore original значения.
    this.типКомпоновки  = типКомпоновки;
    this.защита   = защита;
    this.классХранения = классХранения;

    return деклы;
  }

  /// Парсирует ДефиницияДекларации.
  Декларация разборДефиницииДекларации()
  out(декл)
  { assert(узелУстановлен(декл)); }
  body
  {
    auto начало = сема;
    Декларация декл;
    switch (сема.вид)
    {
    case T.Расклад,
         T.Прагма,
         // Защита attributes
         T.Экспорт,
         T.Приватный,
         T.Пакет,
         T.Защищённый,
         T.Публичный:
      декл = разборИдентификатораАтрибута();
      break;
    // Storage classes
    case T.Экстерн,
         T.Устаревший,
         T.Перепись,
         T.Абстрактный,
         T.Синхронизованный,
         //T.Статический,
         T.Окончательный,
         T.Конст,
         //T.Инвариант, // D 2.0
         T.Авто,
         T.Масштаб:
    случай_СтатичАтрибут:
    случай_АтрибутИнвариант: // D 2.0
    случай_АтрибутПеречень: // D 2.0
      return разборАтрибутаСохранения();
    case T.Алиас:
      далее();
      декл = new ДекларацияАлиаса(разборПеременнойИлиФункции());
      break;
    case T.Типдеф:
      далее();
      декл = new ДекларацияТипдефа(разборПеременнойИлиФункции());
      break;
    case T.Статический:
      switch (возьмиСледщ())
      {
      case T.Импорт:
        goto случай_Импорт;
      case T.Этот:
        декл = разборДекларацииСтатичКонструктора();
        break;
      case T.Тильда:
        декл = разборДекларацииСтатичДеструктора();
        break;
      case T.Если:
        декл = парсируйДекларациюСтатичЕсли();
        break;
      case T.Подтвердить:
        декл = парсируйДекларациюСтатичАссерта();
        break;
      default:
        goto случай_СтатичАтрибут;
      }
      break;
    case T.Импорт:
    случай_Импорт:
      декл = разборДекларацииИмпорта();
      импорты ~= декл.в!(ДекларацияИмпорта);
      // Handle specially. КлассХранения mustn't be установи.
      декл.установиЗащиту(this.защита);
      return установи(декл, начало);
    case T.Перечень:
    version(D2)
    {
      if (манифестПеречня_ли())
        goto случай_АтрибутПеречень;
    }
      декл = разборДекларацииПеречня();
      break;
    case T.Класс:
      декл = разборДекларацииКласса();
      break;
    case T.Интерфейс:
      декл = разборДекларацииИнтерфейса();
      break;
    case T.Структура, T.Союз:
      декл = разборДекларацииСтруктурыИлиСоюза();
      break;
    case T.Этот:
      декл = разборДекларацииКонструктора();
      break;
    case T.Тильда:
      декл = разборДекларацииДеструктора();
      break;
    case T.Инвариант:
    version(D2)
    {
      auto следщ = сема;
      if (возьмиПосле(следщ) == T.ЛСкобка)
      {
        if (возьмиПосле(следщ) != T.ПСкобка)
          goto случай_Декларация;  // invariant ( Тип )
      }
      else
        goto случай_АтрибутИнвариант; // invariant as КлассХранения.
    }
      декл = разборДекларацииИнварианта(); // invariant ( )
      break;
    case T.Юниттест:
      декл = разборДекларацииЮниттеста();
      break;
    case T.Отладка:
      декл = разборДекларацииОтладки();
      break;
    case T.Версия:
      декл = парсируйДекларациюВерсии();
      break;
    case T.Шаблон:
      декл = парсируйДекларациюШаблона();
      break;
    case T.Нов:
      декл = парсируйДекларациюНов();
      break;
    case T.Удалить:
      декл = парсируйДекларациюУдалить();
      break;
    case T.Смесь:
      декл = парсируйМиксин!(ДекларацияСмеси)();
      break;
    case T.ТочкаЗапятая:
      далее();
      декл = new ПустаяДекларация();
      break;
    // Декларация
    case T.Идентификатор, T.Точка, T.Типа:
    случай_Декларация:
      return разборПеременнойИлиФункции(this.классХранения, this.защита, this.типКомпоновки);
    default:
      if (сема.интегральныйТип_ли)
        goto случай_Декларация;
      else if (сема.вид == T.Модуль)
      {
        декл = разборДекларацииМодуля();
        ошибка(начало, сооб.ДекларацияМодуляНеПервая);
        return декл;
      }

      декл = new НелегальнаяДекларация();
      // Skip в следщ valid сема.
      do
        далее();
      while (!сема.началоДефДекл_ли &&
              сема.вид != T.ПФСкобка &&
              сема.вид != T.КФ)
      auto текст = Сема.textSpan(начало, this.предыдущСема);
      ошибка(начало, сооб.НелегальнаяДекларация, текст);
    }
    декл.установиЗащиту(this.защита);
    декл.установиКлассХранения(this.классХранения);
    assert(!узелУстановлен(декл));
    установи(декл, начало);
    return декл;
  }

  /// Parses a DeclarationsBlock.
  /// $(PRE
  /// DeclarationsBlock :=
  ///     : DeclDefs
  ///     { }
  ///     { DeclDefs }
  ///     DeclDef
  /// )
  Декларация разборБлокаДеклараций(/+бул noДвоеточие = нет+/)
  {
    Декларация d;
    switch (сема.вид)
    {
    case T.ЛФСкобка:
      auto начало = сема;
      далее();
      auto деклы = new СложнаяДекларация;
      while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
        деклы ~= разборДефиницииДекларации();
      требуетсяЗакрыв(T.ПФСкобка, начало);
      d = установи(деклы, начало);
      break;
    case T.Двоеточие:
      // if (noДвоеточие == да)
      //   goto default;
      далее();
      auto начало = сема;
      auto деклы = new СложнаяДекларация;
      while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
        деклы ~= разборДефиницииДекларации();
      d = установи(деклы, начало);
      break;
    default:
      d = разборДефиницииДекларации();
    }
    assert(узелУстановлен(d));
    return d;
  }

  // Декларация разборБлокаДекларацийNoДвоеточие()
  // {
  //   return разборБлокаДеклараций(да);
  // }

  /// Parses either a ДекларацияПеременной or a ДекларацияФункции.
  /// Параметры:
  ///   кхр = предшiously parsed storage classes
  ///   защита = предшiously parsed защита attribute
  ///   типКомпоновки = предшiously parsed linkage тип
  ///   testAutoDeclaration = whether в check for an ДекларацияАвто
  ///   optionalParameterList = a hint for how в разбор C-style function pointers
  Декларация разборПеременнойИлиФункции(КлассХранения кхр = КлассХранения.Нет,
                                      Защита защита = Защита.Нет,
                                      ТипКомпоновки типКомпоновки = ТипКомпоновки.Нет,
                                      бул testAutoDeclaration = нет,
                                      бул optionalParameterList = да)
  {
    auto начало = сема;
    Тип тип;
    Идентификатор* имя;

    // Check for ДекларацияАвто: КлассыСохранения Идентификатор =
    if (testAutoDeclaration && сема.вид == T.Идентификатор)
    {
      auto вид = возьмиСледщ();
      if (вид == T.Присвоить)
      { // Авто переменная declaration.
        имя = сема.идент;
        пропусти(T.Идентификатор);
        goto LparseVariables;
      }
      else version(D2) if (вид == T.ЛСкобка)
      { // Check for auto return тип template function.
        // КлассыСохранения Name ( TemplateParameterList ) ( ParameterList )
        имя = сема.идент;
        auto следщ = сема;
        возьмиПосле(следщ);
        if (семаПослеСкобкиЯвляется(T.ЛСкобка, следщ))
        {
          пропусти(T.Идентификатор);
          assert(сема.вид == T.ЛСкобка);
          goto LparseTPList; // Далее with parsing a template function.
        }
      }
    }

    тип = разборТипа(); // VariableType or ТипИтога

    if (сема.вид == T.ЛСкобка)
    { // Указатели на функции в стиле Си усложняют грамматику.
      // С ними приходится иметь дело отдельно, в масштабе функции.
      // Пример:
      //   проц  foo() {
      //     // Указатель на функцию, принимающий целое число и возвращающий 'some_type'.
      //     some_type (*p_func)(цел);
      //     // Вхо the following case precedence is given в a ВыражениеВызов.
      //     something(*p); // 'something' may be a function/method or an объект having opCall overloaded.
      //   }
      //   // A pointer в a function taking no параметры and returning 'something'.
      //   something(*p);
      тип = разборТипаУказательНаФункциюСи(тип, имя, optionalParameterList);
    }
    else if (возьмиСледщ() == T.ЛСкобка)
    { // Тип FunctionName ( ParameterList ) FunctionBody
      имя = требуетсяИдентификатор(сооб.ОжидалосьНазваниеФункции);
      имя || далее(); // Skip non-identifier сема.
      assert(сема.вид == T.ЛСкобка);
      // It's a function declaration
      ПараметрыШаблона шпарамы;
      Выражение констрейнт;

      if (семаПослеСкобкиЯвляется(T.ЛСкобка))
      LparseTPList:
        // ( TemplateParameterList ) ( ParameterList )
        шпарамы = разборСпискаПараметровШаблона();

      auto парамы = разборСпискаПараметров();
    version(D2)
    {
      if (шпарамы) // Если ( ConstraintExpression )
        констрейнт = разборДополнительногоКонстрейнта();
      switch (сема.вид)
      {
      case T.Конст:
        кхр |= КлассХранения.Конст;
        далее();
        break;
      case T.Инвариант:
        кхр |= КлассХранения.Инвариант;
        далее();
        break;
      default:
      }
    }
      // ТипИтога FunctionName ( ParameterList )
      auto телоФунк = разборТелаФункции();
      auto дф = new ДекларацияФункции(тип, имя,/+ шпарамы,+/ парамы, телоФунк);
      дф.установиКлассХранения(кхр);
      дф.установиТипКомпоновки(типКомпоновки);
      дф.установиЗащиту(защита);
      if (шпарамы)
      {
        auto d = поместиДекларациюВнутреннегоШаблона(начало, имя, дф, шпарамы, констрейнт);
        d.установиКлассХранения(кхр);
        d.установиЗащиту(защита);
        return установи(d, начало);
      }
      return установи(дф, начало);
    }
    else
    { // Тип VariableName DeclaratorSuffix
      имя = требуетсяИдентификатор(сооб.ОжидалосьНазваниеПеременной);
      тип = разборСуффиксаДекларатора(тип);
    }

  LparseVariables:
    // It's a переменные declaration.
    Идентификатор*[] имена = [имя]; // One identifier has been parsed already.
    Выражение[] значения;
    goto LenterLoop; // Enter the loop and check for an initializer.
    while (проверено(T.Запятая))
    {
      имена ~= требуетсяИдентификатор(сооб.ОжидалосьНазваниеПеременной);
    LenterLoop:
      if (проверено(T.Присвоить))
        значения ~= разборИнициализатора();
      else
        значения ~= null;
    }
    требуется(T.ТочкаЗапятая);
    auto d = new ДекларацияПеременных(тип, имена, значения);
    d.установиКлассХранения(кхр);
    d.установиТипКомпоновки(типКомпоновки);
    d.установиЗащиту(защита);
    return установи(d, начало);
  }

  /// Parses a переменная initializer.
  Выражение разборИнициализатора()
  {
    if (сема.вид == T.Проц)
    {
      auto начало = сема;
      auto следщ = возьмиСледщ();
      if (следщ == T.Запятая || следщ == T.ТочкаЗапятая)
      {
        пропусти(T.Проц);
        return установи(new ВыражениеИницПроц(), начало);
      }
    }
    return разборНеПроцИнициализатора();
  }

  Выражение разборНеПроцИнициализатора()
  {
    auto начало = сема;
    Выражение иниц;
    switch (сема.вид)
    {
    case T.ЛКвСкобка:
      // ArrayInitializer:
      //         [ ]
      //         [ ArrayMemberInitializations ]
      Выражение[] ключи;
      Выражение[] значения;

      пропусти(T.ЛКвСкобка);
      while (сема.вид != T.ПКвСкобка)
      {
        auto в = разборНеПроцИнициализатора();
        if (проверено(T.Двоеточие))
        {
          ключи ~= в;
          значения ~= разборНеПроцИнициализатора();
        }
        else
        {
          ключи ~= null;
          значения ~= в;
        }

        if (!проверено(T.Запятая))
          break;
      }
      требуетсяЗакрыв(T.ПКвСкобка, начало);
      иниц = new ВыражениеИницМассива(ключи, значения);
      break;
    case T.ЛФСкобка:
      // StructInitializer:
      //         { }
      //         { StructMemberInitializers }
      Выражение разборИнициализатораСтрукт()
      {
        Идентификатор*[] idents;
        Выражение[] значения;

        пропусти(T.ЛФСкобка);
        while (сема.вид != T.ПФСкобка)
        {
          if (сема.вид == T.Идентификатор &&
              // Peek for colon в see if this is a член identifier.
              возьмиСледщ() == T.Двоеточие)
          {
            idents ~= сема.идент;
            пропусти(T.Идентификатор), пропусти(T.Двоеточие);
          }
          else
            idents ~= null;

          // NonVoidInitializer
          значения ~= разборНеПроцИнициализатора();

          if (!проверено(T.Запятая))
            break;
        }
        требуетсяЗакрыв(T.ПФСкобка, начало);
        return new ВыражениеИницСтрукуры(idents, значения);
      }

      бул успех;
      auto si = пробуй_(&разборИнициализатораСтрукт, успех);
      if (успех)
      {
        иниц = si;
        break;
      }
      assert(сема.вид == T.ЛФСкобка);
      //goto default;
    default:
      иниц = разборВыраженияПрисвой();
    }
    установи(иниц, начало);
    return иниц;
  }

  ИнструкцияТелаФункции разборТелаФункции()
  {
    auto начало = сема;
    auto func = new ИнструкцияТелаФункции;
    while (1)
    {
      switch (сема.вид)
      {
      case T.ЛФСкобка:
        func.телоФунк = разборИнструкций();
        break;
      case T.ТочкаЗапятая:
        далее();
        break;
      case T.Вхо:
        if (func.телоВхо)
          ошибка(ИДС.КонтрактИн);
        далее();
        func.телоВхо = разборИнструкций();
        continue;
      case T.Вых:
        if (func.телоВых)
          ошибка(ИДС.КонтрактАут);
        далее();
        if (проверено(T.ЛСкобка))
        {
          auto leftParen = this.предыдущСема;
          func.outIdent = требуетсяИдентификатор(сооб.ОжидалсяИдентификатор);
          требуетсяЗакрыв(T.ПСкобка, leftParen);
        }
        func.телоВых = разборИнструкций();
        continue;
      case T.Тело:
        далее();
        goto case T.ЛФСкобка;
      default:
        ошибка2(сооб.ОжидалосьТелоФункции, сема);
      }
      break; // Exit loop.
    }
    установи(func, начало);
    func.завершиКонструкцию();
    return func;
  }

  ТипКомпоновки разборТипаКомпоновки()
  {
    ТипКомпоновки типКомпоновки;

    if (!проверено(T.ЛСкобка))
      return типКомпоновки;

    if (проверено(T.ПСкобка))
    { // extern()
      ошибка(ИДС.MissingLinkageType);
      return типКомпоновки;
    }

    auto identTok = требуетсяИд();

    ВИД видИд = identTok ? identTok.идент.видИд : ВИД.Нуль;

    switch (видИд)
    {
    case ВИД.C:
      if (проверено(T.ПлюсПлюс))
      {
        типКомпоновки = ТипКомпоновки.Cpp;
        break;
      }
      типКомпоновки = ТипКомпоновки.C;
      break;
    case ВИД.D:
      типКомпоновки = ТипКомпоновки.D;
      break;
    case ВИД.Windows:
      типКомпоновки = ТипКомпоновки.Windows;
      break;
    case ВИД.Pascal:
      типКомпоновки = ТипКомпоновки.Pascal;
      break;
    case ВИД.System:
      типКомпоновки = ТипКомпоновки.Система;
      break;
    default:
      ошибка2(ИДС.НеопознанныйТипКомпоновки, сема);
    }
    требуется(T.ПСкобка);
    return типКомпоновки;
  }

  проц  проверьТипКомпоновки(ref ТипКомпоновки предш_тк, ТипКомпоновки тк, Сема* начало)
  {
    if (предш_тк == ТипКомпоновки.Нет)
      предш_тк = тк;
    else
      ошибка(начало, сооб.ПовторяющийсяТипЛинковки, Сема.textSpan(начало, this.предыдущСема));
  }

  Декларация разборАтрибутаСохранения()
  {
    КлассХранения кхр, stc_tmp;
    ТипКомпоновки предш_типКомпоновки;

    auto saved_storageClass = this.классХранения; // Save.
    // Nested function.
    Декларация разбор()
    {
      Декларация декл;
      auto начало = сема;
      switch (сема.вид)
      {
      case T.Экстерн:
        if (возьмиСледщ() != T.ЛСкобка)
        {
          stc_tmp = КлассХранения.Экстерн;
          goto Lcommon;
        }

        далее();
        auto типКомпоновки = разборТипаКомпоновки();
        проверьТипКомпоновки(предш_типКомпоновки, типКомпоновки, начало);

        auto saved = this.типКомпоновки; // Save.
        this.типКомпоновки = типКомпоновки; // Set.
        декл = new ДекларацияКомпоновки(типКомпоновки, разбор());
        установи(декл, начало);
        this.типКомпоновки = saved; // Restore.
        break;
      case T.Перепись:
        stc_tmp = КлассХранения.Перепись;
        goto Lcommon;
      case T.Устаревший:
        stc_tmp = КлассХранения.Устаревший;
        goto Lcommon;
      case T.Абстрактный:
        stc_tmp = КлассХранения.Абстрактный;
        goto Lcommon;
      case T.Синхронизованный:
        stc_tmp = КлассХранения.Синхронизованный;
        goto Lcommon;
      case T.Статический:
        stc_tmp = КлассХранения.Статический;
        goto Lcommon;
      case T.Окончательный:
        stc_tmp = КлассХранения.Окончательный;
        goto Lcommon;
      case T.Конст:
      version(D2)
      {
        if (возьмиСледщ() == T.ЛСкобка)
          goto случай_Декларация;
      }
        stc_tmp = КлассХранения.Конст;
        goto Lcommon;
      version(D2)
      {
      case T.Инвариант: // D 2.0
        auto следщ = сема;
        if (возьмиПосле(следщ) == T.ЛСкобка)
        {
          if (возьмиПосле(следщ) != T.ПСкобка)
            goto случай_Декларация; // invariant ( Тип )
          декл = разборДекларацииИнварианта(); // invariant ( )
          // NB: this must be similar в the код at the конец of
          //     разборДефиницииДекларации().
          декл.установиЗащиту(this.защита);
          декл.установиКлассХранения(кхр);
          установи(декл, начало);
          break;
        }
        // инвариант как классХранения.
        stc_tmp = КлассХранения.Инвариант;
        goto Lcommon;
      case T.Перечень: // D 2.0
        if (!манифестПеречня_ли())
        { // A normal enum declaration.
          декл = разборДекларацииПеречня();
          // NB: this must be similar в the код at the конец of
          //     разборДефиницииДекларации().
          декл.установиЗащиту(this.защита);
          декл.установиКлассХранения(кхр);
          установи(декл, начало);
          break;
        }
        // enum as КлассХранения.
        stc_tmp = КлассХранения.Манифест;
        goto Lcommon;
      } // version(D2)
      case T.Авто:
        stc_tmp = КлассХранения.Авто;
        goto Lcommon;
      case T.Масштаб:
        stc_tmp = КлассХранения.Масштаб;
        goto Lcommon;
      Lcommon:
        // Issue ошибка if redundant.
        if (кхр & stc_tmp)
          ошибка2(ИДС.ПовторяющийсяКлассХранения, сема);
        else
          кхр |= stc_tmp;

        далее();
        декл = new ДекларацияКлассаХранения(stc_tmp, разбор());
        установи(декл, начало);
        break;
      case T.Идентификатор:
      случай_Декларация:
        // Этот could be a normal Декларация or an ДекларацияАвто
        декл = разборПеременнойИлиФункции(кхр, this.защита, предш_типКомпоновки, да);
        break;
      default:
        this.классХранения = кхр; // Set.
        декл = разборБлокаДеклараций();
        this.классХранения = saved_storageClass; // Reset.
      }
      assert(узелУстановлен(декл));
      return декл;
    }
    return разбор();
  }

  бцел разборАтрибутаАлайн()
  {
    пропусти(T.Расклад);
    бцел размер = РАЗМЕР_РАСКЛАДКИ_ПО_УМОЛЧАНИЮ; // Global default.
    if (проверено(T.ЛСкобка))
    {
      if (сема.вид == T.Цел32)
        (размер = сема.цел_), пропусти(T.Цел32);
      else
        ожидаемое(T.Цел32);
      требуется(T.ПСкобка);
    }
    return размер;
  }

  Декларация разборИдентификатораАтрибута()
  {
    Декларация декл;

    switch (сема.вид)
    {
    case T.Расклад:
      бцел размерРаскладки = разборАтрибутаАлайн();
      auto saved = this.размерРаскладки; // Save.
      this.размерРаскладки = размерРаскладки; // Set.
      декл = new ДекларацияРазложи(размерРаскладки, разборБлокаДеклараций());
      this.размерРаскладки = saved; // Restore.
      break;
    case T.Прагма:
      // Прагма:
      //     pragma ( Идентификатор )
      //     pragma ( Идентификатор , ExpressionList )
      далее();
      Идентификатор* идент;
      Выражение[] арги;

      требуется(T.ЛСкобка);
      идент = требуетсяИдентификатор(сооб.ОжидалсяИдентификаторПрагмы);

      if (проверено(T.Запятая))
        арги = разборСпискаВыражений();
      требуется(T.ПСкобка);

      декл = new ДекларацияПрагмы(идент, арги, разборБлокаДеклараций());
      break;
    default:
      // Защита attributes
      Защита защ;
      switch (сема.вид)
      {
      case T.Приватный:
        защ = Защита.Приватный; break;
      case T.Пакет:
        защ = Защита.Пакет; break;
      case T.Защищённый:
        защ = Защита.Защищённый; break;
      case T.Публичный:
        защ = Защита.Публичный; break;
      case T.Экспорт:
        защ = Защита.Экспорт; break;
      default:
        assert(0);
      }
      далее();
      auto saved = this.защита; // Save.
      this.защита = защ; // Set.
      декл = new ДекларацияЗащиты(защ, разборБлокаДеклараций());
      this.защита = saved; // Restore.
    }
    return декл;
  }

  Декларация разборДекларацииИмпорта()
  {
    бул статический_ли = проверено(T.Статический);
    пропусти(T.Импорт);

    ПКИМодуля[] пкиМодулей;
    Идентификатор*[] алиасыМодуля;
    Идентификатор*[] связанныеИмена;
    Идентификатор*[] связанныеАлиасы;

    do
    {
      ПКИМодуля пкиМодуля;
      Идентификатор* moduleAlias;
      // AliasName = ModuleName
      if (возьмиСледщ() == T.Присвоить)
      {
        moduleAlias = требуетсяИдентификатор(сооб.ExpectedAliasModuleName);
        пропусти(T.Присвоить);
      }
      // Идентификатор ("." Идентификатор)*
      do
        пкиМодуля ~= требуетсяИдентификатор(сооб.ОжидалсяИдентификаторМодуля);
      while (проверено(T.Точка))
      // Push identifiers.
      пкиМодулей ~= пкиМодуля;
      алиасыМодуля ~= moduleAlias;
    } while (проверено(T.Запятая))

    if (проверено(T.Двоеточие))
    { // BindAlias "=" BindName ("," BindAlias "=" BindName)*;
      // BindName ("," BindName)*;
      do
      {
        Идентификатор* bindAlias;
        // BindAlias = BindName
        if (возьмиСледщ() == T.Присвоить)
        {
          bindAlias = требуетсяИдентификатор(сооб.ОжидаемоеИмяАлиасаИмпорта);
          пропусти(T.Присвоить);
        }
        // Push identifiers.
        связанныеИмена ~= требуетсяИдентификатор(сооб.ОжидаемоеИмяИмпорта);
        связанныеАлиасы ~= bindAlias;
      } while (проверено(T.Запятая))
    }
    требуется(T.ТочкаЗапятая);

    return new ДекларацияИмпорта(пкиМодулей, алиасыМодуля, связанныеИмена, связанныеАлиасы, статический_ли);
  }

version(D2)
{
  /// Возвращает да, если из_ an enum manifest or
  /// нет if it's a normal enum declaration.
  бул манифестПеречня_ли()
  {
    assert(сема.вид == T.Перечень);
    auto следщ = сема;
    auto вид = возьмиПосле(следщ);
    if (вид == T.Двоеточие || вид == T.ЛФСкобка)
      return нет; // Anonymous enum.
    else if (вид == T.Идентификатор)
    {
      вид = возьмиПосле(следщ);
      if (вид == T.Двоеточие || вид == T.ЛФСкобка || вид == T.ТочкаЗапятая)
        return нет; // Named enum.
    }
    return да; // Манифест enum.
  }
}

  Декларация разборДекларацииПеречня()
  {
    пропусти(T.Перечень);

    Идентификатор* имяПеречня;
    Тип типОснова;
    ДекларацияЧленаПеречня[] члены;
    бул естьТело;

    имяПеречня = дополнительныйИдентификатор();

    if (проверено(T.Двоеточие))
      типОснова = разборБазовогоТипа();

    if (имяПеречня && проверено(T.ТочкаЗапятая))
    {}
    else if (проверено(T.ЛФСкобка))
    {
      auto леваяФСкобка = this.предыдущСема;
      естьТело = да;
      while (сема.вид != T.ПФСкобка)
      {
        auto начало = сема;

        Тип тип;
      version(D2)
      {
        бул успех;
        пробуй_({
          // Тип Идентификатор = ВыражениеПрисвой
          тип = разборТипа(); // Set outer тип переменная.
          if (сема.вид != T.Идентификатор)
            провал_пробы(), (тип = null);
          return null;
        }, успех);
      }

        auto имя = требуетсяИдентификатор(сооб.ОжидалсяЧленПеречня);
        Выражение значение;

        if (проверено(T.Присвоить))
          значение = разборВыраженияПрисвой();

        члены ~= установи(new ДекларацияЧленаПеречня(тип, имя, значение), начало);

        if (!проверено(T.Запятая))
          break;
      }
      требуетсяЗакрыв(T.ПФСкобка, леваяФСкобка);
    }
    else
      ошибка2(сооб.ОжидалосьТелоПеречня, сема);

    return new ДекларацияПеречня(имяПеречня, типОснова, члены, естьТело);
  }

  /// Wraps a declaration внутри a template declaration.
  /// Параметры:
  ///   начало = начало сема of декл.
  ///   имя = имя of декл.
  ///   декл = the declaration в be wrapped.
  ///   шпарамы = the template параметры.
  ///   констрейнт = the констрейнт выражение.
  ДекларацияШаблона поместиДекларациюВнутреннегоШаблона(Сема* начало,
                                                   Идентификатор* имя,
                                                   Декларация декл,
                                                   ПараметрыШаблона шпарамы,
                                                   Выражение констрейнт)
  {
    установи(декл, начало);
    auto cd = new СложнаяДекларация;
    cd ~= декл;
    установи(cd, начало);
    return new ДекларацияШаблона(имя, шпарамы, констрейнт, cd);
  }

  Декларация разборДекларацииКласса()
  {
    auto начало = сема;
    пропусти(T.Класс);

    Идентификатор* имяКласса;
    ПараметрыШаблона шпарамы;
    Выражение констрейнт;
    ТипКлассОснова[] основы;
    СложнаяДекларация деклы;

    имяКласса = требуетсяИдентификатор(сооб.ОжидалосьНазваниеКласса);

    if (сема.вид == T.ЛСкобка)
    {
      шпарамы = разборСпискаПараметровШаблона();
      version(D2) констрейнт = разборДополнительногоКонстрейнта();
    }

    if (сема.вид == T.Двоеточие)
      основы = разборБазовыхКлассов();

    if (основы.length == 0 && проверено(T.ТочкаЗапятая))
    {}
    else if (сема.вид == T.ЛФСкобка)
      деклы = разборТелаДефиницииДекларации();
    else
      ошибка2(сооб.ОжидалосьТелоКласса, сема);

    Декларация d = new ДекларацияКласса(имяКласса, /+шпарамы, +/основы, деклы);
    if (шпарамы)
      d = поместиДекларациюВнутреннегоШаблона(начало, имяКласса, d, шпарамы, констрейнт);
    return d;
  }

  ТипКлассОснова[] разборБазовыхКлассов(бул colonLeadsOff = да)
  {
    colonLeadsOff && пропусти(T.Двоеточие);

    ТипКлассОснова[] основы;
    do
    {
      Защита защ = Защита.Публичный;
      switch (сема.вид)
      {
      case T.Идентификатор, T.Точка, T.Типа: goto LparseBasicType;
      case T.Приватный:   защ = Защита.Приватный;   break;
      case T.Защищённый: защ = Защита.Защищённый; break;
      case T.Пакет:   защ = Защита.Пакет;   break;
      case T.Публичный:  /*защ = Защита.Публичный;*/  break;
      default:
        ошибка2(ИДС.ExpectedBaseClasses, сема);
        return основы;
      }
      далее(); // Skip защита attribute.
    LparseBasicType:
      auto начало = сема;
      auto тип = разборБазовогоТипа();
      основы ~= установи(new ТипКлассОснова(защ, тип), начало);
    } while (проверено(T.Запятая))
    return основы;
  }

  Декларация разборДекларацииИнтерфейса()
  {
    auto начало = сема;
    пропусти(T.Интерфейс);

    Идентификатор* имя;
    ПараметрыШаблона шпарамы;
    Выражение констрейнт;
    ТипКлассОснова[] основы;
    СложнаяДекларация деклы;

    имя = требуетсяИдентификатор(сооб.ОжидалосьНазваниеИнтерфейса);

    if (сема.вид == T.ЛСкобка)
    {
      шпарамы = разборСпискаПараметровШаблона();
      version(D2) констрейнт = разборДополнительногоКонстрейнта();
    }

    if (сема.вид == T.Двоеточие)
      основы = разборБазовыхКлассов();

    if (основы.length == 0 && проверено(T.ТочкаЗапятая))
    {}
    else if (сема.вид == T.ЛФСкобка)
      деклы = разборТелаДефиницииДекларации();
    else
      ошибка2(сооб.ОжидалосьТелоИнтерфейса, сема);

    Декларация d = new ДекларацияИнтерфейса(имя, /+шпарамы, +/основы, деклы);
    if (шпарамы)
      d = поместиДекларациюВнутреннегоШаблона(начало, имя, d, шпарамы, констрейнт);
    return d;
  }

  Декларация разборДекларацииСтруктурыИлиСоюза()
  {
    assert(сема.вид == T.Структура || сема.вид == T.Союз);
    auto начало = сема;
    пропусти(сема.вид);

    Идентификатор* имя;
    ПараметрыШаблона шпарамы;
    Выражение констрейнт;
    СложнаяДекларация деклы;

    имя = дополнительныйИдентификатор();

    if (имя && сема.вид == T.ЛСкобка)
    {
      шпарамы = разборСпискаПараметровШаблона();
      version(D2) констрейнт = разборДополнительногоКонстрейнта();
    }

    if (имя && проверено(T.ТочкаЗапятая))
    {}
    else if (сема.вид == T.ЛФСкобка)
      деклы = разборТелаДефиницииДекларации();
    else
      ошибка2(начало.вид == T.Структура ?
             сооб.ОжидалосьТелоСтруктуры :
             сооб.ОжидалосьТелоСоюза, сема);

    Декларация d;
    if (начало.вид == T.Структура)
    {
      auto sd = new ДекларацияСтруктуры(имя, /+шпарамы, +/деклы);
      sd.установиРазмерРаскладки(this.размерРаскладки);
      d = sd;
    }
    else
      d = new ДекларацияСоюза(имя, /+шпарамы, +/деклы);

    if (шпарамы)
      d = поместиДекларациюВнутреннегоШаблона(начало, имя, d, шпарамы, констрейнт);
    return d;
  }

  Декларация разборДекларацииКонструктора()
  {
    пропусти(T.Этот);
    auto параметры = разборСпискаПараметров();
    auto телоФунк = разборТелаФункции();
    return new ДекларацияКонструктора(параметры, телоФунк);
  }

  Декларация разборДекларацииДеструктора()
  {
    пропусти(T.Тильда);
    требуется(T.Этот);
    требуется(T.ЛСкобка);
    требуется(T.ПСкобка);
    auto телоФунк = разборТелаФункции();
    return new ДекларацияДеструктора(телоФунк);
  }

  Декларация разборДекларацииСтатичКонструктора()
  {
    пропусти(T.Статический);
    пропусти(T.Этот);
    требуется(T.ЛСкобка);
    требуется(T.ПСкобка);
    auto телоФунк = разборТелаФункции();
    return new ДекларацияСтатическогоКонструктора(телоФунк);
  }

  Декларация разборДекларацииСтатичДеструктора()
  {
    пропусти(T.Статический);
    пропусти(T.Тильда);
    требуется(T.Этот);
    требуется(T.ЛСкобка);
    требуется(T.ПСкобка);
    auto телоФунк = разборТелаФункции();
    return new ДекларацияСтатическогоДеструктора(телоФунк);
  }

  Декларация разборДекларацииИнварианта()
  {
    пропусти(T.Инвариант);
    // Optional () for getting ready porting в D 2.0
    if (проверено(T.ЛСкобка))
      требуется(T.ПСкобка);
    auto телоФунк = разборТелаФункции();
    return new ДекларацияИнварианта(телоФунк);
  }

  Декларация разборДекларацииЮниттеста()
  {
    пропусти(T.Юниттест);
    auto телоФунк = разборТелаФункции();
    return new ДекларацияЮниттеста(телоФунк);
  }

  Сема* разборИдентИлиЦел()
  {
    if (проверено(T.Цел32) || проверено(T.Идентификатор))
      return this.предыдущСема;
    ошибка2(сооб.ОжидалсяИдентИлиЦел, сема);
    return null;
  }

  Сема* разборУсловияВерсии()
  {
  version(D2)
  {
    if (проверено(T.Юниттест))
      return this.предыдущСема;
  }
    return разборИдентИлиЦел();
  }

  Декларация разборДекларацииОтладки()
  {
    пропусти(T.Отладка);

    Сема* спец;
    Сема* услов;
    Декларация деклы, деклыИначе;

    if (проверено(T.Присвоить))
    { // debug = Integer ;
      // debug = Идентификатор ;
      спец = разборИдентИлиЦел();
      требуется(T.ТочкаЗапятая);
    }
    else
    { // ( Condition )
      if (проверено(T.ЛСкобка))
      {
        услов = разборИдентИлиЦел();
        требуется(T.ПСкобка);
      }
      // debug DeclarationsBlock
      // debug ( Condition ) DeclarationsBlock
      деклы = разборБлокаДеклараций();
      // else DeclarationsBlock
      if (проверено(T.Иначе))
        деклыИначе = разборБлокаДеклараций();
    }

    return new ДекларацияОтладки(спец, услов, деклы, деклыИначе);
  }

  Декларация парсируйДекларациюВерсии()
  {
    пропусти(T.Версия);

    Сема* спец;
    Сема* услов;
    Декларация деклы, деклыИначе;

    if (проверено(T.Присвоить))
    { // version = Integer ;
      // version = Идентификатор ;
      спец = разборИдентИлиЦел();
      требуется(T.ТочкаЗапятая);
    }
    else
    { // ( Condition )
      требуется(T.ЛСкобка);
      услов = разборУсловияВерсии();
      требуется(T.ПСкобка);
      // version ( Condition ) DeclarationsBlock
      деклы = разборБлокаДеклараций();
      // else DeclarationsBlock
      if (проверено(T.Иначе))
        деклыИначе = разборБлокаДеклараций();
    }

    return new ДекларацияВерсии(спец, услов, деклы, деклыИначе);
  }

  Декларация парсируйДекларациюСтатичЕсли()
  {
    пропусти(T.Статический);
    пропусти(T.Если);

    Выражение условие;
    Декларация деклыЕсли, деклыИначе;

    auto leftParen = сема;
    требуется(T.ЛСкобка);
    условие = разборВыраженияПрисвой();
    требуетсяЗакрыв(T.ПСкобка, leftParen);

    деклыЕсли = разборБлокаДеклараций();

    if (проверено(T.Иначе))
      деклыИначе = разборБлокаДеклараций();

    return new ДекларацияСтатическогоЕсли(условие, деклыЕсли, деклыИначе);
  }

  Декларация парсируйДекларациюСтатичАссерта()
  {
    пропусти(T.Статический);
    пропусти(T.Подтвердить);
    Выражение условие, сообщение;
    auto leftParen = сема;
    требуется(T.ЛСкобка);
    условие = разборВыраженияПрисвой();
    if (проверено(T.Запятая))
      сообщение = разборВыраженияПрисвой();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    требуется(T.ТочкаЗапятая);
    return new ДекларацияСтатическогоПодтверди(условие, сообщение);
  }

  Декларация парсируйДекларациюШаблона()
  {
    пропусти(T.Шаблон);
    auto имя = требуетсяИдентификатор(сооб.ОжидалосьНазваниеШаблона);
    auto шпарамы = разборСпискаПараметровШаблона();
    auto констрейнт = разборДополнительногоКонстрейнта();
    auto деклы = разборТелаДефиницииДекларации();
    return new ДекларацияШаблона(имя, шпарамы, констрейнт, деклы);
  }

  Декларация парсируйДекларациюНов()
  {
    пропусти(T.Нов);
    auto параметры = разборСпискаПараметров();
    auto телоФунк = разборТелаФункции();
    return new ДекларацияНов(параметры, телоФунк);
  }

  Декларация парсируйДекларациюУдалить()
  {
    пропусти(T.Удалить);
    auto параметры = разборСпискаПараметров();
    auto телоФунк = разборТелаФункции();
    return new ДекларацияУдали(параметры, телоФунк);
  }

  Тип parseTypeofType()
  {
    auto начало = сема;
    пропусти(T.Типа);
    auto leftParen = сема;
    требуется(T.ЛСкобка);
    Тип тип;
    switch (сема.вид)
    {
    version(D2)
    {
    case T.Итог:
      далее();
      тип = new ТТип();
      break;
    }
    default:
      тип = new ТТип(разборВыражения());
    }
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    установи(тип, начало);
    return тип;
  }

  /// Parses a ДекларацияСмеси or ИнструкцияСмесь.
  /// $(PRE
  /// TemplateMixin :=
  ///         mixin ( ВыражениеПрисвой ) ;
  ///         mixin TemplateIdentifier ;
  ///         mixin TemplateIdentifier MixinIdentifier ;
  ///         mixin TemplateIdentifier !( АргументыШаблона ) ;
  ///         mixin TemplateIdentifier !( АргументыШаблона ) MixinIdentifier ;
  /// )
  Класс парсируйМиксин(Класс)()
  {
  static assert(is(Класс == ДекларацияСмеси) || is(Класс == ИнструкцияСмесь));
    пропусти(T.Смесь);

  static if (is(Класс == ДекларацияСмеси))
  {
    if (проверено(T.ЛСкобка))
    {
      auto leftParen = сема;
      auto в = разборВыраженияПрисвой();
      требуетсяЗакрыв(T.ПСкобка, leftParen);
      требуется(T.ТочкаЗапятая);
      return new ДекларацияСмеси(в);
    }
  }

    auto начало = сема;
    Выражение в;
    Идентификатор* идентСмеси;

    if (проверено(T.Точка))
      в = установи(new ВыражениеМасштабМодуля(разборВыраженияИдентификатора()), начало);
    else
      в = разборВыраженияИдентификатора();

    while (проверено(T.Точка))
      в = установи(new ВыражениеТочка(в, разборВыраженияИдентификатора()), начало);

    идентСмеси = дополнительныйИдентификатор();
    требуется(T.ТочкаЗапятая);

    return new Класс(в, идентСмеси);
  }

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                         Инструкция parsing methods                         |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

  СложнаяИнструкция разборИнструкций()
  {
    auto начало = сема;
    требуется(T.ЛФСкобка);
    auto инструкции = new СложнаяИнструкция();
    while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
      инструкции ~= разборИнструкции();
    требуетсяЗакрыв(T.ПФСкобка, начало);
    return установи(инструкции, начало);
  }

  /// Parses a Инструкция.
  Инструкция разборИнструкции()
  {
    auto начало = сема;
    Инструкция s;
    Декларация d;

    if (сема.интегральныйТип_ли)
    {
      d = разборПеременнойИлиФункции();
      goto LreturnDeclarationStatement;
    }

    switch (сема.вид)
    {
    case T.Расклад:
      бцел размер = разборАтрибутаАлайн();
      // Reтктict align attribute в structs in parsing phase.
      ДекларацияСтруктуры structDecl;
      if (сема.вид == T.Структура)
      {
        auto begin2 = сема;
        structDecl = разборДекларацииСтруктурыИлиСоюза().в!(ДекларацияСтруктуры);
        structDecl.установиРазмерРаскладки(размер);
        установи(structDecl, begin2);
      }
      else
        ожидаемое(T.Структура);

      d = new ДекларацияРазложи(размер, structDecl ? cast(Декларация)structDecl : new СложнаяДекларация);
      goto LreturnDeclarationStatement;
      /+ Не applicable for инструкции.
         T.Приватный, T.Пакет, T.Защищённый, T.Публичный, T.Экспорт,
         T.Устаревший, T.Перепись, T.Абстрактный,+/
    case T.Экстерн,
         T.Окончательный,
         T.Конст,
         T.Авто:
         //T.Масштаб
         //T.Статический
    случай_разборАтрибута:
      s = разборИнструкцииАтрибута();
      return s;
    case T.Идентификатор:
      if (возьмиСледщ() == T.Двоеточие)
      {
        auto идент = сема.идент;
        пропусти(T.Идентификатор); пропусти(T.Двоеточие);
        s = new ИнструкцияСМеткой(идент, разборИнструкцииБезМасштабаИлиПустое());
        break;
      }
      goto case T.Точка;
    case T.Точка, T.Типа:
      бул успех;
      d = пробуй_(delegate {
          return разборПеременнойИлиФункции(КлассХранения.Нет,
                                         Защита.Нет,
                                         ТипКомпоновки.Нет, нет, нет);
        }, успех
      );
      if (успех)
        goto LreturnDeclarationStatement; // Декларация
      else
        goto случай_разборИнструкцииВыражения; // Выражение

    case T.Если:
      s = разборИнструкцииЕсли();
      break;
    case T.Пока:
      s = разборИнструкцииПока();
      break;
    case T.Делай:
      s = разборИнструкцииДелайПока();
      break;
    case T.При:
      s = разборИнструкцииПри();
      break;
    case T.Длявсех, T.Длявсех_реверс:
      s = разборИнструкцииДлявсех();
      break;
    case T.Щит:
      s = разборИнструкцииЩит();
      break;
    case T.Реле:
      s = разборИнструкцииРеле();
      break;
    case T.Дефолт:
      s = разборИнструкцииДефолт();
      break;
    case T.Далее:
      s = разборИнструкцииДалее();
      break;
    case T.Всё:
      s = разборИнструкцииВсё();
      break;
    case T.Итог:
      s = разборИнструкцииИтог();
      break;
    case T.Переход:
      s = разборИнструкцииПереход();
      break;
    case T.Для:
      s = разборИнструкцииДля();
      break;
    case T.Синхронизованный:
      s = разборИнструкцииСинхронно();
      break;
    case T.Пробуй:
      s = разборИнструкцииПробуй();
      break;
    case T.Брось:
      s = разборИнструкцииБрось();
      break;
    case T.Масштаб:
      if (возьмиСледщ() != T.ЛСкобка)
        goto случай_разборАтрибута;
      s = parseScopeGuardStatement();
      break;
    case T.Волатайл:
      s = разборИнструкцииВолатайл();
      break;
    case T.Асм:
      s = parseAsmBlockStatement();
      break;
    case T.Прагма:
      s = разборИнструкцииПрагма();
      break;
    case T.Смесь:
      if (возьмиСледщ() == T.ЛСкобка)
        goto случай_разборИнструкцииВыражения; // Parse as выражение.
      s = парсируйМиксин!(ИнструкцияСмесь)();
      break;
    case T.Статический:
      switch (возьмиСледщ())
      {
      case T.Если:
        s = разборИнструкцииСтатичЕсли();
        break;
      case T.Подтвердить:
        s = разборИнструкцииСтатичПровер();
        break;
      default:
        goto случай_разборАтрибута;
      }
      break;
    case T.Отладка:
      s = разборИнструкцииОтладка();
      break;
    case T.Версия:
      s = разборИнструкцииВерсия();
      break;
    // DeclDef
    case T.Алиас, T.Типдеф:
      d = разборДефиницииДекларации();
      goto LreturnDeclarationStatement;
    case T.Перечень:
    version(D2)
    {
      if (манифестПеречня_ли())
        goto случай_разборАтрибута;
    }
      d = разборДекларацииПеречня();
      goto LreturnDeclarationStatement;
    case T.Класс:
      d = разборДекларацииКласса();
      goto LreturnDeclarationStatement;
    case T.Интерфейс:
      d = разборДекларацииИнтерфейса();
      goto LreturnDeclarationStatement;
    case T.Структура, T.Союз:
      d = разборДекларацииСтруктурыИлиСоюза();
      // goto LreturnDeclarationStatement;
    LreturnDeclarationStatement:
      установи(d, начало);
      s = new ИнструкцияДекларация(d);
      break;
    case T.ЛФСкобка:
      s = разборИнструкцииМасштаб();
      break;
    case T.ТочкаЗапятая:
      далее();
      s = new ПустаяИнструкция();
      break;
    // Parse an ИнструкцияВыражение:
    // Токены that старт a PrimaryExpression.
    // case T.Идентификатор, T.Точка, T.Типа:
    case T.Этот:
    case T.Супер:
    case T.Нуль:
    case T.Истина, T.Ложь:
    // case T.Доллар:
    case T.Цел32, T.Цел64, T.Бцел32, T.Бцел64:
    case T.Плав32, T.Плав64, T.Плав80,
         T.Мнимое32, T.Мнимое64, T.Мнимое80:
    case T.СимЛитерал:
    case T.Ткст:
    case T.ЛКвСкобка:
    // case T.ЛФСкобка:
    case T.Функция, T.Делегат:
    case T.Подтвердить:
    // case T.Смесь:
    case T.Импорт:
    case T.Идтипа:
    case T.Является:
    case T.ЛСкобка:
    case T.Трэтс: // D2.0
    // Токены that can старт a УнарноеВыражение:
    case T.ИБинарное, T.ПлюсПлюс, T.МинусМинус, T.Умножь, T.Минус,
         T.Плюс, T.Не, T.Тильда, T.Нов, T.Удалить, T.Каст:
    случай_разборИнструкцииВыражения:
      s = new ИнструкцияВыражение(разборВыражения());
      требуется(T.ТочкаЗапятая);
      break;
    default:
      if (сема.спецСема_ли)
        goto случай_разборИнструкцииВыражения;

      if (сема.вид != T.Доллар)
        // Подтвердить that this isn't a valid выражение.
        assert(delegate бул(){
            бул успех;
            auto выражение = пробуй_(&разборВыражения, успех);
            return успех;
          }() == нет, "Валидное выражение не ожидалось."
        );

      // Report ошибка: it's an illegal statement.
      s = new НелегальнаяИнструкция();
      // Skip в следщ valid сема.
      do
        далее();
      while (!сема.началоИнстр_ли &&
              сема.вид != T.ПФСкобка &&
              сема.вид != T.КФ)
      auto текст = Сема.textSpan(начало, this.предыдущСема);
      ошибка(начало, сооб.НелегальнаяИнструкция, текст);
    }
    assert(s !is null);
    установи(s, начало);
    return s;
  }

  /// $(PRE
  /// Parses a ИнструкцияМасштаб.
  /// ИнструкцияМасштаб :=
  ///     NoScopeStatement
  /// )
  Инструкция разборИнструкцииМасштаб()
  {
    return new ИнструкцияМасштаб(разборИнструкцииБезМасштаба());
  }

  /// $(PRE
  /// NoScopeStatement :=
  ///     NonEmptyStatement
  ///     BlockStatement
  /// BlockStatement :=
  ///     { }
  ///     { StatementList }
  /// )
  Инструкция разборИнструкцииБезМасштаба()
  {
    auto начало = сема;
    Инструкция s;
    if (проверено(T.ЛФСкобка))
    {
      auto ss = new СложнаяИнструкция();
      while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
        ss ~= разборИнструкции();
      требуетсяЗакрыв(T.ПФСкобка, начало);
      s = установи(ss, начало);
    }
    else if (сема.вид == T.ТочкаЗапятая)
    {
      ошибка(сема, сооб.ОжидаласьНеПустаяИнструкция);
      далее();
      s = установи(new ПустаяИнструкция(), начало);
    }
    else
      s = разборИнструкции();
    return s;
  }

  /// $(PRE
  /// NoScopeOrEmptyStatement :=
  ///     ;
  ///     NoScopeStatement
  /// )
  Инструкция разборИнструкцииБезМасштабаИлиПустое()
  {
    if (проверено(T.ТочкаЗапятая))
      return установи(new ПустаяИнструкция(), this.предыдущСема);
    else
      return разборИнструкцииБезМасштаба();
  }

  Инструкция разборИнструкцииАтрибута()
  {
    КлассХранения кхр, stc_tmp;
    ТипКомпоновки предш_типКомпоновки;

    Декларация разбор() // Nested function.
    {
      auto начало = сема;
      Декларация декл;
      switch (сема.вид)
      {
      case T.Экстерн:
        if (возьмиСледщ() != T.ЛСкобка)
        {
          stc_tmp = КлассХранения.Экстерн;
          goto Lcommon;
        }

        далее();
        auto типКомпоновки = разборТипаКомпоновки();
        проверьТипКомпоновки(предш_типКомпоновки, типКомпоновки, начало);

        декл = new ДекларацияКомпоновки(типКомпоновки, разбор());
        break;
      case T.Статический:
        stc_tmp = КлассХранения.Статический;
        goto Lcommon;
      case T.Окончательный:
        stc_tmp = КлассХранения.Окончательный;
        goto Lcommon;
      case T.Конст:
      version(D2)
      {
        if (возьмиСледщ() == T.ЛСкобка)
          goto случай_Декларация;
      }
        stc_tmp = КлассХранения.Конст;
        goto Lcommon;
      version(D2)
      {
      case T.Инвариант: // D 2.0
        if (возьмиСледщ() == T.ЛСкобка)
          goto случай_Декларация;
        stc_tmp = КлассХранения.Инвариант;
        goto Lcommon;
      case T.Перечень: // D 2.0
        if (!манифестПеречня_ли())
        { // A normal enum declaration.
          декл = разборДекларацииПеречня();
          // NB: this must be similar в the код at the конец of
          //     разборДефиницииДекларации().
          декл.установиЗащиту(this.защита);
          декл.установиКлассХранения(кхр);
          установи(декл, начало);
          return декл;
        }
        // enum as КлассХранения.
        stc_tmp = КлассХранения.Манифест;
        goto Lcommon;
      }
      case T.Авто:
        stc_tmp = КлассХранения.Авто;
        goto Lcommon;
      case T.Масштаб:
        stc_tmp = КлассХранения.Масштаб;
        goto Lcommon;
      Lcommon:
        // Issue ошибка if redundant.
        if (кхр & stc_tmp)
          ошибка2(ИДС.ПовторяющийсяКлассХранения, сема);
        else
          кхр |= stc_tmp;

        далее();
        декл = new ДекларацияКлассаХранения(stc_tmp, разбор());
        break;
      case T.Класс, T.Интерфейс, T.Структура, T.Союз, T.Алиас, T.Типдеф:
        декл = разборДефиницииДекларации();
        декл.установиЗащиту(Защита.Нет);
        декл.установиКлассХранения(КлассХранения.Нет);
        return декл;
      default:
      случай_Декларация:
        return разборПеременнойИлиФункции(кхр, Защита.Нет, предш_типКомпоновки, да);
      }
      return установи(декл, начало);
    }
    return new ИнструкцияДекларация(разбор());
  }

  Инструкция разборИнструкцииЕсли()
  {
    пропусти(T.Если);

    Инструкция переменная;
    Выражение условие;
    Инструкция телоЕсли, телоИначе;

    auto leftParen = сема;
    требуется(T.ЛСкобка);

    Идентификатор* идент;
    auto начало = сема; // При старт of ДекларацияАвто or normal Декларация.
    // auto Идентификатор = Выражение
    if (проверено(T.Авто))
    {
      идент = требуетсяИдентификатор(сооб.ОжидалосьНазваниеПеременной);
      требуется(T.Присвоить);
      auto иниц = разборВыражения();
      auto v = new ДекларацияПеременных(null, [идент], [иниц]);
      установи(v, начало.следщНепроб);
      auto d = new ДекларацияКлассаХранения(КлассХранения.Авто, v);
      установи(d, начало);
      переменная = new ИнструкцияДекларация(d);
      установи(переменная, начало);
    }
    else
    { // Declarator = Выражение
      Тип parseDeclaratorAssign()
      {
        auto тип = разборДекларатора(идент);
        требуется(T.Присвоить);
        return тип;
      }
      бул успех;
      auto тип = пробуй_(&parseDeclaratorAssign, успех);
      if (успех)
      {
        auto иниц = разборВыражения();
        auto v = new ДекларацияПеременных(тип, [идент], [иниц]);
        установи(v, начало);
        переменная = new ИнструкцияДекларация(v);
        установи(переменная, начало);
      }
      else
        условие = разборВыражения();
    }
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    телоЕсли = разборИнструкцииМасштаб();
    if (проверено(T.Иначе))
      телоИначе = разборИнструкцииМасштаб();
    return new ИнструкцияЕсли(переменная, условие, телоЕсли, телоИначе);
  }

  Инструкция разборИнструкцииПока()
  {
    пропусти(T.Пока);
    auto leftParen = сема;
    требуется(T.ЛСкобка);
    auto условие = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    return new ИнструкцияПока(условие, разборИнструкцииМасштаб());
  }

  Инструкция разборИнструкцииДелайПока()
  {
    пропусти(T.Делай);
    auto телоДелай = разборИнструкцииМасштаб();
    требуется(T.Пока);
    auto leftParen = сема;
    требуется(T.ЛСкобка);
    auto условие = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    return new ИнструкцияДелайПока(условие, телоДелай);
  }

  Инструкция разборИнструкцииПри()
  {
    пропусти(T.При);

    Инструкция иниц, телоПри;
    Выражение условие, инкремент;

    auto leftParen = сема;
    требуется(T.ЛСкобка);
    if (!проверено(T.ТочкаЗапятая))
      иниц = разборИнструкцииБезМасштаба();
    if (сема.вид != T.ТочкаЗапятая)
      условие = разборВыражения();
    требуется(T.ТочкаЗапятая);
    if (сема.вид != T.ПСкобка)
      инкремент = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    телоПри = разборИнструкцииМасштаб();
    return new ИнструкцияПри(иниц, условие, инкремент, телоПри);
  }

  Инструкция разборИнструкцииДлявсех()
  {
    assert(сема.вид == T.Длявсех || сема.вид == T.Длявсех_реверс);
    TOK лекс = сема.вид;
    далее();

    auto парамы = new Параметры;
    Выражение в; // Агрегат or LwrExpression

    auto leftParen = сема;
    требуется(T.ЛСкобка);
    auto paramsBegin = сема;
    do
    {
      auto paramBegin = сема;
      КлассХранения кхр;
      Тип тип;
      Идентификатор* идент;

      switch (сема.вид)
      {
      case T.Реф, T.Вховых:
        кхр = КлассХранения.Реф;
        далее();
        // fall through
      case T.Идентификатор:
        auto следщ = возьмиСледщ();
        if (следщ == T.Запятая || следщ == T.ТочкаЗапятая || следщ == T.ПСкобка)
        {
          идент = требуетсяИдентификатор(сооб.ОжидалосьНазваниеПеременной);
          break;
        }
        // fall through
      default:
        тип = разборДекларатора(идент);
      }

      парамы ~= установи(new Параметр(кхр, тип, идент, null), paramBegin);
    } while (проверено(T.Запятая))
    установи(парамы, paramsBegin);
    требуется(T.ТочкаЗапятая);
    в = разборВыражения();
  version(D2)
  { //Длявсех (ForeachType; LwrExpression .. UprExpression ) ИнструкцияМасштаб
    if (проверено(T.Срез))
    {
      // if (парамы.length != 1)
        // ошибка(ИДС.XYZ); // TODO: issue ошибка сооб
      auto верхний = разборВыражения();
      требуетсяЗакрыв(T.ПСкобка, leftParen);
      auto телоПри = разборИнструкцииМасштаб();
      return new ИнструкцияДиапазонСКаждым(лекс, парамы, в, верхний, телоПри);
    }
  }
    // Длявсех (ForeachTypeList; Агрегат) ИнструкцияМасштаб
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    auto телоПри = разборИнструкцииМасштаб();
    return new ИнструкцияСКаждым(лекс, парамы, в, телоПри);
  }

  Инструкция разборИнструкцииЩит()
  {
    пропусти(T.Щит);
    auto leftParen = сема;
    требуется(T.ЛСкобка);
    auto условие = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    auto телоЩит = разборИнструкцииМасштаб();
    return new ИнструкцияЩит(условие, телоЩит);
  }

  /// Helper function for parsing the body of a default or case statement.
  Инструкция parseCaseOrDefaultBody()
  {
    // Этот function is similar в разборИнструкцииБезМасштаба()
    auto начало = сема;
    auto s = new СложнаяИнструкция();
    while (сема.вид != T.Реле &&
           сема.вид != T.Дефолт &&
           сема.вид != T.ПФСкобка &&
           сема.вид != T.КФ)
      s ~= разборИнструкции();
    установи(s, начало);
    return установи(new ИнструкцияМасштаб(s), начало);
  }

  Инструкция разборИнструкцииРеле()
  {
    пропусти(T.Реле);
    auto значения = разборСпискаВыражений();
    требуется(T.Двоеточие);
    auto телоРеле = parseCaseOrDefaultBody();
    return new ИнструкцияРеле(значения, телоРеле);
  }

  Инструкция разборИнструкцииДефолт()
  {
    пропусти(T.Дефолт);
    требуется(T.Двоеточие);
    auto телоДефолта = parseCaseOrDefaultBody();
    return new ИнструкцияДефолт(телоДефолта);
  }

  Инструкция разборИнструкцииДалее()
  {
    пропусти(T.Далее);
    auto идент = дополнительныйИдентификатор();
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияДалее(идент);
  }

  Инструкция разборИнструкцииВсё()
  {
    пропусти(T.Всё);
    auto идент = дополнительныйИдентификатор();
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияВсё(идент);
  }

  Инструкция разборИнструкцииИтог()
  {
    пропусти(T.Итог);
    Выражение выр;
    if (сема.вид != T.ТочкаЗапятая)
      выр = разборВыражения();
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияИтог(выр);
  }

  Инструкция разборИнструкцииПереход()
  {
    пропусти(T.Переход);
    Идентификатор* идент;
    Выражение вырРеле;
    switch (сема.вид)
    {
    case T.Реле:
      идент = сема.идент;
      далее();
      if (сема.вид == T.ТочкаЗапятая)
        break;
      вырРеле = разборВыражения();
      break;
    case T.Дефолт:
      идент = сема.идент;
      далее();
      break;
    default:
      идент = требуетсяИдентификатор(сооб.ОжидалсяИдентификатор);
    }
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияПереход(идент, вырРеле);
  }

  Инструкция разборИнструкцииДля()
  {
    пропусти(T.Для);
    auto leftParen = сема;
    требуется(T.ЛСкобка);
    auto выр = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    return new ИнструкцияДля(выр, разборИнструкцииМасштаб());
  }

  Инструкция разборИнструкцииСинхронно()
  {
    пропусти(T.Синхронизованный);
    Выражение выр;
    if (проверено(T.ЛСкобка))
    {
      auto leftParen = this.предыдущСема;
      выр = разборВыражения();
      требуетсяЗакрыв(T.ПСкобка, leftParen);
    }
    return new ИнструкцияСинхр(выр, разборИнструкцииМасштаб());
  }

  Инструкция разборИнструкцииПробуй()
  {
    auto начало = сема;
    пропусти(T.Пробуй);

    auto телоПробуй = разборИнструкцииМасштаб();
    ИнструкцияЛови[] телаЛови;
    ИнструкцияИтожь finBody;

    while (проверено(T.Кэтч))
    {
      Параметр парам;
      if (проверено(T.ЛСкобка))
      {
        auto begin2 = сема;
        Идентификатор* идент;
        auto тип = разборДекларатора(идент, да);
        парам = new Параметр(КлассХранения.Нет, тип, идент, null);
        установи(парам, begin2);
        требуется(T.ПСкобка);
      }
      телаЛови ~= установи(new ИнструкцияЛови(парам, разборИнструкцииБезМасштаба()), начало);
      if (парам is null)
        break; // Этот is a LastCatch
      начало = сема;
    }

    if (проверено(T.Finally))
      finBody = установи(new ИнструкцияИтожь(разборИнструкцииБезМасштаба()), предыдущСема);

    if (телаЛови.length == 0 && finBody is null)
      assert(начало.вид == T.Пробуй), ошибка(начало, сооб.НеДостаетCatchИлиFinally);

    return new ИнструкцияПробуй(телоПробуй, телаЛови, finBody);
  }

  Инструкция разборИнструкцииБрось()
  {
    пропусти(T.Брось);
    auto выр = разборВыражения();
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияБрось(выр);
  }

  Инструкция parseScopeGuardStatement()
  {
    пропусти(T.Масштаб);
    пропусти(T.ЛСкобка);
    auto условие = требуетсяИдентификатор(сооб.ОжидалсяИдентификаторМасштаба);
    if (условие)
      switch (условие.видИд)
      {
      case ВИД.выход, ВИД.успех, ВИД.сбой:
        break;
      default:
        ошибка2(сооб.НеверныйИдентификаторМасштаба, this.предыдущСема);
      }
    требуется(T.ПСкобка);
    Инструкция телоМасштаба;
    if (сема.вид == T.ЛФСкобка)
      телоМасштаба = разборИнструкцииМасштаб();
    else
      телоМасштаба = разборИнструкцииБезМасштаба();
    return new ИнструкцияСтражМасштаба(условие, телоМасштаба);
  }

  Инструкция разборИнструкцииВолатайл()
  {
    пропусти(T.Волатайл);
    Инструкция телоЛетучего;
    if (сема.вид == T.ТочкаЗапятая)
      далее();
    else if (сема.вид == T.ЛФСкобка)
      телоЛетучего = разборИнструкцииМасштаб();
    else
      телоЛетучего = разборИнструкции();
    return new ИнструкцияЛетучее(телоЛетучего);
  }

  Инструкция разборИнструкцииПрагма()
  {
    пропусти(T.Прагма);

    Идентификатор* идент;
    Выражение[] арги;
    Инструкция телоПрагмы;

    auto leftParen = сема;
    требуется(T.ЛСкобка);
    идент = требуетсяИдентификатор(сооб.ОжидалсяИдентификаторПрагмы);

    if (проверено(T.Запятая))
      арги = разборСпискаВыражений();
    требуетсяЗакрыв(T.ПСкобка, leftParen);

    телоПрагмы = разборИнструкцииБезМасштабаИлиПустое();

    return new ИнструкцияПрагма(идент, арги, телоПрагмы);
  }

  Инструкция разборИнструкцииСтатичЕсли()
  {
    пропусти(T.Статический);
    пропусти(T.Если);
    Выражение условие;
    Инструкция телоЕсли, телоИначе;

    auto leftParen = сема;
    требуется(T.ЛСкобка);
    условие = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    телоЕсли = разборИнструкцииБезМасштаба();
    if (проверено(T.Иначе))
      телоИначе = разборИнструкцииБезМасштаба();
    return new ИнструкцияСтатическоеЕсли(условие, телоЕсли, телоИначе);
  }

  Инструкция разборИнструкцииСтатичПровер()
  {
    пропусти(T.Статический);
    пропусти(T.Подтвердить);
    Выражение условие, сообщение;

    требуется(T.ЛСкобка);
    условие = разборВыраженияПрисвой(); // Condition.
    if (проверено(T.Запятая))
      сообщение = разборВыраженияПрисвой(); // Ошибка сообщение.
    требуется(T.ПСкобка);
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияСтатическоеПодтверди(условие, сообщение);
  }

  Инструкция разборИнструкцииОтладка()
  {
    пропусти(T.Отладка);
    Сема* услов;
    Инструкция телоОтладки, телоИначе;

    // ( Condition )
    if (проверено(T.ЛСкобка))
    {
      услов = разборИдентИлиЦел();
      требуется(T.ПСкобка);
    }
    // debug Инструкция
    // debug ( Condition ) Инструкция
    телоОтладки = разборИнструкцииБезМасштаба();
    // else Инструкция
    if (проверено(T.Иначе))
      телоИначе = разборИнструкцииБезМасштаба();

    return new ИнструкцияОтладка(услов, телоОтладки, телоИначе);
  }

  Инструкция разборИнструкцииВерсия()
  {
    пропусти(T.Версия);
    Сема* услов;
    Инструкция телоВерсии, телоИначе;

    // ( Condition )
    требуется(T.ЛСкобка);
    услов = разборУсловияВерсии();
    требуется(T.ПСкобка);
    // version ( Condition ) Инструкция
    телоВерсии = разборИнструкцииБезМасштаба();
    // else Инструкция
    if (проверено(T.Иначе))
      телоИначе = разборИнструкцииБезМасштаба();

    return new ИнструкцияВерсия(услов, телоВерсии, телоИначе);
  }

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                         Assembler parsing methods                         |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

  /// Parses an ИнструкцияБлокАсм.
  Инструкция parseAsmBlockStatement()
  {
    пропусти(T.Асм);
    auto леваяФСкобка = сема;
    требуется(T.ЛФСкобка);
    auto ss = new СложнаяИнструкция;
    while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
      ss ~= parseAsmStatement();
    требуетсяЗакрыв(T.ПФСкобка, леваяФСкобка);
    return new ИнструкцияБлокАсм(ss);
  }

  Инструкция parseAsmStatement()
  {
    auto начало = сема;
    Инструкция s;
    Идентификатор* идент;
    switch (сема.вид)
    {
    // Keywords that are valid opcodes.
    case T.Вхо, T.Цел, T.Вых:
      идент = сема.идент;
      далее();
      goto LOpcode;
    case T.Идентификатор:
      идент = сема.идент;
      далее();
      if (проверено(T.Двоеточие))
      { // Идентификатор : ИнструкцияАсм
        s = new ИнструкцияСМеткой(идент, parseAsmStatement());
        break;
      }

    LOpcode:
      // Opcode ;
      // Opcode Operands ;
      // Opcode
      //     Идентификатор
      Выражение[] es;
      if (сема.вид != T.ТочкаЗапятая)
        do
          es ~= parseAsmExpression();
        while (проверено(T.Запятая))
      требуется(T.ТочкаЗапятая);
      s = new ИнструкцияАсм(идент, es);
      break;
    case T.Расклад:
      // align Integer;
      далее();
      цел число = -1;
      if (сема.вид == T.Цел32)
        (число = сема.цел_), пропусти(T.Цел32);
      else
        ошибка2(сооб.ExpectedIntegerAfterAlign, сема);
      требуется(T.ТочкаЗапятая);
      s = new ИнструкцияАсмРасклад(число);
      break;
    case T.ТочкаЗапятая:
      s = new ПустаяИнструкция();
      далее();
      break;
    default:
      s = new ИнструкцияНелегальныйАсм();
      // Skip в следщ valid сема.
      do
        далее();
      while (!сема.началоАсмИнстр_ли &&
              сема.вид != T.ПФСкобка &&
              сема.вид != T.КФ)
      auto текст = Сема.textSpan(начало, this.предыдущСема);
      ошибка(начало, сооб.ИнструкцияНелегальныйАсм, текст);
    }
    установи(s, начало);
    return s;
  }

  Выражение parseAsmExpression()
  {
    auto начало = сема;
    auto в = parseAsmOrOrExpression();
    if (проверено(T.Вопрос))
    {
      auto лекс = this.предыдущСема;
      auto iftrue = parseAsmExpression();
      требуется(T.Двоеточие);
      auto iffalse = parseAsmExpression();
      в = new ВыражениеУсловия(в, iftrue, iffalse, лекс);
      установи(в, начало);
    }
    // TODO: create AsmExpression that contains в?
    return в;
  }

  Выражение parseAsmOrOrExpression()
  {
    alias parseAsmAndAndExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИлиЛогическое)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИлиИли(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAsmAndAndExpression()
  {
    alias parseAsmOrExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИЛогическое)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИИ(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAsmOrExpression()
  {
    alias parseAsmXorExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИлиБинарное)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИли(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAsmXorExpression()
  {
    alias parseAsmAndExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИИли)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИИли(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAsmAndExpression()
  {
    alias parseAsmCmpExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИБинарное)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИ(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAsmCmpExpression()
  {
    alias parseAsmShiftExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();

    auto operator = сема;
    switch (operator.вид)
    {
    case T.Равно, T.НеРавно:
      далее();
      в = new ВыражениеРавно(в, разборСледующего(), operator);
      break;
    case T.МеньшеРавно, T.Меньше, T.БольшеРавно, T.Больше:
      далее();
      в = new ВыражениеОтнош(в, разборСледующего(), operator);
      break;
    default:
      return в;
    }
    установи(в, начало);
    return в;
  }

  Выражение parseAsmShiftExpression()
  {
    alias parseAsmAddExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (1)
    {
      auto operator = сема;
      switch (operator.вид)
      {
      case T.ЛСдвиг:  далее(); в = new ВыражениеЛСдвиг(в, разборСледующего(), operator); break;
      case T.ПСдвиг:  далее(); в = new ВыражениеПСдвиг(в, разборСледующего(), operator); break;
      case T.URShift: далее(); в = new ВыражениеБПСдвиг(в, разборСледующего(), operator); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение parseAsmAddExpression()
  {
    alias parseAsmMulExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (1)
    {
      auto operator = сема;
      switch (operator.вид)
      {
      case T.Плюс:  далее(); в = new ВыражениеПлюс(в, разборСледующего(), operator); break;
      case T.Минус: далее(); в = new ВыражениеМинус(в, разборСледующего(), operator); break;
      // Не allowed in asm
      //case T.Тильда: далее(); в = new ВыражениеСоедини(в, разборСледующего(), operator); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение parseAsmMulExpression()
  {
    alias parseAsmPostExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (1)
    {
      auto operator = сема;
      switch (operator.вид)
      {
      case T.Умножь: далее(); в = new ВыражениеУмножь(в, разборСледующего(), operator); break;
      case T.Деление: далее(); в = new ВыражениеДели(в, разборСледующего(), operator); break;
      case T.Модуль: далее(); в = new ВыражениеМод(в, разборСледующего(), operator); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение parseAsmPostExpression()
  {
    auto начало = сема;
    auto в = parseAsmUnaryExpression();
    while (проверено(T.ЛКвСкобка))
    {
      auto leftBracket = this.предыдущСема;
      в = new ВыражениеАсмПослеСкобки(в, parseAsmExpression());
      требуетсяЗакрыв(T.ПКвСкобка, leftBracket);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAsmUnaryExpression()
  {
    auto начало = сема;
    Выражение в;
    switch (сема.вид)
    {
    case T.Байт,  T.Крат,  T.Цел,
         T.Плав, T.Дво, T.Реал:
      goto LAsmTypePrefix;
    case T.Идентификатор:
      switch (сема.идент.видИд)
      {
      case ВИД.near, ВИД.far,/* "байт",  "крат",  "цел",*/
           ВИД.word, ВИД.dword, ВИД.qword/*, "плав", "дво", "реал"*/:
      LAsmTypePrefix:
        далее();
        if (сема.вид == T.Идентификатор && сема.идент is Идент.ptr)
          пропусти(T.Идентификатор);
        else
          ошибка2(ИДС.НайденоИноеЧемОжидалось, "ptr", сема);
        в = new ВыражениеТипАсм(parseAsmExpression());
        break;
      case ВИД.offset:
        далее();
        в = new ВыражениеСмещениеАсм(parseAsmExpression());
        break;
      case ВИД.seg:
        далее();
        в = new ВыражениеСегАсм(parseAsmExpression());
        break;
      default:
        goto LparseAsmPrimaryExpression;
      }
      break;
    case T.Минус:
    case T.Плюс:
      далее();
      в = new ВыражениеЗнак(parseAsmUnaryExpression());
      break;
    case T.Не:
      далее();
      в = new ВыражениеНе(parseAsmUnaryExpression());
      break;
    case T.Тильда:
      далее();
      в = new ВыражениеКомп(parseAsmUnaryExpression());
      break;
    case T.Точка:
      далее();
      в = new ВыражениеМасштабМодуля(разборВыраженияИдентификатора());
      while (проверено(TOK.Точка))
      {
        в = new ВыражениеТочка(в, разборВыраженияИдентификатора());
        установи(в, начало);
      }
      break;
    default:
    LparseAsmPrimaryExpression:
      в = parseAsmPrimaryExpression();
      return в;
    }
    установи(в, начало);
    return в;
  }

  Выражение parseAsmPrimaryExpression()
  {
    auto начало = сема;
    Выражение в;
    switch (сема.вид)
    {
    case T.Цел32, T.Цел64, T.Бцел32, T.Бцел64:
      в = new ЦелВыражение(сема);
      далее();
      break;
    case T.Плав32, T.Плав64, T.Плав80,
         T.Мнимое32, T.Мнимое64, T.Мнимое80:
      в = new ВыражениеРеал(сема);
      далее();
      break;
    case T.Доллар:
      в = new ВыражениеДоллар();
      далее();
      break;
    case T.ЛКвСкобка:
      // [ AsmExpression ]
      auto leftBracket = сема;
      далее();
      в = parseAsmExpression();
      требуетсяЗакрыв(T.ПКвСкобка, leftBracket);
      в = new ВыражениеАсмСкобка(в);
      break;
    case T.Идентификатор:
      auto register = сема.идент;
      switch (register.видИд)
      {
      // __LOCAL_SIZE
      case ВИД.__LOCAL_SIZE:
        далее();
        в = new ВыражениеЛокальногоРазмераАсм();
        break;
      // Register
      case ВИД.ST:
        далее();
        // (1) - (7)
        цел число = -1;
        if (проверено(T.ЛСкобка))
        {
          if (сема.вид == T.Цел32)
            (число = сема.цел_), пропусти(T.Цел32);
          else
            ожидаемое(T.Цел32);
          требуется(T.ПСкобка);
        }
        в = new ВыражениеАсмРегистр(register, число);
        break;
      case ВИД.FS:
        далее();
        // TODO: is the colon-число part optional?
        цел число = -1;
        if (проверено(T.Двоеточие))
        {
          // :0, :4, :8
          if (сема.вид == T.Цел32)
            (число = сема.цел_), пропусти(T.Цел32);
          if (число != 0 && число != 4 && число != 8)
            ошибка2(ИДС.НайденоИноеЧемОжидалось, "0, 4 or 8", сема);
        }
        в = new ВыражениеАсмРегистр(register, число);
        break;
      case ВИД.AL, ВИД.AH, ВИД.AX, ВИД.EAX,
           ВИД.BL, ВИД.BH, ВИД.BX, ВИД.EBX,
           ВИД.CL, ВИД.CH, ВИД.CX, ВИД.ECX,
           ВИД.DL, ВИД.DH, ВИД.DX, ВИД.EDX,
           ВИД.BP, ВИД.EBP, ВИД.SP, ВИД.ESP,
           ВИД.DI, ВИД.EDI, ВИД.SI, ВИД.ESI,
           ВИД.ES, ВИД.CS, ВИД.SS, ВИД.DS, ВИД.GS,
           ВИД.CR0, ВИД.CR2, ВИД.CR3, ВИД.CR4,
           ВИД.DR0, ВИД.DR1, ВИД.DR2, ВИД.DR3, ВИД.DR6, ВИД.DR7,
           ВИД.TR3, ВИД.TR4, ВИД.TR5, ВИД.TR6, ВИД.TR7,
           ВИД.MM0, ВИД.MM1, ВИД.MM2, ВИД.MM3,
           ВИД.MM4, ВИД.MM5, ВИД.MM6, ВИД.MM7,
           ВИД.XMM0, ВИД.XMM1, ВИД.XMM2, ВИД.XMM3,
           ВИД.XMM4, ВИД.XMM5, ВИД.XMM6, ВИД.XMM7:
        далее();
        в = new ВыражениеАсмРегистр(register);
        break;
      default:
        в = разборВыраженияИдентификатора();
        while (проверено(TOK.Точка))
        {
          в = new ВыражениеТочка(в, разборВыраженияИдентификатора());
          установи(в, начало);
        }
      } // конец of switch
      break;
    default:
      ошибка2(ИДС.НайденоИноеЧемОжидалось, "Выражение", сема);
      в = new НелегальноеВыражение();
      if (!пробуем)
      { // Insert a dummy сема and don't consume current one.
        начало = лексер.вставьПустуюСемуПеред(сема);
        this.предыдущСема = начало;
      }
    }
    установи(в, начало);
    return в;
  }

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                        Выражение parsing methods                         |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

  /// Parses an Выражение.
  Выражение разборВыражения()
  {
    alias разборВыраженияПрисвой разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.Запятая)
    {
      auto comma = сема;
      далее();
      в = new ВыражениеЗапятая(в, разборСледующего(), comma);
      установи(в, начало);
    }
    return в;
  }

  Выражение разборВыраженияПрисвой()
  {
    alias разборВыраженияПрисвой разборСледующего;
    auto начало = сема;
    auto в = разборУсловнВыражения();
    switch (сема.вид)
    {
    case T.Присвоить:
      далее(); в = new ВыражениеПрисвой(в, разборСледующего()); break;
    case T.ЛСдвигПрисвой:
      далее(); в = new ВыражениеПрисвойЛСдвиг(в, разборСледующего()); break;
    case T.ПСдвигПрисвой:
      далее(); в = new ВыражениеПрисвойПСдвиг(в, разборСледующего()); break;
    case T.URShiftAssign:
      далее(); в = new ВыражениеПрисвойБПСдвиг(в, разборСледующего()); break;
    case T.ИлиПрисвой:
      далее(); в = new ВыражениеПрисвойИли(в, разборСледующего()); break;
    case T.ИПрисвой:
      далее(); в = new ВыражениеПрисвойИ(в, разборСледующего()); break;
    case T.ПлюсПрисвой:
      далее(); в = new ВыражениеПрисвойПлюс(в, разборСледующего()); break;
    case T.МинусПрисвой:
      далее(); в = new ВыражениеПрисвойМинус(в, разборСледующего()); break;
    case T.ДелениеПрисвой:
      далее(); в = new ВыражениеПрисвойДел(в, разборСледующего()); break;
    case T.УмножьПрисвой:
      далее(); в = new ВыражениеПрисвойУмн(в, разборСледующего()); break;
    case T.МодульПрисвой:
      далее(); в = new ВыражениеПрисвойМод(в, разборСледующего()); break;
    case T.ИИлиПрисвой:
      далее(); в = new ВыражениеПрисвойИИли(в, разборСледующего()); break;
    case T.CatAssign:
      далее(); в = new ВыражениеПрисвойСоед(в, разборСледующего()); break;
    default:
      return в;
    }
    установи(в, начало);
    return в;
  }

  Выражение разборУсловнВыражения()
  {
    auto начало = сема;
    auto в = parseOrOrExpression();
    if (сема.вид == T.Вопрос)
    {
      auto лекс = сема;
      далее();
      auto iftrue = разборВыражения();
      требуется(T.Двоеточие);
      auto iffalse = разборУсловнВыражения();
      в = new ВыражениеУсловия(в, iftrue, iffalse, лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseOrOrExpression()
  {
    alias parseAndAndExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИлиЛогическое)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИлиИли(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAndAndExpression()
  {
    alias parseOrExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИЛогическое)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИИ(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseOrExpression()
  {
    alias parseXorExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИлиБинарное)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИли(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseXorExpression()
  {
    alias parseAndExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИИли)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИИли(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAndExpression()
  {
    alias parseCmpExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИБинарное)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИ(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseCmpExpression()
  {
    alias parseShiftExpression разборСледующего;
    auto начало = сема;
    auto в = parseShiftExpression();

    auto operator = сема;
    switch (operator.вид)
    {
    case T.Равно, T.НеРавно:
      далее();
      в = new ВыражениеРавно(в, разборСледующего(), operator);
      break;
    case T.Не:
      if (возьмиСледщ() != T.Является)
        break;
      далее();
      // fall through
    case T.Является:
      далее();
      в = new ВыражениеРавенство(в, разборСледующего(), operator);
      break;
    case T.МеньшеРавно, T.Меньше, T.БольшеРавно, T.Больше,
         T.Unordered, T.UorE, T.UorG, T.UorGorE,
         T.UorL, T.UorLorE, T.LorEorG, T.LorG:
      далее();
      в = new ВыражениеОтнош(в, разборСледующего(), operator);
      break;
    case T.Вхо:
      далее();
      в = new ВыражениеВхо(в, разборСледующего(), operator);
      break;
    default:
      return в;
    }
    установи(в, начало);
    return в;
  }

  Выражение parseShiftExpression()
  {
    alias parseAddExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (1)
    {
      auto operator = сема;
      switch (operator.вид)
      {
      case T.ЛСдвиг:  далее(); в = new ВыражениеЛСдвиг(в, разборСледующего(), operator); break;
      case T.ПСдвиг:  далее(); в = new ВыражениеПСдвиг(в, разборСледующего(), operator); break;
      case T.URShift: далее(); в = new ВыражениеБПСдвиг(в, разборСледующего(), operator); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение parseAddExpression()
  {
    alias parseMulExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (1)
    {
      auto operator = сема;
      switch (operator.вид)
      {
      case T.Плюс:  далее(); в = new ВыражениеПлюс(в, разборСледующего(), operator); break;
      case T.Минус: далее(); в = new ВыражениеМинус(в, разборСледующего(), operator); break;
      case T.Тильда: далее(); в = new ВыражениеСоедини(в, разборСледующего(), operator); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение parseMulExpression()
  {
    alias parsePostExpression разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (1)
    {
      auto operator = сема;
      switch (operator.вид)
      {
      case T.Умножь: далее(); в = new ВыражениеУмножь(в, разборСледующего(), operator); break;
      case T.Деление: далее(); в = new ВыражениеДели(в, разборСледующего(), operator); break;
      case T.Модуль: далее(); в = new ВыражениеМод(в, разборСледующего(), operator); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение parsePostExpression()
  {
    auto начало = сема;
    auto в = parseUnaryExpression();
    while (1)
    {
      while (проверено(T.Точка))
      {
        в = new ВыражениеТочка(в, parseNewOrIdentifierExpression());
        установи(в, начало);
      }

      switch (сема.вид)
      {
      case T.ПлюсПлюс:
        в = new ВыражениеПостИнкр(в);
        break;
      case T.МинусМинус:
        в = new ВыражениеПостДекр(в);
        break;
      case T.ЛСкобка:
        в = new ВыражениеВызов(в, разборАргументов());
        goto Lset;
      case T.ЛКвСкобка:
        // разбор Срез- and ВыражениеИндекс
        auto leftBracket = сема;
        далее();
        // [] is a ВыражениеСрез
        if (сема.вид == T.ПКвСкобка)
        {
          в = new ВыражениеСрез(в, null, null);
          break;
        }

        Выражение[] es = [разборВыраженияПрисвой()];

        // [ ВыражениеПрисвой .. ВыражениеПрисвой ]
        if (проверено(T.Срез))
        {
          в = new ВыражениеСрез(в, es[0], разборВыраженияПрисвой());
          требуетсяЗакрыв(T.ПКвСкобка, leftBracket);
          goto Lset;
        }

        // [ ExpressionList ]
        if (проверено(T.Запятая))
           es ~= разборСпискаВыражений();
        требуетсяЗакрыв(T.ПКвСкобка, leftBracket);

        в = new ВыражениеИндекс(в, es);
        goto Lset;
      default:
        return в;
      }
      далее();
    Lset: // Jumped here в пропусти далее().
      установи(в, начало);
    }
    assert(0);
  }

  Выражение parseUnaryExpression()
  {
    auto начало = сема;
    Выражение в;
    switch (сема.вид)
    {
    case T.ИБинарное:
      далее();
      в = new ВыражениеАдрес(parseUnaryExpression());
      break;
    case T.ПлюсПлюс:
      далее();
      в = new ВыражениеПреИнкр(parseUnaryExpression());
      break;
    case T.МинусМинус:
      далее();
      в = new ВыражениеПреДекр(parseUnaryExpression());
      break;
    case T.Умножь:
      далее();
      в = new ВыражениеДереф(parseUnaryExpression());
      break;
    case T.Минус:
    case T.Плюс:
      далее();
      в = new ВыражениеЗнак(parseUnaryExpression());
      break;
    case T.Не:
      далее();
      в = new ВыражениеНе(parseUnaryExpression());
      break;
    case T.Тильда:
      далее();
      в = new ВыражениеКомп(parseUnaryExpression());
      break;
    case T.Нов:
      в = разборВыраженияНов();
      return в;
    case T.Удалить:
      далее();
      в = new ВыражениеУдали(parseUnaryExpression());
      break;
    case T.Каст:
      требуетсяСледующий(T.ЛСкобка);
      Тип тип;
      switch (сема.вид)
      {
      version(D2)
      {
      auto begin2 = сема;
      case T.Конст:
        тип = new ТКонст(null);
        goto case_break;
      case T.Инвариант:
        тип = new ТИнвариант(null);
      case_break:
        далее();
        установи(тип, begin2);
        break;
      }
      default:
       тип = разборТипа();
      }
      требуется(T.ПСкобка);
      в = new ВыражениеКаст(parseUnaryExpression(), тип);
      break;
    case T.ЛСкобка:
      // ( Тип ) . Идентификатор
      Тип parseType_()
      {
        пропусти(T.ЛСкобка);
        auto тип = разборТипа();
        требуется(T.ПСкобка);
        требуется(T.Точка);
        return тип;
      }
      бул успех;
      auto тип = пробуй_(&parseType_, успех);
      if (успех)
      {
        auto идент = требуетсяИдентификатор(сооб.ExpectedIdAfterTypeDot);
        в = new ВыражениеИдТипаТочка(тип, идент);
        break;
      }
      goto default;
    case T.Точка:
      далее();
      в = new ВыражениеМасштабМодуля(разборВыраженияИдентификатора());
      break;
    default:
      в = parsePrimaryExpression();
      return в;
    }
    assert(в !is null);
    установи(в, начало);
    return в;
  }

  /// $(PRE
  /// ВыражениеИдентификатор :=
  ///         Идентификатор
  ///         TemplateInstance
  /// TemplateInstance :=
  ///         Идентификатор !( АргументыШаблона )
  /// )
  Выражение разборВыраженияИдентификатора()
  {
    auto начало = сема;
    auto идент = требуетсяИдентификатор(сооб.ОжидалсяИдентификатор);
    Выражение в;
    // Peek for '(' в avoid matching: ид !is ид
    if (сема.вид == T.Не && возьмиСледщ() == T.ЛСкобка)
    { // Идентификатор !( АргументыШаблона )
      пропусти(T.Не);
      auto шпарамы = parseTemplateArguments();
      в = new ВыражениеЭкземплярШаблона(идент, шпарамы);
    }
    else // Идентификатор
      в = new ВыражениеИдентификатор(идент);
    return установи(в, начало);
  }

  Выражение parseNewOrIdentifierExpression()
  {
    return сема.вид == T.Нов ? разборВыраженияНов() :  разборВыраженияИдентификатора();
  }

  Выражение parsePrimaryExpression()
  {
    auto начало = сема;
    Выражение в;
    switch (сема.вид)
    {
    case T.Идентификатор:
      в = разборВыраженияИдентификатора();
      return в;
    case T.Типа:
      в = new ВыражениеТипа(parseTypeofType());
      break;
    case T.Этот:
      далее();
      в = new ВыражениеЭтот();
      break;
    case T.Супер:
      далее();
      в = new ВыражениеСупер();
      break;
    case T.Нуль:
      далее();
      в = new ВыражениеНуль();
      break;
    case T.Истина, T.Ложь:
      далее();
      в = new БулевоВыражение(сема.вид == T.Истина);
      break;
    case T.Доллар:
      далее();
      в = new ВыражениеДоллар();
      break;
    case T.Цел32, T.Цел64, T.Бцел32, T.Бцел64:
      в = new ЦелВыражение(сема);
      далее();
      break;
    case T.Плав32, T.Плав64, T.Плав80,
         T.Мнимое32, T.Мнимое64, T.Мнимое80:
      в = new ВыражениеРеал(сема);
      далее();
      break;
    case T.СимЛитерал:
      в = new ВыражениеСим(сема.дим_);
      далее();
      break;
    case T.Ткст:
      ткст ткт = сема.ткт;
      сим postfix = сема.pf;
      далее();
      while (сема.вид == T.Ткст)
      {
        /+if (postfix == 0)
            postfix = сема.pf;
        else+/
        if (сема.pf && сема.pf != postfix)
          ошибка(сема, сооб.StringPostfixMismatch);
        ткт.length = ткт.length - 1; // Exclude '\0'.
        ткт ~= сема.ткт;
        далее();
      }
      switch (postfix)
      {
      case 'w':
        if (естьНеверныйЮ8(ткт, начало))
          goto default;
        в = new ТекстовоеВыражение(drc.Unicode.вЮ16(ткт)); break;
      case 'd':
        if (естьНеверныйЮ8(ткт, начало))
          goto default;
        в = new ТекстовоеВыражение(drc.Unicode.вЮ32(ткт)); break;
      case 'c':
      default:
        // No checking done в allow for binary данные.
        в = new ТекстовоеВыражение(ткт); break;
      }
      break;
    case T.ЛКвСкобка:
      Выражение[] значения;

      далее();
      if (!проверено(T.ПКвСкобка))
      {
        в = разборВыраженияПрисвой();
        if (проверено(T.Двоеточие))
          goto LparseAssocArray;
        if (проверено(T.Запятая))
          значения = [в] ~ разборСпискаВыражений();
        требуетсяЗакрыв(T.ПКвСкобка, начало);
      }

      в = new ВыражениеЛитералМассива(значения);
      break;

    LparseAssocArray:
      Выражение[] ключи = [в];

      goto LenterLoop;
      do
      {
        ключи ~= разборВыраженияПрисвой();
        требуется(T.Двоеточие);
      LenterLoop:
        значения ~= разборВыраженияПрисвой();
      } while (проверено(T.Запятая))
      требуетсяЗакрыв(T.ПКвСкобка, начало);
      в = new ВыражениеЛитералАМассива(ключи, значения);
      break;
    case T.ЛФСкобка:
      // DelegateLiteral := { Statements }
      auto телоФунк = разборТелаФункции();
      в = new ВыражениеЛитералФункции(телоФунк);
      break;
    case T.Функция, T.Делегат:
      // FunctionLiteral := ("function"|"delegate") Тип? "(" ArgumentList ")" FunctionBody
      далее(); // Skip function or delegate keyword.
      Тип типВозврата;
      Параметры параметры;
      if (сема.вид != T.ЛФСкобка)
      {
        if (сема.вид != T.ЛСкобка) // Optional return тип
          типВозврата = разборТипа();
        параметры = разборСпискаПараметров();
      }
      auto телоФунк = разборТелаФункции();
      в = new ВыражениеЛитералФункции(типВозврата, параметры, телоФунк);
      break;
    case T.Подтвердить:
      Выражение сооб;
      требуетсяСледующий(T.ЛСкобка);
      в = разборВыраженияПрисвой();
      if (проверено(T.Запятая))
        сооб = разборВыраженияПрисвой();
      требуется(T.ПСкобка);
      в = new ВыражениеПодтверди(в, сооб);
      break;
    case T.Смесь:
      требуетсяСледующий(T.ЛСкобка);
      в = разборВыраженияПрисвой();
      требуется(T.ПСкобка);
      в = new ВыражениеСмесь(в);
      break;
    case T.Импорт:
      требуетсяСледующий(T.ЛСкобка);
      в = разборВыраженияПрисвой();
      требуется(T.ПСкобка);
      в = new ВыражениеИмпорта(в);
      break;
    case T.Идтипа:
      требуетсяСледующий(T.ЛСкобка);
      auto тип = разборТипа();
      требуется(T.ПСкобка);
      в = new ВыражениеИдТипа(тип);
      break;
    case T.Является:
      далее();
      auto leftParen = сема;
      требуется(T.ЛСкобка);

      Тип тип, типСпец;
      Идентификатор* идент; // optional Идентификатор
      Сема* opTok, specTok;

      тип = разборДекларатора(идент, да);

      switch (сема.вид)
      {
      case T.Двоеточие, T.Равно:
        opTok = сема;
        далее();
        switch (сема.вид)
        {
        case T.Типдеф,
             T.Структура,
             T.Союз,
             T.Класс,
             T.Интерфейс,
             T.Перечень,
             T.Функция,
             T.Делегат,
             T.Супер,
             T.Итог:
        case_Const_Invariant:
          specTok = сема;
          далее();
          break;
        case T.Конст, T.Инвариант:
          if (возьмиСледщ() != T.ЛСкобка)
            goto case_Const_Invariant;
          // Fall through. It's a тип.
        default:
          типСпец = разборТипа();
        }
      default:
      }

      ПараметрыШаблона шпарамы;
    version(D2)
    {
      // is ( Тип Идентификатор : TypeSpecialization , TemplateParameterList )
      // is ( Тип Идентификатор == TypeSpecialization , TemplateParameterList )
      if (идент && типСпец && сема.вид == T.Запятая)
        шпарамы = разборСпискаПараметровШаблона2();
    }
      требуетсяЗакрыв(T.ПСкобка, leftParen);
      в = new ВыражениеЯвляется(тип, идент, opTok, specTok, типСпец, шпарамы);
      break;
    case T.ЛСкобка:
      if (семаПослеСкобкиЯвляется(T.ЛФСкобка)) // Check for "(...) {"
      { // ( ParameterList ) FunctionBody
        auto параметры = разборСпискаПараметров();
        auto телоФунк = разборТелаФункции();
        в = new ВыражениеЛитералФункции(null, параметры, телоФунк);
      }
      else
      { // ( Выражение )
        auto leftParen = сема;
        пропусти(T.ЛСкобка);
        в = разборВыражения();
        требуетсяЗакрыв(T.ПСкобка, leftParen);
        в = new ВыражениеРодит(в);
      }
      break;
    version(D2)
    {
    case T.Трэтс:
      требуетсяСледующий(T.ЛСкобка);
      auto ид = требуетсяИдентификатор(сооб.ОжидалсяИдентификатор);
      АргументыШаблона арги;
      if (сема.вид == T.Запятая)
        арги = parseTemplateArguments2();
      else
        требуется(T.ПСкобка);
      в = new ВыражениеТрактовки(ид, арги);
      break;
    }
    default:
      if (сема.интегральныйТип_ли)
      { // ИнтегральныйТип . Идентификатор
        auto тип = new ИнтегральныйТип(сема.вид);
        далее();
        установи(тип, начало);
        требуется(T.Точка);
        auto идент = требуетсяИдентификатор(сооб.ExpectedIdAfterTypeDot);
        в = new ВыражениеИдТипаТочка(тип, идент);
      }
      else if (сема.спецСема_ли)
      {
        в = new ВыражениеСпецСема(сема);
        далее();
      }
      else
      {
        ошибка2(ИДС.НайденоИноеЧемОжидалось, "Выражение", сема);
        в = new НелегальноеВыражение();
        if (!пробуем)
        { // Insert a dummy сема and don't consume current one.
          начало = лексер.вставьПустуюСемуПеред(сема);
          this.предыдущСема = начало;
        }
      }
    }
    установи(в, начало);
    return в;
  }

  Выражение разборВыраженияНов(/*Выражение в*/)
  {
    auto начало = сема;
    пропусти(T.Нов);

    Выражение[] аргиНов;
    Выражение[] аргиКтора;

    if (сема.вид == T.ЛСкобка)
      аргиНов = разборАргументов();

    // ВыражениеНовАнонКласс:
    //         new (ArgumentList)opt class (ArgumentList)opt SuperClassopt ЦелerfaceClassesopt ClassBody
    if (проверено(T.Класс))
    {
      if (сема.вид == T.ЛСкобка)
        аргиКтора = разборАргументов();

      ТипКлассОснова[] основы = сема.вид != T.ЛФСкобка ? разборБазовыхКлассов(нет) : null ;

      auto деклы = разборТелаДефиницииДекларации();
      return установи(new ВыражениеНовАнонКласс(/*в, */аргиНов, основы, аргиКтора, деклы), начало);
    }

    // ВыражениеНов:
    //         NewArguments Тип [ ВыражениеПрисвой ]
    //         NewArguments Тип ( ArgumentList )
    //         NewArguments Тип
    auto тип = разборТипа();

    if (сема.вид == T.ЛСкобка)
      аргиКтора = разборАргументов();

    return установи(new ВыражениеНов(/*в, */аргиНов, тип, аргиКтора), начало);
  }

  /// Parses a Тип.
  Тип разборТипа()
  {
    return разборБазовогоТипа2(разборБазовогоТипа());
  }

  Тип разборТипаИдентификатора()
  {
    auto начало = сема;
    auto идент = требуетсяИдентификатор(сооб.ОжидалсяИдентификатор);
    Тип t;
    if (проверено(T.Не)) // Идентификатор !( АргументыШаблона )
      t = new ТЭкземплярШаблона(идент, parseTemplateArguments());
    else // Идентификатор
      t = new ТИдентификатор(идент);
    return установи(t, начало);
  }

  Тип разборКвалифицированногоТипа()
  {
    auto начало = сема;
    Тип тип;
    if (сема.вид == T.Точка)
      тип = установи(new ТМасштабМодуля(), начало, начало);
    else if (сема.вид == T.Типа)
      тип = parseTypeofType();
    else
      тип = разборТипаИдентификатора();

    while (проверено(T.Точка))
      тип = установи(new КвалифицированныйТип(тип, разборТипаИдентификатора()), начало);
    return тип;
  }

  Тип разборБазовогоТипа()
  {
    auto начало = сема;
    Тип t;

    if (сема.интегральныйТип_ли)
    {
      t = new ИнтегральныйТип(сема.вид);
      далее();
    }
    else
    switch (сема.вид)
    {
    case T.Идентификатор, T.Типа, T.Точка:
      t = разборКвалифицированногоТипа();
      return t;
    version(D2)
    {
    case T.Конст:
      // const ( Тип )
      требуетсяСледующий(T.ЛСкобка);
      t = разборТипа();
      требуется(T.ПСкобка);
      t = new ТКонст(t);
      break;
    case T.Инвариант:
      // invariant ( Тип )
      требуетсяСледующий(T.ЛСкобка);
      t = разборТипа();
      требуется(T.ПСкобка);
      t = new ТИнвариант(t);
      break;
    } // version(D2)
    default:
      ошибка2(ИДС.НайденоИноеЧемОжидалось, "BasicType", сема);
      t = new НелегальныйТип();
      далее();
    }
    return установи(t, начало);
  }

  Тип разборБазовогоТипа2(Тип t)
  {
    while (1)
    {
      auto начало = сема;
      switch (сема.вид)
      {
      case T.Умножь:
        t = new ТУказатель(t);
        далее();
        break;
      case T.ЛКвСкобка:
        t = разборТипаМассив(t);
        continue;
      case T.Функция, T.Делегат:
        TOK лекс = сема.вид;
        далее();
        auto параметры = разборСпискаПараметров();
        if (лекс == T.Функция)
          t = new ТФункция(t, параметры);
        else
          t = new ТДелегат(t, параметры);
        break;
      default:
        return t;
      }
      установи(t, начало);
    }
    assert(0);
  }

  /// Returns да if the сема after the закрывающий parenthesis
  /// matches the searched вид.
  бул семаПослеСкобкиЯвляется(TOK вид)
  {
    assert(сема.вид == T.ЛСкобка);
    auto следщ = сема;
    return пропустиСкобку(следщ) == вид;
  }

  /// определено
  бул семаПослеСкобкиЯвляется(TOK вид, ref Сема* следщ)
  {
    assert(следщ !is null && следщ.вид == T.ЛСкобка);
    return пропустиСкобку(следщ) == вид;
  }

  /// Skips в the сема behind the закрывающий parenthesis.
  /// Takes nested parentheses into account.
  TOK пропустиСкобку(ref Сема* следщ)
  {
    assert(следщ !is null && следщ.вид == T.ЛСкобка);
    // We счёт nested parentheses семы because template types, typeof etc.
    // may appear внутри parameter lists. E.g.: (цел x, Foo!(цел) y)
    бцел уровень = 1;
  Loop:
    while (1)
      switch (возьмиПосле(следщ))
      {
      case T.ЛСкобка:
        ++уровень;
        break;
      case T.ПСкобка:
        if (--уровень == 0)
          return возьмиПосле(следщ); // Closing parenthesis found.
        break;
      case T.КФ:
        return T.КФ;
      default:
      }
    assert(0, "должно быть недоступно");
  }

  /// Parse the массив types after the declarator (C-style.) E.g.: цел a[]
  Тип разборСуффиксаДекларатора(Тип lhsType)
  {
    // The Тип chain should be as follows:
    // цел[3]* Идентификатор [][32]
    //   <- <-             ->  -.
    //       ^-----------------´
    // Итогing chain: [][32]*[3]цел
    Тип разборСледующего() // Nested function required в accomplish this.
    {
      if (сема.вид != T.ЛКвСкобка)
        return lhsType; // Всё recursion; return Тип on the левый hand сторона of the Идентификатор.

      auto начало = сема;
      Тип t;
      пропусти(T.ЛКвСкобка);
      if (проверено(T.ПКвСкобка))
        t = new ТМассив(разборСледующего()); // [ ]
      else
      {
        бул успех;
        Тип разборТипаАМ()
        {
          auto тип = разборТипа();
          требуется(T.ПКвСкобка);
          return тип;
        }
        auto ассоцТип = пробуй_(&разборТипаАМ, успех);
        if (успех)
          t = new ТМассив(разборСледующего(), ассоцТип); // [ Тип ]
        else
        {
          Выражение в = разборВыражения(), e2;
          if (проверено(T.Срез))
            e2 = разборВыражения();
          требуетсяЗакрыв(T.ПКвСкобка, начало);
          t = new ТМассив(разборСледующего(), в, e2); // [ Выражение .. Выражение ]
        }
      }
      установи(t, начало);
      return t;
    }
    return разборСледующего();
  }

  Тип разборТипаМассив(Тип t)
  {
    auto начало = сема;
    пропусти(T.ЛКвСкобка);
    if (проверено(T.ПКвСкобка))
      t = new ТМассив(t);
    else
    {
      бул успех;
      Тип разборТипаАМ()
      {
        auto тип = разборТипа();
        требуется(T.ПКвСкобка);
        return тип;
      }
      auto ассоцТип = пробуй_(&разборТипаАМ, успех);
      if (успех)
        t = new ТМассив(t, ассоцТип);
      else
      {
        Выражение в = разборВыражения(), e2;
        if (проверено(T.Срез))
          e2 = разборВыражения();
        требуетсяЗакрыв(T.ПКвСкобка, начало);
        t = new ТМассив(t, в, e2);
      }
    }
    установи(t, начало);
    return t;
  }

  Тип разборТипаУказательНаФункциюСи(Тип тип, ref Идентификатор* идент, бул опцСписокПарам)
  {
    assert(тип !is null);
    auto начало = сема;
    пропусти(T.ЛСкобка);

    тип = разборБазовогоТипа2(тип);
    if (сема.вид == T.ЛСкобка)
    { // Can be nested.
      тип = разборТипаУказательНаФункциюСи(тип, идент, да);
    }
    else if (сема.вид == T.Идентификатор)
    { // The identifier of the function pointer and the declaration.
      идент = сема.идент;
      далее();
      тип = разборСуффиксаДекларатора(тип);
    }
    требуетсяЗакрыв(T.ПСкобка, начало);

    Параметры парамы;
    if (опцСписокПарам)
      парамы = сема.вид == T.ЛСкобка ? разборСпискаПараметров() : null;
    else
      парамы = разборСпискаПараметров();

    тип = new ТУказательНаФункСи(тип, парамы);
    return установи(тип, начало);
  }

  Тип разборДекларатора(ref Идентификатор* идент, бул identOptional = нет)
  {
    auto t = разборТипа();

    if (сема.вид == T.ЛСкобка)
      t = разборТипаУказательНаФункциюСи(t, идент, да);
    else if (сема.вид == T.Идентификатор)
    {
      идент = сема.идент;
      далее();
      t = разборСуффиксаДекларатора(t);
    }

    if (идент is null && !identOptional)
      ошибка2(сооб.ОжидалсяИдентификаторДекларатора, сема);

    return t;
  }

  /// Parses a список of AssignExpressions.
  /// $(PRE
  /// ExpressionList :=
  ///   ВыражениеПрисвой
  ///   ВыражениеПрисвой , ExpressionList
  /// )
  Выражение[] разборСпискаВыражений()
  {
    Выражение[] выражения;
    do
      выражения ~= разборВыраженияПрисвой();
    while(проверено(T.Запятая))
    return выражения;
  }

  /// Parses a список of Аргументы.
  /// $(PRE
  /// Аргументы :=
  ///   ( )
  ///   ( ExpressionList )
  /// )
  Выражение[] разборАргументов()
  {
    auto leftParen = сема;
    пропусти(T.ЛСкобка);
    Выражение[] арги;
    if (сема.вид != T.ПСкобка)
      арги = разборСпискаВыражений();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    return арги;
  }

  /// Parses a ParameterList.
  Параметры разборСпискаПараметров()
  out(парамы)
  {
    if (парамы.length > 1)
      foreach (парам; парамы.элементы[0..$-1])
      {
        if (парам.вариадический_ли())
          assert(0, "вариадические аргументы могут появляться только в конце списка параметров.");
      }
  }
  body
  {
    auto начало = сема;
    требуется(T.ЛСкобка);

    auto парамы = new Параметры();

    if (проверено(T.ПСкобка))
      return установи(парамы, начало);

    do
    {
      auto paramBegin = сема;
      КлассХранения кхр, stc_;
      Тип тип;
      Идентификатор* идент;
      Выражение дефЗначение;

      проц  pushParameter()
      {
        парамы ~= установи(new Параметр(кхр, тип, идент, дефЗначение), paramBegin);
      }

      if (проверено(T.Эллипсис))
      {
        кхр = КлассХранения.Вариадический;
        pushParameter(); // тип, идент and дефЗначение will be null.
        break;
      }

      while (1)
      { // Parse storage classes.
        switch (сема.вид)
        {
      version(D2)
      {
        case T.Инвариант: // D2.0
          if (возьмиСледщ() == T.ЛСкобка)
            break;
          stc_ = КлассХранения.Инвариант;
          goto Lcommon;
        case T.Конст: // D2.0
          if (возьмиСледщ() == T.ЛСкобка)
            break;
          stc_ = КлассХранения.Конст;
          goto Lcommon;
        case T.Окончательный: // D2.0
          stc_ = КлассХранения.Окончательный;
          goto Lcommon;
        case T.Масштаб: // D2.0
          stc_ = КлассХранения.Масштаб;
          goto Lcommon;
        case T.Статический: // D2.0
          stc_ = КлассХранения.Статический;
          goto Lcommon;
      }
        case T.Вхо:
          stc_ = КлассХранения.Вхо;
          goto Lcommon;
        case T.Вых:
          stc_ = КлассХранения.Вых;
          goto Lcommon;
        case T.Вховых, T.Реф:
          stc_ = КлассХранения.Реф;
          goto Lcommon;
        case T.Отложенный:
          stc_ = КлассХранения.Отложенный;
          goto Lcommon;
        Lcommon:
          // Check for redundancy.
          if (кхр & stc_)
            ошибка2(ИДС.ПовторяющийсяКлассХранения, сема);
          else
            кхр |= stc_;
          далее();
        version(D2)
          continue;
        else
          break; // Вхо D1.0 the grammar only allows one storage class.
        default:
        }
        break; // Всё out of inner loop.
      }
      тип = разборДекларатора(идент, да);

      if (проверено(T.Присвоить))
        дефЗначение = разборВыраженияПрисвой();

      if (проверено(T.Эллипсис))
      {
        кхр |= КлассХранения.Вариадический;
        pushParameter();
        break;
      }
      pushParameter();

    } while (проверено(T.Запятая))
    требуетсяЗакрыв(T.ПСкобка, начало);
    return установи(парамы, начало);
  }

  АргументыШаблона parseTemplateArguments()
  {
    АргументыШаблона шарги;
    auto leftParen = сема;
    требуется(T.ЛСкобка);
    if (сема.вид != T.ПСкобка)
      шарги = разборАргументовШаблона_();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    return шарги;
  }

version(D2)
{
  АргументыШаблона parseTemplateArguments2()
  {
    пропусти(T.Запятая);
    АргументыШаблона шарги;
    if (сема.вид != T.ПСкобка)
      шарги = разборАргументовШаблона_();
    else
      ошибка(сема, сооб.ОжидалсяТипИлиВыражение);
    требуется(T.ПСкобка);
    return шарги;
  }
} // version(D2)

  АргументыШаблона разборАргументовШаблона_()
  {
    auto начало = сема;
    auto шарги = new АргументыШаблона;
    do
    {
      Тип parseType_()
      {
        auto тип = разборТипа();
        if (сема.вид == T.Запятая || сема.вид == T.ПСкобка)
          return тип;
        провал_пробы();
        return null;
      }
      бул успех;
      auto typeArgument = пробуй_(&parseType_, успех);
      if (успех)
        // TemplateArgument:
        //         Тип
        //         Символ
        шарги ~= typeArgument;
      else
        // TemplateArgument:
        //         ВыражениеПрисвой
        шарги ~= разборВыраженияПрисвой();
    } while (проверено(T.Запятая))
    установи(шарги, начало);
    return шарги;
  }

  /// if ( ConstraintExpression )
  Выражение разборДополнительногоКонстрейнта()
  {
    if (!проверено(T.Если))
      return null;
    требуется(T.ЛСкобка);
    auto в = разборВыражения();
    требуется(T.ПСкобка);
    return в;
  }

  ПараметрыШаблона разборСпискаПараметровШаблона()
  {
    auto начало = сема;
    auto шпарамы = new ПараметрыШаблона;
    требуется(T.ЛСкобка);
    if (сема.вид != T.ПСкобка)
      разборСпискаПараметровШаблона_(шпарамы);
    требуетсяЗакрыв(T.ПСкобка, начало);
    return установи(шпарамы, начало);
  }

version(D2)
{
  ПараметрыШаблона разборСпискаПараметровШаблона2()
  {
    пропусти(T.Запятая);
    auto начало = сема;
    auto шпарамы = new ПараметрыШаблона;
    if (сема.вид != T.ПСкобка)
      разборСпискаПараметровШаблона_(шпарамы);
    else
      ошибка(сема, сооб.ОжидалисьПараметрыШаблона);
    return установи(шпарамы, начало);
  }
} // version(D2)

  /// Parses template параметры.
  проц  разборСпискаПараметровШаблона_(ПараметрыШаблона шпарамы)
  {
    do
    {
      auto paramBegin = сема;
      ПараметрШаблона tp;
      Идентификатор* идент;
      Тип типСпец, дефТип;

      проц  разборСпецИИлиДефолтнТипа()
      {
        // : SpecializationType
        if (проверено(T.Двоеточие))
          типСпец = разборТипа();
        // = DefaultType
        if (проверено(T.Присвоить))
          дефТип = разборТипа();
      }

      switch (сема.вид)
      {
      case T.Алиас:
        // ПараметрАлиасШаблона:
        //         alias Идентификатор
        пропусти(T.Алиас);
        идент = требуетсяИдентификатор(сооб.ОжидалсяАлиасПараметраШаблона);
        разборСпецИИлиДефолтнТипа();
        tp = new ПараметрАлиасШаблона(идент, типСпец, дефТип);
        break;
      case T.Идентификатор:
        идент = сема.идент;
        switch (возьмиСледщ())
        {
        case T.Эллипсис:
          // ПараметрКортежШаблона:
          //         Идентификатор ...
          пропусти(T.Идентификатор); пропусти(T.Эллипсис);
          if (сема.вид == T.Запятая)
            ошибка(ИДС.ПараметрКортежШаблона);
          tp = new ПараметрКортежШаблона(идент);
          break;
        case T.Запятая, T.ПСкобка, T.Двоеточие, T.Присвоить:
          // ПараметрТипаШаблона:
          //         Идентификатор
          пропусти(T.Идентификатор);
          разборСпецИИлиДефолтнТипа();
          tp = new ПараметрТипаШаблона(идент, типСпец, дефТип);
          break;
        default:
          // ПараметрШаблонЗначения:
          //         Declarator
          идент = null;
          goto LTemplateValueParameter;
        }
        break;
      version(D2)
      {
      case T.Этот:
        // ПараметрЭтотШаблона
        //         this ПараметрТипаШаблона
        пропусти(T.Этот);
        идент = требуетсяИдентификатор(сооб.ОжидалосьИмяДляПараметраШаблонаThis);
        разборСпецИИлиДефолтнТипа();
        tp = new ПараметрЭтотШаблона(идент, типСпец, дефТип);
        break;
      }
      default:
      LTemplateValueParameter:
        // ПараметрШаблонЗначения:
        //         Declarator
        Выражение спецЗначение, дефЗначение;
        auto типЗначение = разборДекларатора(идент);
        // : SpecializationValue
        if (проверено(T.Двоеточие))
          спецЗначение = разборУсловнВыражения();
        // = DefaultValue
        if (проверено(T.Присвоить))
          дефЗначение = разборУсловнВыражения();
        tp = new ПараметрШаблонЗначения(типЗначение, идент, спецЗначение, дефЗначение);
      }

      // Push template parameter.
      шпарамы ~= установи(tp, paramBegin);

    } while (проверено(T.Запятая))
  }

  /// Returns the ткст of a сема printable в the client.
  ткст дайПечатный(Сема* сема)
  { // TODO: there are some другой семы that have в be handled, в.g. тксты.
    return сема.вид == T.КФ ? "КФ" : сема.исхТекст;
  }

  alias требуется ожидаемое;

  /// Requires a сема of вид лекс.
  проц  требуется(TOK лекс)
  {
    if (сема.вид == лекс)
      далее();
    else
      ошибка2(ИДС.НайденоИноеЧемОжидалось, Сема.вТкст(лекс), сема);
  }

  /// Requires the следщ сема в be of вид лекс.
  проц  требуетсяСледующий(TOK лекс)
  {
    далее();
    требуется(лекс);
  }

  /// Optionally parses an identifier.
  /// Возвращает: null or the identifier.
  Идентификатор* дополнительныйИдентификатор()
  {
    Идентификатор* ид;
    if (сема.вид == T.Идентификатор)
      (ид = сема.идент), пропусти(T.Идентификатор);
    return ид;
  }

  Идентификатор* требуетсяИдентификатор()
  {
    Идентификатор* ид;
    if (сема.вид == T.Идентификатор)
      (ид = сема.идент), пропусти(T.Идентификатор);
    else
      ошибка(ИДС.НайденоИноеЧемОжидалось, "Идентификатор", сема.исхТекст);
    return ид;
  }

  /// Reports an ошибка if the current сема is not an identifier.
  /// Параметры:
  ///   ошСооб = the ошибка сообщение в be used.
  /// Возвращает: null or the identifier.
  Идентификатор* требуетсяИдентификатор(ткст ошСооб)
  {
    Идентификатор* ид;
    if (сема.вид == T.Идентификатор)
      (ид = сема.идент), пропусти(T.Идентификатор);
    else
      ошибка(сема, ошСооб, сема.исхТекст);
    return ид;
  }

  /// Reports an ошибка if the current сема is not an identifier.
  /// Параметры:
  ///   идс = the ошибка сообщение ID в be used.
  /// Возвращает: null or the identifier.
  Идентификатор* требуетсяИдентификатор(ИДС идс)
  {
    Идентификатор* ид;
    if (сема.вид == T.Идентификатор)
      (ид = сема.идент), пропусти(T.Идентификатор);
    else
      ошибка(идс, сема.исхТекст);
    return ид;
  }

  /// Reports an ошибка if the current сема is not an identifier.
  /// Возвращает: null or the сема.
  Сема* требуетсяИд()
  {
    Сема* семаИд;
    if (сема.вид == T.Идентификатор)
      (семаИд = сема), пропусти(T.Идентификатор);
    else
      ошибка(ИДС.НайденоИноеЧемОжидалось, "Идентификатор", сема.исхТекст);
    return семаИд;
  }

  Сема* требуетсяСемаИд(ткст ошСооб)
  {
    Сема* семаИд;
    if (сема.вид == T.Идентификатор)
      (семаИд = сема), пропусти(T.Идентификатор);
    else
    {
      ошибка(сема, ошСооб, сема.исхТекст);
      семаИд = лексер.вставьПустуюСемуПеред(сема);
      this.предыдущСема = семаИд;
    }
    return семаИд;
  }

  /// Reports an ошибка if the закрывающий counterpart of a сема is not found.
  проц  требуетсяЗакрыв(TOK закрывающий, Сема* открывающий)
  {
    assert(закрывающий == T.ПФСкобка || закрывающий == T.ПСкобка || закрывающий == T.ПКвСкобка);
    assert(открывающий !is null);
    if (!проверено(закрывающий))
    {
      auto место = открывающий.дайРеальноеПоложение();
      auto открывающийLoc = Формат("(открывающий @{},{})", место.номСтр, место.номСтолб);
      //ошибка(сема, сооб.ExpectedClosing,
            //Сема.вТкст(закрывающий), открывающийLoc, дайПечатный(сема));
    }
  }

  /// Returns да if the ткст ткт has an invalid UTF-8 sequence.
  бул естьНеверныйЮ8(ткст ткт, Сема* начало)
  {
    auto invalidUTF8Seq = Лексер.найдиНедействительнуюПоследовательностьУТФ8(ткт);
    if (invalidUTF8Seq.length)
      ошибка(начало, сооб.НедействительнаяПоследовательностьУТФ8ВТексте, invalidUTF8Seq);
    return invalidUTF8Seq.length != 0;
  }

  /// Forwards ошибка параметры.
  проц  ошибка(Сема* сема, ткст форматирСооб, ...)
  {
    error_(сема, форматирСооб, _arguments, _argptr);
  }
  /// определено
  проц  ошибка(ИДС идс, ...)
  {
    error_(this.сема, ДайСооб(идс), _arguments, _argptr);
  }

  /// определено
  проц  ошибка2(ткст форматирСооб, Сема* сема)
  {
    ошибка(сема, форматирСооб, дайПечатный(сема));
  }
  /// определено
  проц  ошибка2(ИДС идс, Сема* сема)
  {
    ошибка(идс, дайПечатный(сема));
  }
  /// определено
  проц  ошибка2(ИДС идс, ткст арг, Сема* сема)
  {
    ошибка(идс, арг, дайПечатный(сема));
  }

  /// Создаёт отчёт об ошибках и добавляет его в список.
  /// Параметры:
  ///   сема = используется для получения позиции ошибки.
  ///   форматирСооб = сообщение компилятора об ошибке.
  проц  error_(Сема* сема, ткст форматирСооб, TypeInfo[] _arguments, base.спис_ва _argptr)
  {
    if (пробуем)
    {
      счётОшибок++;
      return;
    }
    auto положение = сема.дайПоложениеОшибки();
    auto сооб = Формат(_arguments, _argptr, форматирСооб);
    auto ошибка = new ОшибкаПарсера(положение, сооб);
    ошибки ~= ошибка;
    if (диаг !is null)
      диаг ~= ошибка;
  }
}
