module drc.parser.Parser;

import drc.lexer.Lexer,
       drc.lexer.IdTable;
import drc.ast.Node,
       drc.ast.Declarations,
       drc.ast.Statements,
       drc.ast.Expressions,
       drc.ast.Types,
       drc.ast.Parameters;
import drc.Messages;
import drc.Diagnostics;
import drc.Enums;
import drc.CompilerInfo;
import drc.SourceText;
import drc.Unicode;
import common;

import core.Vararg;

/// Парсер производит полный разбор дерева путём исследования
/// списка сем, предоставляемого Лексером.
class Парсер
{
  Лексер лексер; /// Используется для "лексирования" исходного кода.
  Сема* сема; /// Текущая непробельная сема.
  Сема* предыдущСема; /// Предыдущая непробельная сема.

  Диагностика диаг;
  ОшибкаПарсера[] ошибки; /// Массив сообщений об ошибках парсера.

  ДекларацияИмпорта[] импорты; /// ДекларацииИмпорта в исходном тексте.

  /// Атрибуты оцениваются на фазе парсирования.
  /// TODO: будет удалено. СемантическаяПроходка1 прозводит обработку атрибутов.
  ТипКомпоновки типКомпоновки;
  Защита защита; /// определено
  КлассХранения классХранения; /// определено
  бцел размерРаскладки = РАЗМЕР_РАСКЛАДКИ_ПО_УМОЛЧАНИЮ; /// определено

  private alias TOK T; /// Часто используется данным классом.
  private alias УзелТипа Тип;

  /// Строит объект Парсер.
  /// Параметры:
  ///   исхТекст = the UTF-8 source код.
  ///   диаг = используется для сбора сообщений об ошибке.
  this(ИсходныйТекст исхТекст, Диагностика диаг = пусто)
  {
    this.диаг = диаг;
    лексер = new Лексер(исхТекст, диаг);
  }

  /// Переходит к первой семе.
  protected проц  иниц()
  {
    далее();
    предыдущСема = сема;
  }

  /// Переходит к следующей семе.
  проц  далее()
  {
    предыдущСема = сема;
    do
    {
      лексер.следщСема();
      сема = лексер.сема;
    } while (сема.пробел) // Пропустим whitespace
  }

  /// Запускает парсер и возвращает парсированные декларации.
  СложнаяДекларация старт()
  {
    иниц();
    auto начало = сема;
    auto деклы = new СложнаяДекларация;
    if (сема.вид == T.Модуль)
      деклы ~= разборДекларацииМодуля();
    деклы.добавьОпцОтпрыски(разборДефиницииДеклараций());
    установи(деклы, начало);
    return деклы;
  }

  /// Запускает парсер и возвращает парсированные выражения.
  Выражение старт2()
  {
    иниц();
    return разборВыражения();
  }

  // Члены, относящиеся к методу пробуй_().
  бцел пробуем; /// Больше чем 0, если Парсер в пробуй_().
  бцел счётОшибок; /// Используется для отслеживания числа ошибок при обороте пробуй_().

  /// Этот метод выполняет делегат методРазбора и при ошибке
  /// состояние лексера и парсера восстанавливается.
  /// Возвращает: возвратное значение методРазбора().
  ТипИтога пробуй_(ТипИтога)(ТипИтога delegate() методРазбора, out бул успех)
  {
    // Сохранить члены.
    auto старСема     = this.сема;
    auto старПредшСема = this.предыдущСема;
    auto старСчёт     = this.счётОшибок;

    ++пробуем;
    auto результат = методРазбора();
    --пробуем;
    // Check if an ошибка occurred.
    if (счётОшибок != старСчёт)
    { // Восстановить члены.
      сема       = старСема;
      предыдущСема   = старПредшСема;
      лексер.сема = старСема;
      счётОшибок  = старСчёт;
      успех = нет;
    }
    else
      успех = да;
    return результат;
  }

  /// Вызывает неудачное завершение текущего вызова пробуй_().
  проц  провал_пробы()
  {
    assert(пробуем);
    счётОшибок++;
  }

  /// Устанавливает начало и конец семы узла синтактического древа.
  Класс установи(Класс)(Класс узел, Сема* начало)
  {
    узел.установиСемы(начало, this.предыдущСема);
    return узел;
  }

  ///Устанавливает начало и конец семы узла синтактического древа.
  Класс установи(Класс)(Класс узел, Сема* начало, Сема* конец)
  {
    узел.установиСемы(начало, конец);
    return узел;
  }

  /// Возвращает "да", если установи() has been called on a узел.
  static бул узелУстановлен(Узел узел)
  {
    return узел.начало !is пусто && узел.конец !is пусто;
  }

  /// Возвращает вид следующей семы.
  TOK возьмиСледщ()
  {
    Сема* следщ = сема;
    do
      лексер.возьми(следщ);
    while (следщ.пробел); // Пропустим whitespace
    return следщ.вид;
  }

  /// Возвращает род семы, следующей за т.
  TOK возьмиПосле(ref Сема* т)
  {
    assert(т !is пусто);
    do
      лексер.возьми(т);
    while (т.пробел); // Пропустим whitespace
    return т.вид;
  }

  /// Проверяет теущую сему на соответствие k по виду и возвращает да.
  бул проверено()(TOK k) // Templatized, so it's inlined.
  {
    return сема.вид == k ? (далее(), да) : нет;
  }

  /// Проверяет, чтобы текущая сема была ожидаемого вида,
  /// затем приступает за следующую сему.
  проц  пропусти()(TOK ожидаемыйВид)
  {
    assert(сема.вид == ожидаемыйВид /+|| *(цел*).иниц+/, сема.исхТекст());
    далее();
  }

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                       Методы парсинга деклараций                         |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

  Декларация разборДекларацииМодуля()
  {
    auto начало = сема;
    пропусти(T.Модуль);
    ПКИМодуля пкиМодуля;
    do
      пкиМодуля ~= требуетсяИдентификатор(сооб.ОжидалсяИдентификаторМодуля);
    while (проверено(T.Точка));
    требуется(T.ТочкаЗапятая);
    return установи(new ДекларацияМодуля(пкиМодуля), начало);
  }

  /// Парсирует "Дефиниции Деклараций" (определения объявлений) до конца файла.
  /// $(PRE
  /// DeclDefs :=
  ///     DeclDef
  ///     DeclDefs
  /// )
  Декларация[] разборДефиницииДеклараций()
  {
    Декларация[] деклы;
    while (сема.вид != T.КФ)
      деклы ~= разборДефиницииДекларации();
    return деклы;
  }

  /// Парсирует тело шаблона, класса, интерфейса структуры или союза.
  /// $(PRE
  /// DeclDefsBlock :=
  ///     { }
  ///     { DeclDefs }
  /// )
  СложнаяДекларация разборТелаДефиницииДекларации()
  {
    // Сохранить атрибуты.
    auto типКомпоновки  = this.типКомпоновки;
    auto защита   = this.защита;
    auto классХранения = this.классХранения;
    // Удалить атрибуты.
    this.типКомпоновки  = ТипКомпоновки.Нет;
    this.защита   = Защита.Нет;
    this.классХранения = КлассХранения.Нет;

    // Разобрать тело.
    auto начало = сема;
    auto деклы = new СложнаяДекларация;
    требуется(T.ЛФСкобка);
    while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
      деклы ~= разборДефиницииДекларации();
    требуетсяЗакрыв(T.ПФСкобка, начало);
    установи(деклы, начало);

    // Восстановить исходные значения.
    this.типКомпоновки  = типКомпоновки;
    this.защита   = защита;
    this.классХранения = классХранения;

    return деклы;
  }

  /// Парсирует ДефиницияДекларации.
  Декларация разборДефиницииДекларации()
  out(декл)
  { assert(узелУстановлен(декл)); }
  body
  {
    auto начало = сема;
    Декларация декл;
    switch (сема.вид)
    {
    case T.Расклад,
         T.Прагма,
         // Защита атрибуты
         T.Экспорт,
         T.Приватный,
         T.Пакет,
         T.Защищённый,
         T.Публичный:
      декл = разборИдентификатораАтрибута();
      break;
    // Stилиage classes
    case T.Экстерн,
         T.Устаревший,
         T.Перепись,
         T.Абстрактный,
         T.Синхронизованный,
         //T.Статический,
         T.Окончательный,
         T.Конст,
         //T.Инвариант, // D 2.0
         T.Авто,
         T.Масштаб:
    случай_СтатичАтрибут:
    случай_АтрибутИнвариант: // D 2.0
    случай_АтрибутПеречень: // D 2.0
      return разборАтрибутаСохранения();
    case T.Алиас:
      далее();
      декл = new ДекларацияАлиаса(разборПеременнойИлиФункции());
      break;
    case T.Типдеф:
      далее();
      декл = new ДекларацияТипдефа(разборПеременнойИлиФункции());
      break;
    case T.Статический:
      switch (возьмиСледщ())
      {
      case T.Импорт:
        goto случай_Импорт;
      case T.Этот:
        декл = разборДекларацииСтатичКонструктора();
        break;
      case T.Тильда:
        декл = разборДекларацииСтатичДеструктора();
        break;
      case T.Если:
        декл = парсируйДекларациюСтатичЕсли();
        break;
      case T.Подтвердить:
        декл = парсируйДекларациюСтатичАссерта();
        break;
      default:
        goto случай_СтатичАтрибут;
      }
      break;
    case T.Импорт:
    случай_Импорт:
      декл = разборДекларацииИмпорта();
      импорты ~= декл.в!(ДекларацияИмпорта);
      // Особая обработка. КлассХранения не должен быть установлен.
      декл.установиЗащиту(this.защита);
      return установи(декл, начало);
    case T.Перечень:
    version(D2)
    {
      if (манифестПеречня_ли())
        goto случай_АтрибутПеречень;
    }
      декл = разборДекларацииПеречня();
      break;
    case T.Класс:
      декл = разборДекларацииКласса();
      break;
    case T.Интерфейс:
      декл = разборДекларацииИнтерфейса();
      break;
    case T.Структура, T.Союз:
      декл = разборДекларацииСтруктурыИлиСоюза();
      break;
    case T.Этот:
      декл = разборДекларацииКонструктора();
      break;
    case T.Тильда:
      декл = разборДекларацииДеструктора();
      break;
    case T.Инвариант:
    version(D2)
    {
      auto следщ = сема;
      if (возьмиПосле(следщ) == T.ЛСкобка)
      {
        if (возьмиПосле(следщ) != T.ПСкобка)
          goto случай_Декларация;  // invariant ( Тип )
      }
      else
        goto случай_АтрибутИнвариант; // invariant as КлассХранения.
    }
      декл = разборДекларацииИнварианта(); // invariant ( )
      break;
    case T.Юниттест:
      декл = разборДекларацииЮниттеста();
      break;
    case T.Отладка:
      декл = разборДекларацииОтладки();
      break;
    case T.Версия:
      декл = парсируйДекларациюВерсии();
      break;
    case T.Шаблон:
      декл = парсируйДекларациюШаблона();
      break;
    case T.Нов:
      декл = парсируйДекларациюНов();
      break;
    case T.Удалить:
      декл = парсируйДекларациюУдалить();
      break;
    case T.Смесь:
      декл = парсируйМиксин!(ДекларацияСмеси)();
      break;
    case T.ТочкаЗапятая:
      далее();
      декл = new ПустаяДекларация();
      break;
    // Декларация
    case T.Идентификатор, T.Точка, T.Типа:
    случай_Декларация:
      return разборПеременнойИлиФункции(this.классХранения, this.защита, this.типКомпоновки);
    default:
      if (сема.интегральныйТип)
        goto случай_Декларация;
      else if (сема.вид == T.Модуль)
      {
        декл = разборДекларацииМодуля();
        ошибка(начало, сооб.ДекларацияМодуляНеПервая);
        return декл;
      }

      декл = new НелегальнаяДекларация();
      // Пропустим в следщ valid сема.
      do
        далее();
      while (!сема.началоДефДекл &&
              сема.вид != T.ПФСкобка &&
              сема.вид != T.КФ);
      auto текст = Сема.участокТекста(начало, this.предыдущСема);
      ошибка(начало, сооб.НелегальнаяДекларация, текст);
    }
    декл.установиЗащиту(this.защита);
    декл.установиКлассХранения(this.классХранения);
    assert(!узелУстановлен(декл));
    установи(декл, начало);
    return декл;
  }

  /// Разбирает БлокДеклараций.
  /// $(PRE
  /// БлокДеклараций :=
  ///     : DeclDefs
  ///     { }
  ///     { DeclDefs }
  ///     DeclDef
  /// )
  Декларация разборБлокаДеклараций(/+бул noДвоеточие = нет+/)
  {
    Декларация d;
    switch (сема.вид)
    {
    case T.ЛФСкобка:
      auto начало = сема;
      далее();
      auto деклы = new СложнаяДекларация;
      while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
        деклы ~= разборДефиницииДекларации();
      требуетсяЗакрыв(T.ПФСкобка, начало);
      d = установи(деклы, начало);
      break;
    case T.Двоеточие:
      // if (noДвоеточие == да)
      //   goto default;
      далее();
      auto начало = сема;
      auto деклы = new СложнаяДекларация;
      while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
        деклы ~= разборДефиницииДекларации();
      d = установи(деклы, начало);
      break;
    default:
      d = разборДефиницииДекларации();
    }
    assert(узелУстановлен(d));
    return d;
  }

  // Декларация разборБлокаДекларацийNoДвоеточие()
  // {
  //   return разборБлокаДеклараций(да);
  // }

  /// Разбирает либо ДекларацияПеременной или ДекларацияФункции.
  /// Параметры:
  ///   кхр = ранее разобранные классы сохранения
  ///   защита = ранее разобранный атрибут защиты
  ///   типКомпоновки = ранее разобранный тип компоновки
  ///   проверятьДекларациюАвто = проверять ли ДекларацияАвто
  ///   списокНеобязатПарамов = подсказка для разбора указателей на функции в Си-стиле
  Декларация разборПеременнойИлиФункции(КлассХранения кхр = КлассХранения.Нет,
                                      Защита защита = Защита.Нет,
                                      ТипКомпоновки типКомпоновки = ТипКомпоновки.Нет,
                                      бул проверятьДекларациюАвто = нет,
                                      бул списокНеобязатПарамов = да)
  {
    auto начало = сема;
    Тип тип;
    Идентификатор* имя;

    // Проверять ДекларацияАвто: КлассыСохранения Идентификатор =
    if (проверятьДекларациюАвто && сема.вид == T.Идентификатор)
    {
      auto вид = возьмиСледщ();
      if (вид == T.Присвоить)
      { // Декларация автоматической переменной.
        имя = сема.идент;
        пропусти(T.Идентификатор);
        goto LparseVariables;
      }
      else version(D2) if (вид == T.ЛСкобка)
      { // Проверим на auto return тип template function.
        // КлассыСохранения Имя ( TemplateParameterList ) ( СписокПараметров )
        имя = сема.идент;
        auto следщ = сема;
        возьмиПосле(следщ);
        if (семаПослеСкобкиЯвляется(T.ЛСкобка, следщ))
        {
          пропусти(T.Идентификатор);
          assert(сема.вид == T.ЛСкобка);
          goto LparseTPList; // Далее with parsing a template function.
        }
      }
    }

    тип = разборТипа(); // VariableType или ТипИтога

    if (сема.вид == T.ЛСкобка)
    { // Указатели на функции в стиле Си усложняют грамматику.
      // С ними приходится иметь дело отдельно, в масштабе функции.
      // Пример:
      //   проц  foo() {
      //     // Указатель на функцию, принимающий целое число и возвращающий 'some_type'.
      //     some_type (*p_func)(цел);
      //     // Вхо the following case precedence is given в a ВыражениеВызов.
      //     something(*у); // 'something' may be a function/method или an объект having opCall overloaded.
      //   }
      //   // A pointer в a function taking no параметры and returning 'something'.
      //   something(*у);
      тип = разборТипаУказательНаФункциюСи(тип, имя, списокНеобязатПарамов);
    }
    else if (возьмиСледщ() == T.ЛСкобка)
    { // Тип ИмяФункции ( СписокПараметров ) FunctionBody
      имя = требуетсяИдентификатор(сооб.ОжидалосьНазваниеФункции);
      имя || далее(); // Пропустим non-идентификатор сема.
      assert(сема.вид == T.ЛСкобка);
      // It's a function declaration
      ПараметрыШаблона шпарамы;
      Выражение констрейнт;

      if (семаПослеСкобкиЯвляется(T.ЛСкобка))
      LparseTPList:
        // ( TemplateParameterList ) ( СписокПараметров )
        шпарамы = разборСпискаПараметровШаблона();

      auto парамы = разборСпискаПараметров();
    version(D2)
    {
      if (шпарамы) // Если ( ConstraintExpression )
        констрейнт = разборДополнительногоКонстрейнта();
      switch (сема.вид)
      {
      case T.Конст:
        кхр |= КлассХранения.Конст;
        далее();
        break;
      case T.Инвариант:
        кхр |= КлассХранения.Инвариант;
        далее();
        break;
      default:
      }
    }
      // ТипИтога ИмяФункции ( СписокПараметров )
      auto телоФунк = разборТелаФункции();
      auto дф = new ДекларацияФункции(тип, имя,/+ шпарамы,+/ парамы, телоФунк);
      дф.установиКлассХранения(кхр);
      дф.установиТипКомпоновки(типКомпоновки);
      дф.установиЗащиту(защита);
      if (шпарамы)
      {
        auto d = поместиДекларациюВнутреннегоШаблона(начало, имя, дф, шпарамы, констрейнт);
        d.установиКлассХранения(кхр);
        d.установиЗащиту(защита);
        return установи(d, начало);
      }
      return установи(дф, начало);
    }
    else
    { // Тип ИмяПеременной СуффиксДекларатора
      имя = требуетсяИдентификатор(сооб.ОжидалосьНазваниеПеременной);
      тип = разборСуффиксаДекларатора(тип);
    }

  LparseVariables:
    // It's a переменные declaration.
    Идентификатор*[] имена = [имя]; // One идентификатор has been parsed already.
    Выражение[] значения;
    goto LenterLoop; // Enter the loop and check for an initializer.
    while (проверено(T.Запятая))
    {
      имена ~= требуетсяИдентификатор(сооб.ОжидалосьНазваниеПеременной);
    LenterLoop:
      if (проверено(T.Присвоить))
        значения ~= разборИнициализатора();
      else
        значения ~= пусто;
    }
    требуется(T.ТочкаЗапятая);
    auto d = new ДекларацияПеременных(тип, имена, значения);
    d.установиКлассХранения(кхр);
    d.установиТипКомпоновки(типКомпоновки);
    d.установиЗащиту(защита);
    return установи(d, начало);
  }

  /// Разбирает переменная initializer.
  Выражение разборИнициализатора()
  {
    if (сема.вид == T.Проц)
    {
      auto начало = сема;
      auto следщ = возьмиСледщ();
      if (следщ == T.Запятая || следщ == T.ТочкаЗапятая)
      {
        пропусти(T.Проц);
        return установи(new ВыражениеИницПроц(), начало);
      }
    }
    return разборНеПроцИнициализатора();
  }

  Выражение разборНеПроцИнициализатора()
  {
    auto начало = сема;
    Выражение иниц;
    switch (сема.вид)
    {
    case T.ЛКвСкобка:
      // МассивInitializer:
      //         [ ]
      //         [ МассивЧленInitializations ]
      Выражение[] ключи;
      Выражение[] значения;

      пропусти(T.ЛКвСкобка);
      while (сема.вид != T.ПКвСкобка)
      {
        auto в = разборНеПроцИнициализатора();
        if (проверено(T.Двоеточие))
        {
          ключи ~= в;
          значения ~= разборНеПроцИнициализатора();
        }
        else
        {
          ключи ~= пусто;
          значения ~= в;
        }

        if (!проверено(T.Запятая))
          break;
      }
      требуетсяЗакрыв(T.ПКвСкобка, начало);
      иниц = new ВыражениеИницМассива(ключи, значения);
      break;
    case T.ЛФСкобка:
      // StructInitializer:
      //         { }
      //         { StructЧленInitializers }
      Выражение разборИнициализатораСтрукт()
      {
        Идентификатор*[] иденты;
        Выражение[] значения;

        пропусти(T.ЛФСкобка);
        while (сема.вид != T.ПФСкобка)
        {
          if (сема.вид == T.Идентификатор &&
              // Peek for colon в see if this есть член идентификатор.
              возьмиСледщ() == T.Двоеточие)
          {
            иденты ~= сема.идент;
            пропусти(T.Идентификатор), пропусти(T.Двоеточие);
          }
          else
            иденты ~= пусто;

          // NonVoidInitializer
          значения ~= разборНеПроцИнициализатора();

          if (!проверено(T.Запятая))
            break;
        }
        требуетсяЗакрыв(T.ПФСкобка, начало);
        return new ВыражениеИницСтруктуры(иденты, значения);
      }

      бул успех;
      auto si = пробуй_(&разборИнициализатораСтрукт, успех);
      if (успех)
      {
        иниц = si;
        break;
      }
      assert(сема.вид == T.ЛФСкобка);
      //goto default;
    default:
      иниц = разборВыраженияПрисвой();
    }
    установи(иниц, начало);
    return иниц;
  }

  ИнструкцияТелаФункции разборТелаФункции()
  {
    auto начало = сема;
    auto функц = new ИнструкцияТелаФункции;
    while (1)
    {
      switch (сема.вид)
      {
      case T.ЛФСкобка:
        функц.телоФунк = разборИнструкций();
        break;
      case T.ТочкаЗапятая:
        далее();
        break;
      case T.Вхо:
        if (функц.телоВхо)
          ошибка(ИДС.КонтрактИн);
        далее();
        функц.телоВхо = разборИнструкций();
        continue;
      case T.Вых:
        if (функц.телоВых)
          ошибка(ИДС.КонтрактАут);
        далее();
        if (проверено(T.ЛСкобка))
        {
          auto левСкобка = this.предыдущСема;
          функц.outIdent = требуетсяИдентификатор(сооб.ОжидалсяИдентификатор);
          требуетсяЗакрыв(T.ПСкобка, левСкобка);
        }
        функц.телоВых = разборИнструкций();
        continue;
      case T.Тело:
        далее();
        goto case T.ЛФСкобка;
      default:
        ошибка2(сооб.ОжидалосьТелоФункции, сема);
      }
      break; // Exit loop.
    }
    установи(функц, начало);
    функц.завершиКонструкцию();
    return функц;
  }

  ТипКомпоновки разборТипаКомпоновки()
  {
    ТипКомпоновки типКомпоновки;

    if (!проверено(T.ЛСкобка))
      return типКомпоновки;

    if (проверено(T.ПСкобка))
    { // extern()
      ошибка(ИДС.ОтсутствуетТипКомпоновки);
      return типКомпоновки;
    }

    auto identTok = требуетсяИд();

    ВИД видИд = identTok ? identTok.идент.видИд : ВИД.Нуль;

    switch (видИд)
    {
    case ВИД.C:
      if (проверено(T.ПлюсПлюс))
      {
        типКомпоновки = ТипКомпоновки.Cpp;
        break;
      }
      типКомпоновки = ТипКомпоновки.C;
      break;
    case ВИД.D:
      типКомпоновки = ТипКомпоновки.D;
      break;
    case ВИД.Windows:
      типКомпоновки = ТипКомпоновки.Windows;
      break;
    case ВИД.Pascal:
      типКомпоновки = ТипКомпоновки.Pascal;
      break;
    case ВИД.System:
      типКомпоновки = ТипКомпоновки.Система;
      break;
    default:
      ошибка2(ИДС.НеопознанныйТипКомпоновки, сема);
    }
    требуется(T.ПСкобка);
    return типКомпоновки;
  }

  проц  проверьТипКомпоновки(ref ТипКомпоновки предш_тк, ТипКомпоновки тк, Сема* начало)
  {
    if (предш_тк == ТипКомпоновки.Нет)
      предш_тк = тк;
    else
      ошибка(начало, сооб.ПовторяющийсяТипЛинковки, Сема.участокТекста(начало, this.предыдущСема));
  }

  Декларация разборАтрибутаСохранения()
  {
    КлассХранения кхр, stc_tmp;
    ТипКомпоновки предш_типКомпоновки;

    auto saved_stилиageClass = this.классХранения; // Сохранить.
    // Nested function.
    Декларация разбор()
    {
      Декларация декл;
      auto начало = сема;
      switch (сема.вид)
      {
      case T.Экстерн:
        if (возьмиСледщ() != T.ЛСкобка)
        {
          stc_tmp = КлассХранения.Экстерн;
          goto Lcommon;
        }

        далее();
        auto типКомпоновки = разборТипаКомпоновки();
        проверьТипКомпоновки(предш_типКомпоновки, типКомпоновки, начало);

        auto сохранённое = this.типКомпоновки; // Сохранить.
        this.типКомпоновки = типКомпоновки; // Установить.
        декл = new ДекларацияКомпоновки(типКомпоновки, разбор());
        установи(декл, начало);
        this.типКомпоновки = сохранённое; // Восстановить.
        break;
      case T.Перепись:
        stc_tmp = КлассХранения.Перепись;
        goto Lcommon;
      case T.Устаревший:
        stc_tmp = КлассХранения.Устаревший;
        goto Lcommon;
      case T.Абстрактный:
        stc_tmp = КлассХранения.Абстрактный;
        goto Lcommon;
      case T.Синхронизованный:
        stc_tmp = КлассХранения.Синхронизованный;
        goto Lcommon;
      case T.Статический:
        stc_tmp = КлассХранения.Статический;
        goto Lcommon;
      case T.Окончательный:
        stc_tmp = КлассХранения.Окончательный;
        goto Lcommon;
      case T.Конст:
      version(D2)
      {
        if (возьмиСледщ() == T.ЛСкобка)
          goto случай_Декларация;
      }
        stc_tmp = КлассХранения.Конст;
        goto Lcommon;
      version(D2)
      {
      case T.Инвариант: // D 2.0
        auto следщ = сема;
        if (возьмиПосле(следщ) == T.ЛСкобка)
        {
          if (возьмиПосле(следщ) != T.ПСкобка)
            goto случай_Декларация; // invariant ( Тип )
          декл = разборДекларацииИнварианта(); // invariant ( )
          // NB: this must be similar в the код at the конец of
          //     разборДефиницииДекларации().
          декл.установиЗащиту(this.защита);
          декл.установиКлассХранения(кхр);
          установи(декл, начало);
          break;
        }
        // инвариант как классХранения.
        stc_tmp = КлассХранения.Инвариант;
        goto Lcommon;
      case T.Перечень: // D 2.0
        if (!манифестПеречня_ли())
        { // A nилиmal enum declaration.
          декл = разборДекларацииПеречня();
          // NB: this must be similar в the код at the конец of
          //     разборДефиницииДекларации().
          декл.установиЗащиту(this.защита);
          декл.установиКлассХранения(кхр);
          установи(декл, начало);
          break;
        }
        // enum as КлассХранения.
        stc_tmp = КлассХранения.Манифест;
        goto Lcommon;
      } // version(D2)
      case T.Авто:
        stc_tmp = КлассХранения.Авто;
        goto Lcommon;
      case T.Масштаб:
        stc_tmp = КлассХранения.Масштаб;
        goto Lcommon;
      Lcommon:
        // Issue ошибка if redundant.
        if (кхр & stc_tmp)
          ошибка2(ИДС.ПовторяющийсяКлассХранения, сема);
        else
          кхр |= stc_tmp;

        далее();
        декл = new ДекларацияКлассаХранения(stc_tmp, разбор());
        установи(декл, начало);
        break;
      case T.Идентификатор:
      случай_Декларация:
        // Этот может быть nилиmal Декларация или an ДекларацияАвто
        декл = разборПеременнойИлиФункции(кхр, this.защита, предш_типКомпоновки, да);
        break;
      default:
        this.классХранения = кхр; // Установить.
        декл = разборБлокаДеклараций();
        this.классХранения = saved_stилиageClass; // Reset.
      }
      assert(узелУстановлен(декл));
      return декл;
    }
    return разбор();
  }

  бцел разборАтрибутаАлайн()
  {
    пропусти(T.Расклад);
    бцел размер = РАЗМЕР_РАСКЛАДКИ_ПО_УМОЛЧАНИЮ; // Global default.
    if (проверено(T.ЛСкобка))
    {
      if (сема.вид == T.Цел32)
        (размер = сема.цел_), пропусти(T.Цел32);
      else
        ожидаемое(T.Цел32);
      требуется(T.ПСкобка);
    }
    return размер;
  }

  Декларация разборИдентификатораАтрибута()
  {
    Декларация декл;

    switch (сема.вид)
    {
    case T.Расклад:
      бцел размерРаскладки = разборАтрибутаАлайн();
      auto сохранённое = this.размерРаскладки; // Сохранить.
      this.размерРаскладки = размерРаскладки; // Установить.
      декл = new ДекларацияРазложи(размерРаскладки, разборБлокаДеклараций());
      this.размерРаскладки = сохранённое; // Восстановить.
      break;
    case T.Прагма:
      // Прагма:
      //     pragma ( Идентификатор )
      //     pragma ( Идентификатор , ExpressionList )
      далее();
      Идентификатор* идент;
      Выражение[] арги;

      требуется(T.ЛСкобка);
      идент = требуетсяИдентификатор(сооб.ОжидалсяИдентификаторПрагмы);

      if (проверено(T.Запятая))
        арги = разборСпискаВыражений();
      требуется(T.ПСкобка);

      декл = new ДекларацияПрагмы(идент, арги, разборБлокаДеклараций());
      break;
    default:
      // Защита атрибуты
      Защита защ;
      switch (сема.вид)
      {
      case T.Приватный:
        защ = Защита.Приватный; break;
      case T.Пакет:
        защ = Защита.Пакет; break;
      case T.Защищённый:
        защ = Защита.Защищённый; break;
      case T.Публичный:
        защ = Защита.Публичный; break;
      case T.Экспорт:
        защ = Защита.Экспорт; break;
      default:
        assert(0);
      }
      далее();
      auto сохранённое = this.защита; // Сохранить.
      this.защита = защ; // Установить.
      декл = new ДекларацияЗащиты(защ, разборБлокаДеклараций());
      this.защита = сохранённое; // Восстановить.
    }
    return декл;
  }

  Декларация разборДекларацииИмпорта()
  {
    бул статический_ли = проверено(T.Статический);
    пропусти(T.Импорт);

    ПКИМодуля[] пкиМодулей;
    Идентификатор*[] алиасыМодуля;
    Идентификатор*[] связанныеИмена;
    Идентификатор*[] связанныеАлиасы;

    do
    {
      ПКИМодуля пкиМодуля;
      Идентификатор* алиасМодуля;
      // ИмяАлиаса = ИмяМодуля
      if (возьмиСледщ() == T.Присвоить)
      {
        алиасМодуля = требуетсяИдентификатор(сооб.ОжидалосьПсевдоимяМодуля);
        пропусти(T.Присвоить);
      }
      // Идентификатор ("." Идентификатор)*
      do
        пкиМодуля ~= требуетсяИдентификатор(сооб.ОжидалсяИдентификаторМодуля);
      while (проверено(T.Точка));
      // Сунуть идентификаторы.
      пкиМодулей ~= пкиМодуля;
      алиасыМодуля ~= алиасМодуля;
    } while (проверено(T.Запятая));

    if (проверено(T.Двоеточие))
    { // АлиасПривязки "=" ИмяПривязки ("," АлиасПривязки "=" ИмяПривязки)*;
      // ИмяПривязки ("," ИмяПривязки)*;
      do
      {
        Идентификатор* алиасПривязки;
        // АлиасПривязки = ИмяПривязки
        if (возьмиСледщ() == T.Присвоить)
        {
          алиасПривязки = требуетсяИдентификатор(сооб.ОжидалосьПсевдоимяИмпорта);
          пропусти(T.Присвоить);
        }
        // Сунуть идентификаторы.
        связанныеИмена ~= требуетсяИдентификатор(сооб.ОжидалосьИмяИмпорта);
        связанныеАлиасы ~= алиасПривязки;
      } while (проверено(T.Запятая))
    }
    требуется(T.ТочкаЗапятая);

    return new ДекларацияИмпорта(пкиМодулей, алиасыМодуля, связанныеИмена, связанныеАлиасы, статический_ли);
  }

version(D2)
{
  /// Возвращает да, если является an enum manifest или
  /// нет if it's a nилиmal enum declaration.
  бул манифестПеречня_ли()
  {
    assert(сема.вид == T.Перечень);
    auto следщ = сема;
    auto вид = возьмиПосле(следщ);
    if (вид == T.Двоеточие || вид == T.ЛФСкобка)
      return нет; // Anonymous enum.
    else if (вид == T.Идентификатор)
    {
      вид = возьмиПосле(следщ);
      if (вид == T.Двоеточие || вид == T.ЛФСкобка || вид == T.ТочкаЗапятая)
        return нет; // Имяd enum.
    }
    return да; // Манифест enum.
  }
}

  Декларация разборДекларацииПеречня()
  {
    пропусти(T.Перечень);

    Идентификатор* имяПеречня;
    Тип типОснова;
    ДекларацияЧленаПеречня[] члены;
    бул естьТело;

    имяПеречня = дополнительныйИдентификатор();

    if (проверено(T.Двоеточие))
      типОснова = разборБазовогоТипа();

    if (имяПеречня && проверено(T.ТочкаЗапятая))
    {}
    else if (проверено(T.ЛФСкобка))
    {
      auto леваяФСкобка = this.предыдущСема;
      естьТело = да;
      while (сема.вид != T.ПФСкобка)
      {
        auto начало = сема;

        Тип тип;
      version(D2)
      {
        бул успех;
        пробуй_({
          // Тип Идентификатор = ВыражениеПрисвой
          тип = разборТипа(); // Установить outer тип переменная.
          if (сема.вид != T.Идентификатор)
            провал_пробы(), (тип = пусто);
          return пусто;
        }, успех);
      }

        auto имя = требуетсяИдентификатор(сооб.ОжидалсяЧленПеречня);
        Выражение значение;

        if (проверено(T.Присвоить))
          значение = разборВыраженияПрисвой();

        члены ~= установи(new ДекларацияЧленаПеречня(тип, имя, значение), начало);

        if (!проверено(T.Запятая))
          break;
      }
      требуетсяЗакрыв(T.ПФСкобка, леваяФСкобка);
    }
    else
      ошибка2(сооб.ОжидалосьТелоПеречня, сема);

    return new ДекларацияПеречня(имяПеречня, типОснова, члены, естьТело);
  }

  /// Оборачивает декларацию внутри декларации шаблона.
  /// Параметры:
  ///   начало = начальная сема декл.
  ///   имя = имя декл.
  ///   декл = оборачиваемая декларация.
  ///   шпарамы = параметры шаблона.
  ///   констрейнт = констрейнт-выражение.
  ДекларацияШаблона поместиДекларациюВнутреннегоШаблона(Сема* начало,
                                                   Идентификатор* имя,
                                                   Декларация декл,
                                                   ПараметрыШаблона шпарамы,
                                                   Выражение констрейнт)
  {
    установи(декл, начало);
    auto cd = new СложнаяДекларация;
    cd ~= декл;
    установи(cd, начало);
    return new ДекларацияШаблона(имя, шпарамы, констрейнт, cd);
  }

  Декларация разборДекларацииКласса()
  {
    auto начало = сема;
    пропусти(T.Класс);

    Идентификатор* имяКласса;
    ПараметрыШаблона шпарамы;
    Выражение констрейнт;
    ТипКлассОснова[] основы;
    СложнаяДекларация деклы;

    имяКласса = требуетсяИдентификатор(сооб.ОжидалосьНазваниеКласса);

    if (сема.вид == T.ЛСкобка)
    {
      шпарамы = разборСпискаПараметровШаблона();
      version(D2) констрейнт = разборДополнительногоКонстрейнта();
    }

    if (сема.вид == T.Двоеточие)
      основы = разборБазовыхКлассов();

    if (основы.length == 0 && проверено(T.ТочкаЗапятая))
    {}
    else if (сема.вид == T.ЛФСкобка)
      деклы = разборТелаДефиницииДекларации();
    else
      ошибка2(сооб.ОжидалосьТелоКласса, сема);

    Декларация d = new ДекларацияКласса(имяКласса, /+шпарамы, +/основы, деклы);
    if (шпарамы)
      d = поместиДекларациюВнутреннегоШаблона(начало, имяКласса, d, шпарамы, констрейнт);
    return d;
  }

  ТипКлассОснова[] разборБазовыхКлассов(бул выклВводнСтолбцы = да)
  {
    выклВводнСтолбцы && пропусти(T.Двоеточие);

    ТипКлассОснова[] основы;
    do
    {
      Защита защ = Защита.Публичный;
      switch (сема.вид)
      {
      case T.Идентификатор, T.Точка, T.Типа: goto LparseBasicType;
      case T.Приватный:   защ = Защита.Приватный;   break;
      case T.Защищённый: защ = Защита.Защищённый; break;
      case T.Пакет:   защ = Защита.Пакет;   break;
      case T.Публичный:  /*защ = Защита.Публичный;*/  break;
      default:
        ошибка2(ИДС.ОжидалисьКлассыОсновы, сема);
        return основы;
      }
      далее(); // Пропустим защита атрибут.
    LparseBasicType:
      auto начало = сема;
      auto тип = разборБазовогоТипа();
      основы ~= установи(new ТипКлассОснова(защ, тип), начало);
    } while (проверено(T.Запятая));
    return основы;
  }

  Декларация разборДекларацииИнтерфейса()
  {
    auto начало = сема;
    пропусти(T.Интерфейс);

    Идентификатор* имя;
    ПараметрыШаблона шпарамы;
    Выражение констрейнт;
    ТипКлассОснова[] основы;
    СложнаяДекларация деклы;

    имя = требуетсяИдентификатор(сооб.ОжидалосьНазваниеИнтерфейса);

    if (сема.вид == T.ЛСкобка)
    {
      шпарамы = разборСпискаПараметровШаблона();
      version(D2) констрейнт = разборДополнительногоКонстрейнта();
    }

    if (сема.вид == T.Двоеточие)
      основы = разборБазовыхКлассов();

    if (основы.length == 0 && проверено(T.ТочкаЗапятая))
    {}
    else if (сема.вид == T.ЛФСкобка)
      деклы = разборТелаДефиницииДекларации();
    else
      ошибка2(сооб.ОжидалосьТелоИнтерфейса, сема);

    Декларация d = new ДекларацияИнтерфейса(имя, /+шпарамы, +/основы, деклы);
    if (шпарамы)
      d = поместиДекларациюВнутреннегоШаблона(начало, имя, d, шпарамы, констрейнт);
    return d;
  }

  Декларация разборДекларацииСтруктурыИлиСоюза()
  {
    assert(сема.вид == T.Структура || сема.вид == T.Союз);
    auto начало = сема;
    пропусти(сема.вид);

    Идентификатор* имя;
    ПараметрыШаблона шпарамы;
    Выражение констрейнт;
    СложнаяДекларация деклы;

    имя = дополнительныйИдентификатор();

    if (имя && сема.вид == T.ЛСкобка)
    {
      шпарамы = разборСпискаПараметровШаблона();
      version(D2) констрейнт = разборДополнительногоКонстрейнта();
    }

    if (имя && проверено(T.ТочкаЗапятая))
    {}
    else if (сема.вид == T.ЛФСкобка)
      деклы = разборТелаДефиницииДекларации();
    else
      ошибка2(начало.вид == T.Структура ?
             сооб.ОжидалосьТелоСтруктуры :
             сооб.ОжидалосьТелоСоюза, сема);

    Декларация d;
    if (начало.вид == T.Структура)
    {
      auto sd = new ДекларацияСтруктуры(имя, /+шпарамы, +/деклы);
      sd.установиРазмерРаскладки(this.размерРаскладки);
      d = sd;
    }
    else
      d = new ДекларацияСоюза(имя, /+шпарамы, +/деклы);

    if (шпарамы)
      d = поместиДекларациюВнутреннегоШаблона(начало, имя, d, шпарамы, констрейнт);
    return d;
  }

  Декларация разборДекларацииКонструктора()
  {
    пропусти(T.Этот);
    auto параметры = разборСпискаПараметров();
    auto телоФунк = разборТелаФункции();
    return new ДекларацияКонструктора(параметры, телоФунк);
  }

  Декларация разборДекларацииДеструктора()
  {
    пропусти(T.Тильда);
    требуется(T.Этот);
    требуется(T.ЛСкобка);
    требуется(T.ПСкобка);
    auto телоФунк = разборТелаФункции();
    return new ДекларацияДеструктора(телоФунк);
  }

  Декларация разборДекларацииСтатичКонструктора()
  {
    пропусти(T.Статический);
    пропусти(T.Этот);
    требуется(T.ЛСкобка);
    требуется(T.ПСкобка);
    auto телоФунк = разборТелаФункции();
    return new ДекларацияСтатическогоКонструктора(телоФунк);
  }

  Декларация разборДекларацииСтатичДеструктора()
  {
    пропусти(T.Статический);
    пропусти(T.Тильда);
    требуется(T.Этот);
    требуется(T.ЛСкобка);
    требуется(T.ПСкобка);
    auto телоФунк = разборТелаФункции();
    return new ДекларацияСтатическогоДеструктора(телоФунк);
  }

  Декларация разборДекларацииИнварианта()
  {
    пропусти(T.Инвариант);
    // Optional () for getting ready pилиting в D 2.0
    if (проверено(T.ЛСкобка))
      требуется(T.ПСкобка);
    auto телоФунк = разборТелаФункции();
    return new ДекларацияИнварианта(телоФунк);
  }

  Декларация разборДекларацииЮниттеста()
  {
    пропусти(T.Юниттест);
    auto телоФунк = разборТелаФункции();
    return new ДекларацияЮниттеста(телоФунк);
  }

  Сема* разборИдентИлиЦел()
  {
    if (проверено(T.Цел32) || проверено(T.Идентификатор))
      return this.предыдущСема;
    ошибка2(сооб.ОжидалсяИдентИлиЦел, сема);
    return пусто;
  }

  Сема* разборУсловияВерсии()
  {
  version(D2)
  {
    if (проверено(T.Юниттест))
      return this.предыдущСема;
  }
    return разборИдентИлиЦел();
  }

  Декларация разборДекларацииОтладки()
  {
    пропусти(T.Отладка);

    Сема* спец;
    Сема* услов;
    Декларация деклы, деклыИначе;

    if (проверено(T.Присвоить))
    { // debug = Целое ;
      // debug = Идентификатор ;
      спец = разборИдентИлиЦел();
      требуется(T.ТочкаЗапятая);
    }
    else
    { // ( Условие )
      if (проверено(T.ЛСкобка))
      {
        услов = разборИдентИлиЦел();
        требуется(T.ПСкобка);
      }
      // debug БлокДеклараций
      // debug ( Условие ) БлокДеклараций
      деклы = разборБлокаДеклараций();
      // else БлокДеклараций
      if (проверено(T.Иначе))
        деклыИначе = разборБлокаДеклараций();
    }

    return new ДекларацияОтладки(спец, услов, деклы, деклыИначе);
  }

  Декларация парсируйДекларациюВерсии()
  {
    пропусти(T.Версия);

    Сема* спец;
    Сема* услов;
    Декларация деклы, деклыИначе;

    if (проверено(T.Присвоить))
    { // version = Целое ;
      // version = Идентификатор ;
      спец = разборИдентИлиЦел();
      требуется(T.ТочкаЗапятая);
    }
    else
    { // ( Условие )
      требуется(T.ЛСкобка);
      услов = разборУсловияВерсии();
      требуется(T.ПСкобка);
      // version ( Условие ) БлокДеклараций
      деклы = разборБлокаДеклараций();
      // else БлокДеклараций
      if (проверено(T.Иначе))
        деклыИначе = разборБлокаДеклараций();
    }

    return new ДекларацияВерсии(спец, услов, деклы, деклыИначе);
  }

  Декларация парсируйДекларациюСтатичЕсли()
  {
    пропусти(T.Статический);
    пропусти(T.Если);

    Выражение условие;
    Декларация деклыЕсли, деклыИначе;

    auto левСкобка = сема;
    требуется(T.ЛСкобка);
    условие = разборВыраженияПрисвой();
    требуетсяЗакрыв(T.ПСкобка, левСкобка);

    деклыЕсли = разборБлокаДеклараций();

    if (проверено(T.Иначе))
      деклыИначе = разборБлокаДеклараций();

    return new ДекларацияСтатическогоЕсли(условие, деклыЕсли, деклыИначе);
  }

  Декларация парсируйДекларациюСтатичАссерта()
  {
    пропусти(T.Статический);
    пропусти(T.Подтвердить);
    Выражение условие, сообщение;
    auto левСкобка = сема;
    требуется(T.ЛСкобка);
    условие = разборВыраженияПрисвой();
    if (проверено(T.Запятая))
      сообщение = разборВыраженияПрисвой();
    требуетсяЗакрыв(T.ПСкобка, левСкобка);
    требуется(T.ТочкаЗапятая);
    return new ДекларацияСтатическогоПодтверди(условие, сообщение);
  }

  Декларация парсируйДекларациюШаблона()
  {
    пропусти(T.Шаблон);
    auto имя = требуетсяИдентификатор(сооб.ОжидалосьНазваниеШаблона);
    auto шпарамы = разборСпискаПараметровШаблона();
    auto констрейнт = разборДополнительногоКонстрейнта();
    auto деклы = разборТелаДефиницииДекларации();
    return new ДекларацияШаблона(имя, шпарамы, констрейнт, деклы);
  }

  Декларация парсируйДекларациюНов()
  {
    пропусти(T.Нов);
    auto параметры = разборСпискаПараметров();
    auto телоФунк = разборТелаФункции();
    return new ДекларацияНов(параметры, телоФунк);
  }

  Декларация парсируйДекларациюУдалить()
  {
    пропусти(T.Удалить);
    auto параметры = разборСпискаПараметров();
    auto телоФунк = разборТелаФункции();
    return new ДекларацияУдали(параметры, телоФунк);
  }

  Тип разборТипаТипа()
  {
    auto начало = сема;
    пропусти(T.Типа);
    auto левСкобка = сема;
    требуется(T.ЛСкобка);
    Тип тип;
    switch (сема.вид)
    {
    version(D2)
    {
    case T.Итог:
      далее();
      тип = new ТТип();
      break;
    }
    default:
      тип = new ТТип(разборВыражения());
    }
    требуетсяЗакрыв(T.ПСкобка, левСкобка);
    установи(тип, начало);
    return тип;
  }

  /// Разбирает ДекларацияСмеси или ИнструкцияСмесь.
  /// $(PRE
  /// СмесьШаблона :=
  ///         mixin ( ВыражениеПрисвой ) ;
  ///         mixin ИдентификаторШаблона ;
  ///         mixin ИдентификаторШаблона ИдентификаторСмеси ;
  ///         mixin ИдентификаторШаблона !( АргументыШаблона ) ;
  ///         mixin ИдентификаторШаблона !( АргументыШаблона ) ИдентификаторСмеси ;
  /// )
  Класс парсируйМиксин(Класс)()
  {
  static assert(is(Класс == ДекларацияСмеси) || is(Класс == ИнструкцияСмесь));
    пропусти(T.Смесь);

  static if (is(Класс == ДекларацияСмеси))
  {
    if (проверено(T.ЛСкобка))
    {
      auto левСкобка = сема;
      auto в = разборВыраженияПрисвой();
      требуетсяЗакрыв(T.ПСкобка, левСкобка);
      требуется(T.ТочкаЗапятая);
      return new ДекларацияСмеси(в);
    }
  }

    auto начало = сема;
    Выражение в;
    Идентификатор* идентСмеси;

    if (проверено(T.Точка))
      в = установи(new ВыражениеМасштабМодуля(разборВыраженияИдентификатора()), начало);
    else
      в = разборВыраженияИдентификатора();

    while (проверено(T.Точка))
      в = установи(new ВыражениеТочка(в, разборВыраженияИдентификатора()), начало);

    идентСмеси = дополнительныйИдентификатор();
    требуется(T.ТочкаЗапятая);

    return new Класс(в, идентСмеси);
  }

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                         Методы разбора инструкций                        |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

  СложнаяИнструкция разборИнструкций()
  {
    auto начало = сема;
    требуется(T.ЛФСкобка);
    auto инструкции = new СложнаяИнструкция();
    while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
      инструкции ~= разборИнструкции();
    требуетсяЗакрыв(T.ПФСкобка, начало);
    return установи(инструкции, начало);
  }

  /// Разбирает Инструкция.
  Инструкция разборИнструкции()
  {
    auto начало = сема;
    Инструкция s;
    Декларация d;

    if (сема.интегральныйТип)
    {
      d = разборПеременнойИлиФункции();
      goto LreturnDeclarationStatement;
    }

    switch (сема.вид)
    {
    case T.Расклад:
      бцел размер = разборАтрибутаАлайн();
      // Ограничить атрибут align до структур в фазе разбора.
      ДекларацияСтруктуры деклСтрукта;
      if (сема.вид == T.Структура)
      {
        auto нач2 = сема;
        деклСтрукта = разборДекларацииСтруктурыИлиСоюза().в!(ДекларацияСтруктуры);
        деклСтрукта.установиРазмерРаскладки(размер);
        установи(деклСтрукта, нач2);
      }
      else
        ожидаемое(T.Структура);

      d = new ДекларацияРазложи(размер, деклСтрукта ? cast(Декларация)деклСтрукта : new СложнаяДекларация);
      goto LreturnDeclarationStatement;
      /+ Не применимо к инструкции.
         T.Приватный, T.Пакет, T.Защищённый, T.Публичный, T.Экспорт,
         T.Устаревший, T.Перепись, T.Абстрактный,+/
    case T.Экстерн,
         T.Окончательный,
         T.Конст,
         T.Авто:
         //T.Масштаб
         //T.Статический
    случай_разборАтрибута:
      s = разборИнструкцииАтрибута();
      return s;
    case T.Идентификатор:
      if (возьмиСледщ() == T.Двоеточие)
      {
        auto идент = сема.идент;
        пропусти(T.Идентификатор); пропусти(T.Двоеточие);
        s = new ИнструкцияСМеткой(идент, разборИнструкцииБезМасштабаИлиПустое());
        break;
      }
      goto case T.Точка;
    case T.Точка, T.Типа:
      бул успех;
      d = пробуй_(delegate {
          return разборПеременнойИлиФункции(КлассХранения.Нет,
                                         Защита.Нет,
                                         ТипКомпоновки.Нет, нет, нет);
        }, успех
      );
      if (успех)
        goto LreturnDeclarationStatement; // Декларация
      else
        goto случай_разборИнструкцииВыражения; // Выражение

    case T.Если:
      s = разборИнструкцииЕсли();
      break;
    case T.Пока:
      s = разборИнструкцииПока();
      break;
    case T.Делай:
      s = разборИнструкцииДелайПока();
      break;
    case T.При:
      s = разборИнструкцииПри();
      break;
    case T.ДляВсех, T.ДляВсех_реверс:
      s = разборИнструкцииДляВсех();
      break;
    case T.Щит:
      s = разборИнструкцииЩит();
      break;
    case T.Реле:
      s = разборИнструкцииРеле();
      break;
    case T.Дефолт:
      s = разборИнструкцииДефолт();
      break;
    case T.Далее:
      s = разборИнструкцииДалее();
      break;
    case T.Всё:
      s = разборИнструкцииВсё();
      break;
    case T.Итог:
      s = разборИнструкцииИтог();
      break;
    case T.Переход:
      s = разборИнструкцииПереход();
      break;
    case T.Для:
      s = разборИнструкцииДля();
      break;
    case T.Синхронизованный:
      s = разборИнструкцииСинхронно();
      break;
    case T.Пробуй:
      s = разборИнструкцииПробуй();
      break;
    case T.Брось:
      s = разборИнструкцииБрось();
      break;
    case T.Масштаб:
      if (возьмиСледщ() != T.ЛСкобка)
        goto случай_разборАтрибута;
      s = разборИнструкцииЗащитыМасштаба();
      break;
    case T.Волатайл:
      s = разборИнструкцииВолатайл();
      break;
    case T.Асм:
      s = разборИнструкцииБлокаАсм();
      break;
    case T.Прагма:
      s = разборИнструкцииПрагма();
      break;
    case T.Смесь:
      if (возьмиСледщ() == T.ЛСкобка)
        goto случай_разборИнструкцииВыражения; // Разобрать как выражение.
      s = парсируйМиксин!(ИнструкцияСмесь)();
      break;
    case T.Статический:
      switch (возьмиСледщ())
      {
      case T.Если:
        s = разборИнструкцииСтатичЕсли();
        break;
      case T.Подтвердить:
        s = разборИнструкцииСтатичПровер();
        break;
      default:
        goto случай_разборАтрибута;
      }
      break;
    case T.Отладка:
      s = разборИнструкцииОтладка();
      break;
    case T.Версия:
      s = разборИнструкцииВерсия();
      break;
    // DeclDef
    case T.Алиас, T.Типдеф:
      d = разборДефиницииДекларации();
      goto LreturnDeclarationStatement;
    case T.Перечень:
    version(D2)
    {
      if (манифестПеречня_ли())
        goto случай_разборАтрибута;
    }
      d = разборДекларацииПеречня();
      goto LreturnDeclarationStatement;
    case T.Класс:
      d = разборДекларацииКласса();
      goto LreturnDeclarationStatement;
    case T.Интерфейс:
      d = разборДекларацииИнтерфейса();
      goto LreturnDeclarationStatement;
    case T.Структура, T.Союз:
      d = разборДекларацииСтруктурыИлиСоюза();
      // goto LreturnDeclarationStatement;
    LreturnDeclarationStatement:
      установи(d, начало);
      s = new ИнструкцияДекларация(d);
      break;
    case T.ЛФСкобка:
      s = разборИнструкцииМасштаб();
      break;
    case T.ТочкаЗапятая:
      далее();
      s = new ПустаяИнструкция();
      break;
    // Разобрать ИнструкцияВыражение:
    // Токены, начинающие ПервичноеВыражение.
    // case T.Идентификатор, T.Точка, T.Типа:
    case T.Этот:
    case T.Супер:
    case T.Нуль:
    case T.Истина, T.Ложь:
    // case T.Доллар:
    case T.Цел32, T.Цел64, T.Бцел32, T.Бцел64:
    case T.Плав32, T.Плав64, T.Плав80,
         T.Мнимое32, T.Мнимое64, T.Мнимое80:
    case T.СимЛитерал:
    case T.Ткст:
    case T.ЛКвСкобка:
    // case T.ЛФСкобка:
    case T.Функция, T.Делегат:
    case T.Подтвердить:
    // case T.Смесь:
    case T.Импорт:
    case T.Идтипа:
    case T.Является:
    case T.ЛСкобка:
    case T.Трэтс: // D2.0
    // Токены, могущие начинать УнарноеВыражение:
    case T.ИБинарное, T.ПлюсПлюс, T.МинусМинус, T.Умножь, T.Минус,
         T.Плюс, T.Не, T.Тильда, T.Нов, T.Удалить, T.Каст:
    случай_разборИнструкцииВыражения:
      s = new ИнструкцияВыражение(разборВыражения());
      требуется(T.ТочкаЗапятая);
      break;
    default:
      if (сема.спецСема)
        goto случай_разборИнструкцииВыражения;

      if (сема.вид != T.Доллар)
        // Подтвердить, что это невалидное выражение.
        assert(delegate бул(){
            бул успех;
            auto выражение = пробуй_(&разборВыражения, успех);
            return успех;
          }() == нет, "Валидное выражение не ожидалось."
        );

      // Отчёт об ошибке: это нелегальная инструкция.
      s = new НелегальнаяИнструкция();
      // Пропустим в следщ valid сема.
      do
        далее();
      while (!сема.началоИнстр &&
              сема.вид != T.ПФСкобка &&
              сема.вид != T.КФ);
      auto текст = Сема.участокТекста(начало, this.предыдущСема);
      ошибка(начало, сооб.НелегальнаяИнструкция, текст);
    }
    assert(s !is пусто);
    установи(s, начало);
    return s;
  }

  /// $(PRE
  /// Разбирает ИнструкцияМасштаб.
  /// ИнструкцияМасштаб :=
  ///     NoScopeStatement
  /// )
  Инструкция разборИнструкцииМасштаб()
  {
    return new ИнструкцияМасштаб(разборИнструкцииБезМасштаба());
  }

  /// $(PRE
  /// NoScopeStatement :=
  ///     NonEmptyStatement
  ///     BlockStatement
  /// BlockStatement :=
  ///     { }
  ///     { StatementList }
  /// )
  Инструкция разборИнструкцииБезМасштаба()
  {
    auto начало = сема;
    Инструкция s;
    if (проверено(T.ЛФСкобка))
    {
      auto ss = new СложнаяИнструкция();
      while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
        ss ~= разборИнструкции();
      требуетсяЗакрыв(T.ПФСкобка, начало);
      s = установи(ss, начало);
    }
    else if (сема.вид == T.ТочкаЗапятая)
    {
      ошибка(сема, сооб.ОжидаласьНеПустаяИнструкция);
      далее();
      s = установи(new ПустаяИнструкция(), начало);
    }
    else
      s = разборИнструкции();
    return s;
  }

  /// $(PRE
  /// NoScopeOrEmptyStatement :=
  ///     ;
  ///     NoScopeStatement
  /// )
  Инструкция разборИнструкцииБезМасштабаИлиПустое()
  {
    if (проверено(T.ТочкаЗапятая))
      return установи(new ПустаяИнструкция(), this.предыдущСема);
    else
      return разборИнструкцииБезМасштаба();
  }

  Инструкция разборИнструкцииАтрибута()
  {
    КлассХранения кхр, stc_tmp;
    ТипКомпоновки предш_типКомпоновки;

    Декларация разбор() // Nested function.
    {
      auto начало = сема;
      Декларация декл;
      switch (сема.вид)
      {
      case T.Экстерн:
        if (возьмиСледщ() != T.ЛСкобка)
        {
          stc_tmp = КлассХранения.Экстерн;
          goto Lcommon;
        }

        далее();
        auto типКомпоновки = разборТипаКомпоновки();
        проверьТипКомпоновки(предш_типКомпоновки, типКомпоновки, начало);

        декл = new ДекларацияКомпоновки(типКомпоновки, разбор());
        break;
      case T.Статический:
        stc_tmp = КлассХранения.Статический;
        goto Lcommon;
      case T.Окончательный:
        stc_tmp = КлассХранения.Окончательный;
        goto Lcommon;
      case T.Конст:
      version(D2)
      {
        if (возьмиСледщ() == T.ЛСкобка)
          goto случай_Декларация;
      }
        stc_tmp = КлассХранения.Конст;
        goto Lcommon;
      version(D2)
      {
      case T.Инвариант: // D 2.0
        if (возьмиСледщ() == T.ЛСкобка)
          goto случай_Декларация;
        stc_tmp = КлассХранения.Инвариант;
        goto Lcommon;
      case T.Перечень: // D 2.0
        if (!манифестПеречня_ли())
        { // A nилиmal enum declaration.
          декл = разборДекларацииПеречня();
          // NB: this must be similar в the код at the конец of
          //     разборДефиницииДекларации().
          декл.установиЗащиту(this.защита);
          декл.установиКлассХранения(кхр);
          установи(декл, начало);
          return декл;
        }
        // enum as КлассХранения.
        stc_tmp = КлассХранения.Манифест;
        goto Lcommon;
      }
      case T.Авто:
        stc_tmp = КлассХранения.Авто;
        goto Lcommon;
      case T.Масштаб:
        stc_tmp = КлассХранения.Масштаб;
        goto Lcommon;
      Lcommon:
        // Issue ошибка if redundant.
        if (кхр & stc_tmp)
          ошибка2(ИДС.ПовторяющийсяКлассХранения, сема);
        else
          кхр |= stc_tmp;

        далее();
        декл = new ДекларацияКлассаХранения(stc_tmp, разбор());
        break;
      case T.Класс, T.Интерфейс, T.Структура, T.Союз, T.Алиас, T.Типдеф:
        декл = разборДефиницииДекларации();
        декл.установиЗащиту(Защита.Нет);
        декл.установиКлассХранения(КлассХранения.Нет);
        return декл;
      default:
      случай_Декларация:
        return разборПеременнойИлиФункции(кхр, Защита.Нет, предш_типКомпоновки, да);
      }
      return установи(декл, начало);
    }
    return new ИнструкцияДекларация(разбор());
  }

  Инструкция разборИнструкцииЕсли()
  {
    пропусти(T.Если);

    Инструкция переменная;
    Выражение условие;
    Инструкция телоЕсли, телоИначе;

    auto левСкобка = сема;
    требуется(T.ЛСкобка);

    Идентификатор* идент;
    auto начало = сема; // При старт of ДекларацияАвто или nилиmal Декларация.
    // auto Идентификатор = Выражение
    if (проверено(T.Авто))
    {
      идент = требуетсяИдентификатор(сооб.ОжидалосьНазваниеПеременной);
      требуется(T.Присвоить);
      auto иниц = разборВыражения();
      auto v = new ДекларацияПеременных(пусто, [идент], [иниц]);
      установи(v, начало.следщНепроб);
      auto d = new ДекларацияКлассаХранения(КлассХранения.Авто, v);
      установи(d, начало);
      переменная = new ИнструкцияДекларация(d);
      установи(переменная, начало);
    }
    else
    { // Декларатор = Выражение
      Тип разборДекларатораПрисвой()
      {
        auto тип = разборДекларатора(идент);
        требуется(T.Присвоить);
        return тип;
      }
      бул успех;
      auto тип = пробуй_(&разборДекларатораПрисвой, успех);
      if (успех)
      {
        auto иниц = разборВыражения();
        auto v = new ДекларацияПеременных(тип, [идент], [иниц]);
        установи(v, начало);
        переменная = new ИнструкцияДекларация(v);
        установи(переменная, начало);
      }
      else
        условие = разборВыражения();
    }
    требуетсяЗакрыв(T.ПСкобка, левСкобка);
    телоЕсли = разборИнструкцииМасштаб();
    if (проверено(T.Иначе))
      телоИначе = разборИнструкцииМасштаб();
    return new ИнструкцияЕсли(переменная, условие, телоЕсли, телоИначе);
  }

  Инструкция разборИнструкцииПока()
  {
    пропусти(T.Пока);
    auto левСкобка = сема;
    требуется(T.ЛСкобка);
    auto условие = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, левСкобка);
    return new ИнструкцияПока(условие, разборИнструкцииМасштаб());
  }

  Инструкция разборИнструкцииДелайПока()
  {
    пропусти(T.Делай);
    auto телоДелай = разборИнструкцииМасштаб();
    требуется(T.Пока);
    auto левСкобка = сема;
    требуется(T.ЛСкобка);
    auto условие = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, левСкобка);
    return new ИнструкцияДелайПока(условие, телоДелай);
  }

  Инструкция разборИнструкцииПри()
  {
    пропусти(T.При);

    Инструкция иниц, телоПри;
    Выражение условие, инкремент;

    auto левСкобка = сема;
    требуется(T.ЛСкобка);
    if (!проверено(T.ТочкаЗапятая))
      иниц = разборИнструкцииБезМасштаба();
    if (сема.вид != T.ТочкаЗапятая)
      условие = разборВыражения();
    требуется(T.ТочкаЗапятая);
    if (сема.вид != T.ПСкобка)
      инкремент = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, левСкобка);
    телоПри = разборИнструкцииМасштаб();
    return new ИнструкцияПри(иниц, условие, инкремент, телоПри);
  }

  Инструкция разборИнструкцииДляВсех()
  {
    assert(сема.вид == T.ДляВсех || сема.вид == T.ДляВсех_реверс);
    TOK лекс = сема.вид;
    далее();

    auto парамы = new Параметры;
    Выражение в; // Агрегат или LwrExpression

    auto левСкобка = сема;
    требуется(T.ЛСкобка);
    auto началоПарамов = сема;
    do
    {
      auto началоПарама = сема;
      КлассХранения кхр;
      Тип тип;
      Идентификатор* идент;

      switch (сема.вид)
      {
      case T.Реф, T.Вховых:
        кхр = КлассХранения.Реф;
        далее();
        // fall through
      case T.Идентификатор:
        auto следщ = возьмиСледщ();
        if (следщ == T.Запятая || следщ == T.ТочкаЗапятая || следщ == T.ПСкобка)
        {
          идент = требуетсяИдентификатор(сооб.ОжидалосьНазваниеПеременной);
          break;
        }
        // fall through
      default:
        тип = разборДекларатора(идент);
      }

      парамы ~= установи(new Параметр(кхр, тип, идент, пусто), началоПарама);
    } while (проверено(T.Запятая));
    установи(парамы, началоПарамов);
    требуется(T.ТочкаЗапятая);
    в = разборВыражения();
  version(D2)
  { //ДляВсех (FилиeachType; LwrExpression .. UprExpression ) ИнструкцияМасштаб
    if (проверено(T.Срез))
    {
      // if (парамы.length != 1)
        // ошибка(ИДС.XYZ); // TODO: issue ошибка сооб
      auto верхний = разборВыражения();
      требуетсяЗакрыв(T.ПСкобка, левСкобка);
      auto телоПри = разборИнструкцииМасштаб();
      return new ИнструкцияДиапазонСКаждым(лекс, парамы, в, верхний, телоПри);
    }
  }
    // ДляВсех (СписокТипаДляВсех; Агрегат) ИнструкцияМасштаб
    требуетсяЗакрыв(T.ПСкобка, левСкобка);
    auto телоПри = разборИнструкцииМасштаб();
    return new ИнструкцияСКаждым(лекс, парамы, в, телоПри);
  }

  Инструкция разборИнструкцииЩит()
  {
    пропусти(T.Щит);
    auto левСкобка = сема;
    требуется(T.ЛСкобка);
    auto условие = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, левСкобка);
    auto телоЩит = разборИнструкцииМасштаб();
    return new ИнструкцияЩит(условие, телоЩит);
  }

  /// Helper function for parsing the body of a default или case statement.
  Инструкция разборТелаКейсИлиДефолт()
  {
    // Этот function is similar в разборИнструкцииБезМасштаба()
    auto начало = сема;
    auto s = new СложнаяИнструкция();
    while (сема.вид != T.Реле &&
           сема.вид != T.Дефолт &&
           сема.вид != T.ПФСкобка &&
           сема.вид != T.КФ)
      s ~= разборИнструкции();
    установи(s, начало);
    return установи(new ИнструкцияМасштаб(s), начало);
  }

  Инструкция разборИнструкцииРеле()
  {
    пропусти(T.Реле);
    auto значения = разборСпискаВыражений();
    требуется(T.Двоеточие);
    auto телоРеле = разборТелаКейсИлиДефолт();
    return new ИнструкцияРеле(значения, телоРеле);
  }

  Инструкция разборИнструкцииДефолт()
  {
    пропусти(T.Дефолт);
    требуется(T.Двоеточие);
    auto телоДефолта = разборТелаКейсИлиДефолт();
    return new ИнструкцияДефолт(телоДефолта);
  }

  Инструкция разборИнструкцииДалее()
  {
    пропусти(T.Далее);
    auto идент = дополнительныйИдентификатор();
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияДалее(идент);
  }

  Инструкция разборИнструкцииВсё()
  {
    пропусти(T.Всё);
    auto идент = дополнительныйИдентификатор();
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияВсё(идент);
  }

  Инструкция разборИнструкцииИтог()
  {
    пропусти(T.Итог);
    Выражение выр;
    if (сема.вид != T.ТочкаЗапятая)
      выр = разборВыражения();
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияИтог(выр);
  }

  Инструкция разборИнструкцииПереход()
  {
    пропусти(T.Переход);
    Идентификатор* идент;
    Выражение вырРеле;
    switch (сема.вид)
    {
    case T.Реле:
      идент = сема.идент;
      далее();
      if (сема.вид == T.ТочкаЗапятая)
        break;
      вырРеле = разборВыражения();
      break;
    case T.Дефолт:
      идент = сема.идент;
      далее();
      break;
    default:
      идент = требуетсяИдентификатор(сооб.ОжидалсяИдентификатор);
    }
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияПереход(идент, вырРеле);
  }

  Инструкция разборИнструкцииДля()
  {
    пропусти(T.Для);
    auto левСкобка = сема;
    требуется(T.ЛСкобка);
    auto выр = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, левСкобка);
    return new ИнструкцияДля(выр, разборИнструкцииМасштаб());
  }

  Инструкция разборИнструкцииСинхронно()
  {
    пропусти(T.Синхронизованный);
    Выражение выр;
    if (проверено(T.ЛСкобка))
    {
      auto левСкобка = this.предыдущСема;
      выр = разборВыражения();
      требуетсяЗакрыв(T.ПСкобка, левСкобка);
    }
    return new ИнструкцияСинхр(выр, разборИнструкцииМасштаб());
  }

  Инструкция разборИнструкцииПробуй()
  {
    auto начало = сема;
    пропусти(T.Пробуй);

    auto телоПробуй = разборИнструкцииМасштаб();
    ИнструкцияЛови[] телаЛови;
    ИнструкцияИтожь finBody;

    while (проверено(T.Кэтч))
    {
      Параметр парам;
      if (проверено(T.ЛСкобка))
      {
        auto нач2 = сема;
        Идентификатор* идент;
        auto тип = разборДекларатора(идент, да);
        парам = new Параметр(КлассХранения.Нет, тип, идент, пусто);
        установи(парам, нач2);
        требуется(T.ПСкобка);
      }
      телаЛови ~= установи(new ИнструкцияЛови(парам, разборИнструкцииБезМасштаба()), начало);
      if (парам is пусто)
        break; // Этот есть LastCatch
      начало = сема;
    }

    if (проверено(T.ВИтоге))
      finBody = установи(new ИнструкцияИтожь(разборИнструкцииБезМасштаба()), предыдущСема);

    if (телаЛови.length == 0 && finBody is пусто)
      assert(начало.вид == T.Пробуй), ошибка(начало, сооб.НеДостаетCatchИлиВИтоге);

    return new ИнструкцияПробуй(телоПробуй, телаЛови, finBody);
  }

  Инструкция разборИнструкцииБрось()
  {
    пропусти(T.Брось);
    auto выр = разборВыражения();
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияБрось(выр);
  }

  Инструкция разборИнструкцииЗащитыМасштаба()
  {
    пропусти(T.Масштаб);
    пропусти(T.ЛСкобка);
    auto условие = требуетсяИдентификатор(сооб.ОжидалсяИдентификаторМасштаба);
    if (условие)
      switch (условие.видИд)
      {
      case ВИД.выход, ВИД.успех, ВИД.сбой:
        break;
      default:
        ошибка2(сооб.НеверныйИдентификаторМасштаба, this.предыдущСема);
      }
    требуется(T.ПСкобка);
    Инструкция телоМасштаба;
    if (сема.вид == T.ЛФСкобка)
      телоМасштаба = разборИнструкцииМасштаб();
    else
      телоМасштаба = разборИнструкцииБезМасштаба();
    return new ИнструкцияСтражМасштаба(условие, телоМасштаба);
  }

  Инструкция разборИнструкцииВолатайл()
  {
    пропусти(T.Волатайл);
    Инструкция телоЛетучего;
    if (сема.вид == T.ТочкаЗапятая)
      далее();
    else if (сема.вид == T.ЛФСкобка)
      телоЛетучего = разборИнструкцииМасштаб();
    else
      телоЛетучего = разборИнструкции();
    return new ИнструкцияЛетучее(телоЛетучего);
  }

  Инструкция разборИнструкцииПрагма()
  {
    пропусти(T.Прагма);

    Идентификатор* идент;
    Выражение[] арги;
    Инструкция телоПрагмы;

    auto левСкобка = сема;
    требуется(T.ЛСкобка);
    идент = требуетсяИдентификатор(сооб.ОжидалсяИдентификаторПрагмы);

    if (проверено(T.Запятая))
      арги = разборСпискаВыражений();
    требуетсяЗакрыв(T.ПСкобка, левСкобка);

    телоПрагмы = разборИнструкцииБезМасштабаИлиПустое();

    return new ИнструкцияПрагма(идент, арги, телоПрагмы);
  }

  Инструкция разборИнструкцииСтатичЕсли()
  {
    пропусти(T.Статический);
    пропусти(T.Если);
    Выражение условие;
    Инструкция телоЕсли, телоИначе;

    auto левСкобка = сема;
    требуется(T.ЛСкобка);
    условие = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, левСкобка);
    телоЕсли = разборИнструкцииБезМасштаба();
    if (проверено(T.Иначе))
      телоИначе = разборИнструкцииБезМасштаба();
    return new ИнструкцияСтатическоеЕсли(условие, телоЕсли, телоИначе);
  }

  Инструкция разборИнструкцииСтатичПровер()
  {
    пропусти(T.Статический);
    пропусти(T.Подтвердить);
    Выражение условие, сообщение;

    требуется(T.ЛСкобка);
    условие = разборВыраженияПрисвой(); // Условие.
    if (проверено(T.Запятая))
      сообщение = разборВыраженияПрисвой(); // Ошибка сообщение.
    требуется(T.ПСкобка);
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияСтатическоеПодтверди(условие, сообщение);
  }

  Инструкция разборИнструкцииОтладка()
  {
    пропусти(T.Отладка);
    Сема* услов;
    Инструкция телоОтладки, телоИначе;

    // ( Условие )
    if (проверено(T.ЛСкобка))
    {
      услов = разборИдентИлиЦел();
      требуется(T.ПСкобка);
    }
    // debug Инструкция
    // debug ( Условие ) Инструкция
    телоОтладки = разборИнструкцииБезМасштаба();
    // else Инструкция
    if (проверено(T.Иначе))
      телоИначе = разборИнструкцииБезМасштаба();

    return new ИнструкцияОтладка(услов, телоОтладки, телоИначе);
  }

  Инструкция разборИнструкцииВерсия()
  {
    пропусти(T.Версия);
    Сема* услов;
    Инструкция телоВерсии, телоИначе;

    // ( Условие )
    требуется(T.ЛСкобка);
    услов = разборУсловияВерсии();
    требуется(T.ПСкобка);
    // version ( Условие ) Инструкция
    телоВерсии = разборИнструкцииБезМасштаба();
    // else Инструкция
    if (проверено(T.Иначе))
      телоИначе = разборИнструкцииБезМасштаба();

    return new ИнструкцияВерсия(услов, телоВерсии, телоИначе);
  }

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                         Методы разбора асемблера                         |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

  /// Разбирает ИнструкцияБлокАсм.
  Инструкция разборИнструкцииБлокаАсм()
  {
    пропусти(T.Асм);
    auto леваяФСкобка = сема;
    требуется(T.ЛФСкобка);
    auto ss = new СложнаяИнструкция;
    while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
      ss ~= разборИнструкцииАсемблера();
    требуетсяЗакрыв(T.ПФСкобка, леваяФСкобка);
    return new ИнструкцияБлокАсм(ss);
  }

  Инструкция разборИнструкцииАсемблера()
  {
    auto начало = сема;
    Инструкция s;
    Идентификатор* идент;
    switch (сема.вид)
    {
    // Keywords that are valid opКодs.
    case T.Вхо, T.Цел, T.Вых:
      идент = сема.идент;
      далее();
      goto LOpcode;
    case T.Идентификатор:
      идент = сема.идент;
      далее();
      if (проверено(T.Двоеточие))
      { // Идентификатор : ИнструкцияАсм
        s = new ИнструкцияСМеткой(идент, разборИнструкцииАсемблера());
        break;
      }

    LOpcode:
      // Опкод ;
      // Опкод Операнды ;
      // Опкод
      //     Идентификатор
      Выражение[] es;
      if (сема.вид != T.ТочкаЗапятая)
        do
          es ~= разборВыраженияАсемблера();
        while (проверено(T.Запятая));
      требуется(T.ТочкаЗапятая);
      s = new ИнструкцияАсм(идент, es);
      break;
    case T.Расклад:
      // align Целое;
      далее();
      цел число = -1;
      if (сема.вид == T.Цел32)
        (число = сема.цел_), пропусти(T.Цел32);
      else
        ошибка2(сооб.ExpectedIntegerAfterAlign, сема);
      требуется(T.ТочкаЗапятая);
      s = new ИнструкцияАсмРасклад(число);
      break;
    case T.ТочкаЗапятая:
      s = new ПустаяИнструкция();
      далее();
      break;
    default:
      s = new ИнструкцияНелегальныйАсм();
      // Пропустим в следщ valid сема.
      do
        далее();
      while (!сема.началоАсмИнстр &&
              сема.вид != T.ПФСкобка &&
              сема.вид != T.КФ);
      auto текст = Сема.участокТекста(начало, this.предыдущСема);
      ошибка(начало, сооб.ИнструкцияНелегальныйАсм, текст);
    }
    установи(s, начало);
    return s;
  }

  Выражение разборВыраженияАсемблера()
  {
    auto начало = сема;
    auto в = разборВыраженияАсемблераИлиИли();
    if (проверено(T.Вопрос))
    {
      auto лекс = this.предыдущСема;
      auto iftrue = разборВыраженияАсемблера();
      требуется(T.Двоеточие);
      auto iffalse = разборВыраженияАсемблера();
      в = new ВыражениеУсловия(в, iftrue, iffalse, лекс);
      установи(в, начало);
    }
    // TODO: create AsmExpression that contains в?
    return в;
  }

  Выражение разборВыраженияАсемблераИлиИли()
  {
    alias разборВыраженияАсемблераИИ разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИлиЛог)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИлиИли(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение разборВыраженияАсемблераИИ()
  {
    alias разборВыраженияАсемблераИли разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИЛог)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИИ(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение разборВыраженияАсемблераИли()
  {
    alias разборВыраженияАсемблераИИли разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИлиБинарное)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИли(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение разборВыраженияАсемблераИИли()
  {
    alias разборВыраженияАсемблераИ разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИИли)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИИли(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение разборВыраженияАсемблераИ()
  {
    alias разборВыраженияАсемблераЦмп разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИБинарное)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИ(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение разборВыраженияАсемблераЦмп()
  {
    alias разборВыраженияАсемблераШифт разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();

    auto оператор = сема;
    switch (оператор.вид)
    {
    case T.Равно, T.НеРавно:
      далее();
      в = new ВыражениеРавно(в, разборСледующего(), оператор);
      break;
    case T.МеньшеРавно, T.Меньше, T.БольшеРавно, T.Больше:
      далее();
      в = new ВыражениеОтнош(в, разборСледующего(), оператор);
      break;
    default:
      return в;
    }
    установи(в, начало);
    return в;
  }

  Выражение разборВыраженияАсемблераШифт()
  {
    alias разборВыраженияАсемблераАдд разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (1)
    {
      auto оператор = сема;
      switch (оператор.вид)
      {
      case T.ЛСдвиг:  далее(); в = new ВыражениеЛСдвиг(в, разборСледующего(), оператор); break;
      case T.ПСдвиг:  далее(); в = new ВыражениеПСдвиг(в, разборСледующего(), оператор); break;
      case T.БПСдвиг: далее(); в = new ВыражениеБПСдвиг(в, разборСледующего(), оператор); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение разборВыраженияАсемблераАдд()
  {
    alias разборВыраженияАсемблераМул разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (1)
    {
      auto оператор = сема;
      switch (оператор.вид)
      {
      case T.Плюс:  далее(); в = new ВыражениеПлюс(в, разборСледующего(), оператор); break;
      case T.Минус: далее(); в = new ВыражениеМинус(в, разборСледующего(), оператор); break;
      // Не allowed in asm
      //case T.Тильда: далее(); в = new ВыражениеСоедини(в, разборСледующего(), оператор); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение разборВыраженияАсемблераМул()
  {
    alias разборВыраженияАсемблераПост разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (1)
    {
      auto оператор = сема;
      switch (оператор.вид)
      {
      case T.Умножь: далее(); в = new ВыражениеУмножь(в, разборСледующего(), оператор); break;
      case T.Деление: далее(); в = new ВыражениеДели(в, разборСледующего(), оператор); break;
      case T.Модуль: далее(); в = new ВыражениеМод(в, разборСледующего(), оператор); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение разборВыраженияАсемблераПост()
  {
    auto начало = сема;
    auto в = разборУнарногоВыраженияАсемблера();
    while (проверено(T.ЛКвСкобка))
    {
      auto левКвСкобка = this.предыдущСема;
      в = new ВыражениеАсмПослеСкобки(в, разборВыраженияАсемблера());
      требуетсяЗакрыв(T.ПКвСкобка, левКвСкобка);
      установи(в, начало);
    }
    return в;
  }

  Выражение разборУнарногоВыраженияАсемблера()
  {
    auto начало = сема;
    Выражение в;
    switch (сема.вид)
    {
    case T.Байт,  T.Крат,  T.Цел,
         T.Плав, T.Дво, T.Реал:
      goto LAsmTypePrefix;
    case T.Идентификатор:
      switch (сема.идент.видИд)
      {
      case ВИД.near, ВИД.far,/* "байт",  "крат",  "цел",*/
           ВИД.word, ВИД.dword, ВИД.qword/*, "плав", "дво", "реал"*/:
      LAsmTypePrefix:
        далее();
        if (сема.вид == T.Идентификатор && сема.идент is Идент.ptr)
          пропусти(T.Идентификатор);
        else
          ошибка2(ИДС.НайденоИноеЧемОжидалось, "ptr", сема);
        в = new ВыражениеТипАсм(разборВыраженияАсемблера());
        break;
      case ВИД.offset:
        далее();
        в = new ВыражениеСмещениеАсм(разборВыраженияАсемблера());
        break;
      case ВИД.seg:
        далее();
        в = new ВыражениеСегАсм(разборВыраженияАсемблера());
        break;
      default:
        goto LparseAsmПервичноеВыражение;
      }
      break;
    case T.Минус:
    case T.Плюс:
      далее();
      в = new ВыражениеЗнак(разборУнарногоВыраженияАсемблера());
      break;
    case T.Не:
      далее();
      в = new ВыражениеНе(разборУнарногоВыраженияАсемблера());
      break;
    case T.Тильда:
      далее();
      в = new ВыражениеКомп(разборУнарногоВыраженияАсемблера());
      break;
    case T.Точка:
      далее();
      в = new ВыражениеМасштабМодуля(разборВыраженияИдентификатора());
      while (проверено(TOK.Точка))
      {
        в = new ВыражениеТочка(в, разборВыраженияИдентификатора());
        установи(в, начало);
      }
      break;
    default:
    LparseAsmПервичноеВыражение:
      в = разборПримарногоВыраженияАсемблера();
      return в;
    }
    установи(в, начало);
    return в;
  }

  Выражение разборПримарногоВыраженияАсемблера()
  {
    auto начало = сема;
    Выражение в;
    switch (сема.вид)
    {
    case T.Цел32, T.Цел64, T.Бцел32, T.Бцел64:
      в = new ЦелВыражение(сема);
      далее();
      break;
    case T.Плав32, T.Плав64, T.Плав80,
         T.Мнимое32, T.Мнимое64, T.Мнимое80:
      в = new ВыражениеРеал(сема);
      далее();
      break;
    case T.Доллар:
      в = new ВыражениеДоллар();
      далее();
      break;
    case T.ЛКвСкобка:
      // [ AsmExpression ]
      auto левКвСкобка = сема;
      далее();
      в = разборВыраженияАсемблера();
      требуетсяЗакрыв(T.ПКвСкобка, левКвСкобка);
      в = new ВыражениеАсмСкобка(в);
      break;
    case T.Идентификатор:
      auto регистр = сема.идент;
      switch (регистр.видИд)
      {
      // __LOCAL_SIZE
      case ВИД.__LOCAL_SIZE:
        далее();
        в = new ВыражениеЛокальногоРазмераАсм();
        break;
      // Register
      case ВИД.ST:
        далее();
        // (1) - (7)
        цел число = -1;
        if (проверено(T.ЛСкобка))
        {
          if (сема.вид == T.Цел32)
            (число = сема.цел_), пропусти(T.Цел32);
          else
            ожидаемое(T.Цел32);
          требуется(T.ПСкобка);
        }
        в = new ВыражениеАсмРегистр(регистр, число);
        break;
      case ВИД.FS:
        далее();
        // TODO: is the colon-число part optional?
        цел число = -1;
        if (проверено(T.Двоеточие))
        {
          // :0, :4, :8
          if (сема.вид == T.Цел32)
            (число = сема.цел_), пропусти(T.Цел32);
          if (число != 0 && число != 4 && число != 8)
            ошибка2(ИДС.НайденоИноеЧемОжидалось, "0, 4 или 8", сема);
        }
        в = new ВыражениеАсмРегистр(регистр, число);
        break;
      case ВИД.AL, ВИД.AH, ВИД.AX, ВИД.EAX,
           ВИД.BL, ВИД.BH, ВИД.BX, ВИД.EBX,
           ВИД.CL, ВИД.CH, ВИД.CX, ВИД.ECX,
           ВИД.DL, ВИД.DH, ВИД.DX, ВИД.EDX,
           ВИД.BP, ВИД.EBP, ВИД.SP, ВИД.ESP,
           ВИД.DI, ВИД.EDI, ВИД.SI, ВИД.ESI,
           ВИД.ES, ВИД.CS, ВИД.SS, ВИД.DS, ВИД.GS,
           ВИД.CR0, ВИД.CR2, ВИД.CR3, ВИД.CR4,
           ВИД.DR0, ВИД.DR1, ВИД.DR2, ВИД.DR3, ВИД.DR6, ВИД.DR7,
           ВИД.TR3, ВИД.TR4, ВИД.TR5, ВИД.TR6, ВИД.TR7,
           ВИД.MM0, ВИД.MM1, ВИД.MM2, ВИД.MM3,
           ВИД.MM4, ВИД.MM5, ВИД.MM6, ВИД.MM7,
           ВИД.XMM0, ВИД.XMM1, ВИД.XMM2, ВИД.XMM3,
           ВИД.XMM4, ВИД.XMM5, ВИД.XMM6, ВИД.XMM7:
        далее();
        в = new ВыражениеАсмРегистр(регистр);
        break;
      default:
        в = разборВыраженияИдентификатора();
        while (проверено(TOK.Точка))
        {
          в = new ВыражениеТочка(в, разборВыраженияИдентификатора());
          установи(в, начало);
        }
      } // конец of switch
      break;
    default:
      ошибка2(ИДС.НайденоИноеЧемОжидалось, "Выражение", сема);
      в = new НелегальноеВыражение();
      if (!пробуем)
      { // Вставить a dummy сема and don'т consume current one.
        начало = лексер.вставьПустуюСемуПеред(сема);
        this.предыдущСема = начало;
      }
    }
    установи(в, начало);
    return в;
  }

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                        Методы разбора выражений                        |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

  /// Разбирает Выражение.
  Выражение разборВыражения()
  {
    alias разборВыраженияПрисвой разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.Запятая)
    {
      auto comma = сема;
      далее();
      в = new ВыражениеЗапятая(в, разборСледующего(), comma);
      установи(в, начало);
    }
    return в;
  }

  Выражение разборВыраженияПрисвой()
  {
    alias разборВыраженияПрисвой разборСледующего;
    auto начало = сема;
    auto в = разборУсловнВыражения();
    switch (сема.вид)
    {
    case T.Присвоить:
      далее(); в = new ВыражениеПрисвой(в, разборСледующего()); break;
    case T.ЛСдвигПрисвой:
      далее(); в = new ВыражениеПрисвойЛСдвиг(в, разборСледующего()); break;
    case T.ПСдвигПрисвой:
      далее(); в = new ВыражениеПрисвойПСдвиг(в, разборСледующего()); break;
    case T.БПСдвигПрисвой:
      далее(); в = new ВыражениеПрисвойБПСдвиг(в, разборСледующего()); break;
    case T.ИлиПрисвой:
      далее(); в = new ВыражениеПрисвойИли(в, разборСледующего()); break;
    case T.ИПрисвой:
      далее(); в = new ВыражениеПрисвойИ(в, разборСледующего()); break;
    case T.ПрибавьПрисвой:
      далее(); в = new ВыражениеПрисвойПлюс(в, разборСледующего()); break;
    case T.ОтнимиПрисвой:
      далее(); в = new ВыражениеПрисвойМинус(в, разборСледующего()); break;
    case T.ДелиПрисвой:
      далее(); в = new ВыражениеПрисвойДел(в, разборСледующего()); break;
    case T.УмножьПрисвой:
      далее(); в = new ВыражениеПрисвойУмн(в, разборСледующего()); break;
    case T.МодульПрисвой:
      далее(); в = new ВыражениеПрисвойМод(в, разборСледующего()); break;
    case T.ИИлиПрисвой:
      далее(); в = new ВыражениеПрисвойИИли(в, разборСледующего()); break;
    case T.СоединиПрисвой:
      далее(); в = new ВыражениеПрисвойСоед(в, разборСледующего()); break;
    default:
      return в;
    }
    установи(в, начало);
    return в;
  }

  Выражение разборУсловнВыражения()
  {
    auto начало = сема;
    auto в = разборВыраженияИлиИли();
    if (сема.вид == T.Вопрос)
    {
      auto лекс = сема;
      далее();
      auto iftrue = разборВыражения();
      требуется(T.Двоеточие);
      auto iffalse = разборУсловнВыражения();
      в = new ВыражениеУсловия(в, iftrue, iffalse, лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение разборВыраженияИлиИли()
  {
    alias разборВыраженияИИ разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИлиЛог)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИлиИли(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение разборВыраженияИИ()
  {
    alias разборВыраженияИли разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИЛог)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИИ(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение разборВыраженияИли()
  {
    alias разборВыраженияИИли разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИлиБинарное)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИли(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение разборВыраженияИИли()
  {
    alias разборВыраженияИ разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИИли)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИИли(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение разборВыраженияИ()
  {
    alias разборВыраженияЦмп разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (сема.вид == T.ИБинарное)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИ(в, разборСледующего(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение разборВыраженияЦмп()
  {
    alias разборВыраженияШифт разборСледующего;
    auto начало = сема;
    auto в = разборВыраженияШифт();

    auto оператор = сема;
    switch (оператор.вид)
    {
    case T.Равно, T.НеРавно:
      далее();
      в = new ВыражениеРавно(в, разборСледующего(), оператор);
      break;
    case T.Не:
      if (возьмиСледщ() != T.Является)
        break;
      далее();
      // fall through
    case T.Является:
      далее();
      в = new ВыражениеРавенство(в, разборСледующего(), оператор);
      break;
    case T.МеньшеРавно, T.Меньше, T.БольшеРавно, T.Больше,
         T.Неупорядоченный, T.НилиР, T.НилиБ, T.НилиБилиР,
         T.НилиМ, T.НилиМилиР, T.МилиРилиБ, T.МилиБ:
      далее();
      в = new ВыражениеОтнош(в, разборСледующего(), оператор);
      break;
    case T.Вхо:
      далее();
      в = new ВыражениеВхо(в, разборСледующего(), оператор);
      break;
    default:
      return в;
    }
    установи(в, начало);
    return в;
  }

  Выражение разборВыраженияШифт()
  {
    alias разборВыраженияАдд разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (1)
    {
      auto оператор = сема;
      switch (оператор.вид)
      {
      case T.ЛСдвиг:  далее(); в = new ВыражениеЛСдвиг(в, разборСледующего(), оператор); break;
      case T.ПСдвиг:  далее(); в = new ВыражениеПСдвиг(в, разборСледующего(), оператор); break;
      case T.БПСдвиг: далее(); в = new ВыражениеБПСдвиг(в, разборСледующего(), оператор); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение разборВыраженияАдд()
  {
    alias разборВыраженияМул разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (1)
    {
      auto оператор = сема;
      switch (оператор.вид)
      {
      case T.Плюс:  далее(); в = new ВыражениеПлюс(в, разборСледующего(), оператор); break;
      case T.Минус: далее(); в = new ВыражениеМинус(в, разборСледующего(), оператор); break;
      case T.Тильда: далее(); в = new ВыражениеСоедини(в, разборСледующего(), оператор); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение разборВыраженияМул()
  {
    alias разборВыраженияПост разборСледующего;
    auto начало = сема;
    auto в = разборСледующего();
    while (1)
    {
      auto оператор = сема;
      switch (оператор.вид)
      {
      case T.Умножь: далее(); в = new ВыражениеУмножь(в, разборСледующего(), оператор); break;
      case T.Деление: далее(); в = new ВыражениеДели(в, разборСледующего(), оператор); break;
      case T.Модуль: далее(); в = new ВыражениеМод(в, разборСледующего(), оператор); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение разборВыраженияПост()
  {
    auto начало = сема;
    auto в = разборУнарногоВыражения();
    while (1)
    {
      while (проверено(T.Точка))
      {
        в = new ВыражениеТочка(в, разборВыраженияНовИлиИдентификатор());
        установи(в, начало);
      }

      switch (сема.вид)
      {
      case T.ПлюсПлюс:
        в = new ВыражениеПостИнкр(в);
        break;
      case T.МинусМинус:
        в = new ВыражениеПостДекр(в);
        break;
      case T.ЛСкобка:
        в = new ВыражениеВызов(в, разборАргументов());
        goto Lset;
      case T.ЛКвСкобка:
        // разбор Срез- and ВыражениеИндекс
        auto левКвСкобка = сема;
        далее();
        // [] есть ВыражениеСрез
        if (сема.вид == T.ПКвСкобка)
        {
          в = new ВыражениеСрез(в, пусто, пусто);
          break;
        }

        Выражение[] es = [разборВыраженияПрисвой()];

        // [ ВыражениеПрисвой .. ВыражениеПрисвой ]
        if (проверено(T.Срез))
        {
          в = new ВыражениеСрез(в, es[0], разборВыраженияПрисвой());
          требуетсяЗакрыв(T.ПКвСкобка, левКвСкобка);
          goto Lset;
        }

        // [ ExpressionList ]
        if (проверено(T.Запятая))
           es ~= разборСпискаВыражений();
        требуетсяЗакрыв(T.ПКвСкобка, левКвСкобка);

        в = new ВыражениеИндекс(в, es);
        goto Lset;
      default:
        return в;
      }
      далее();
    Lset: // Jumped here в пропусти далее().
      установи(в, начало);
    }
    assert(0);
  }

  Выражение разборУнарногоВыражения()
  {
    auto начало = сема;
    Выражение в;
    switch (сема.вид)
    {
    case T.ИБинарное:
      далее();
      в = new ВыражениеАдрес(разборУнарногоВыражения());
      break;
    case T.ПлюсПлюс:
      далее();
      в = new ВыражениеПреИнкр(разборУнарногоВыражения());
      break;
    case T.МинусМинус:
      далее();
      в = new ВыражениеПреДекр(разборУнарногоВыражения());
      break;
    case T.Умножь:
      далее();
      в = new ВыражениеДереф(разборУнарногоВыражения());
      break;
    case T.Минус:
    case T.Плюс:
      далее();
      в = new ВыражениеЗнак(разборУнарногоВыражения());
      break;
    case T.Не:
      далее();
      в = new ВыражениеНе(разборУнарногоВыражения());
      break;
    case T.Тильда:
      далее();
      в = new ВыражениеКомп(разборУнарногоВыражения());
      break;
    case T.Нов:
      в = разборВыраженияНов();
      return в;
    case T.Удалить:
      далее();
      в = new ВыражениеУдали(разборУнарногоВыражения());
      break;
    case T.Каст:
      требуетсяСледующий(T.ЛСкобка);
      Тип тип;
      switch (сема.вид)
      {
      version(D2)
      {
      auto нач2 = сема;
      case T.Конст:
        тип = new ТКонст(пусто);
        goto case_break;
      case T.Инвариант:
        тип = new ТИнвариант(пусто);
      case_break:
        далее();
        установи(тип, нач2);
        break;
      }
      default:
       тип = разборТипа();
      }
      требуется(T.ПСкобка);
      в = new ВыражениеКаст(разборУнарногоВыражения(), тип);
      break;
    case T.ЛСкобка:
      // ( Тип ) . Идентификатор
      Тип разборТипа_()
      {
        пропусти(T.ЛСкобка);
        auto тип = разборТипа();
        требуется(T.ПСкобка);
        требуется(T.Точка);
        return тип;
      }
      бул успех;
      auto тип = пробуй_(&разборТипа_, успех);
      if (успех)
      {
        auto идент = требуетсяИдентификатор(сооб.ExpectedIdAfterTypeDot);
        в = new ВыражениеИдТипаТочка(тип, идент);
        break;
      }
      goto default;
    case T.Точка:
      далее();
      в = new ВыражениеМасштабМодуля(разборВыраженияИдентификатора());
      break;
    default:
      в = разборПримарногоВыражения();
      return в;
    }
    assert(в !is пусто);
    установи(в, начало);
    return в;
  }

  /// $(PRE
  /// ВыражениеИдентификатор :=
  ///         Идентификатор
  ///         TemplateInstance
  /// TemplateInstance :=
  ///         Идентификатор !( АргументыШаблона )
  /// )
  Выражение разборВыраженияИдентификатора()
  {
    auto начало = сема;
    auto идент = требуетсяИдентификатор(сооб.ОжидалсяИдентификатор);
    Выражение в;
    // Peek for '(' в avoid matching: ид !is ид
    if (сема.вид == T.Не && возьмиСледщ() == T.ЛСкобка)
    { // Идентификатор !( АргументыШаблона )
      пропусти(T.Не);
      auto шпарамы = разборАргументовШаблона();
      в = new ВыражениеЭкземплярШаблона(идент, шпарамы);
    }
    else // Идентификатор
      в = new ВыражениеИдентификатор(идент);
    return установи(в, начало);
  }

  Выражение разборВыраженияНовИлиИдентификатор()
  {
    return сема.вид == T.Нов ? разборВыраженияНов() :  разборВыраженияИдентификатора();
  }

  Выражение разборПримарногоВыражения()
  {
    auto начало = сема;
    Выражение в;
    switch (сема.вид)
    {
    case T.Идентификатор:
      в = разборВыраженияИдентификатора();
      return в;
    case T.Типа:
      в = new ВыражениеТипа(разборТипаТипа());
      break;
    case T.Этот:
      далее();
      в = new ВыражениеЭтот();
      break;
    case T.Супер:
      далее();
      в = new ВыражениеСупер();
      break;
    case T.Нуль:
      далее();
      в = new ВыражениеНуль();
      break;
    case T.Истина, T.Ложь:
      далее();
      в = new БулевоВыражение(сема.вид == T.Истина);
      break;
    case T.Доллар:
      далее();
      в = new ВыражениеДоллар();
      break;
    case T.Цел32, T.Цел64, T.Бцел32, T.Бцел64:
      в = new ЦелВыражение(сема);
      далее();
      break;
    case T.Плав32, T.Плав64, T.Плав80,
         T.Мнимое32, T.Мнимое64, T.Мнимое80:
      в = new ВыражениеРеал(сема);
      далее();
      break;
    case T.СимЛитерал:
      в = new ВыражениеСим(сема.дим_);
      далее();
      break;
    case T.Ткст:
      ткст ткт = сема.ткт;
      сим postfix = сема.pf;
      далее();
      while (сема.вид == T.Ткст)
      {
        /+if (postfix == 0)
            postfix = сема.pf;
        else+/
        if (сема.pf && сема.pf != postfix)
          ошибка(сема, сооб.StringPostfixMismatch);
        ткт.length = ткт.length - 1; // Exclude '\0'.
        ткт ~= сема.ткт;
        далее();
      }
      switch (postfix)
      {
      case 'w':
        if (естьНеверныйЮ8(ткт, начало))
          goto default;
        в = new ТекстовоеВыражение(drc.Unicode.вЮ16(ткт)); break;
      case 'd':
        if (естьНеверныйЮ8(ткт, начало))
          goto default;
        в = new ТекстовоеВыражение(drc.Unicode.вЮ32(ткт)); break;
      case 'c':
      default:
        // No checking done в allow for binary данные.
        в = new ТекстовоеВыражение(ткт); break;
      }
      break;
    case T.ЛКвСкобка:
      Выражение[] значения;

      далее();
      if (!проверено(T.ПКвСкобка))
      {
        в = разборВыраженияПрисвой();
        if (проверено(T.Двоеточие))
          goto LparseAssocМассив;
        if (проверено(T.Запятая))
          значения = [в] ~ разборСпискаВыражений();
        требуетсяЗакрыв(T.ПКвСкобка, начало);
      }

      в = new ВыражениеЛитералМассива(значения);
      break;

    LparseAssocМассив:
      Выражение[] ключи = [в];

      goto LenterLoop;
      do
      {
        ключи ~= разборВыраженияПрисвой();
        требуется(T.Двоеточие);
      LenterLoop:
        значения ~= разборВыраженияПрисвой();
      } while (проверено(T.Запятая));
      требуетсяЗакрыв(T.ПКвСкобка, начало);
      в = new ВыражениеЛитералАМассива(ключи, значения);
      break;
    case T.ЛФСкобка:
      // DelegateLiteral := { Statements }
      auto телоФунк = разборТелаФункции();
      в = new ВыражениеЛитералФункции(телоФунк);
      break;
    case T.Функция, T.Делегат:
      // FunctionLiteral := ("function"|"delegate") Тип? "(" ArgumentList ")" FunctionBody
      далее(); // Пропустим function или delegate ключевое слово.
      Тип типВозврата;
      Параметры параметры;
      if (сема.вид != T.ЛФСкобка)
      {
        if (сема.вид != T.ЛСкобка) // Optional return тип
          типВозврата = разборТипа();
        параметры = разборСпискаПараметров();
      }
      auto телоФунк = разборТелаФункции();
      в = new ВыражениеЛитералФункции(типВозврата, параметры, телоФунк);
      break;
    case T.Подтвердить:
      Выражение сооб;
      требуетсяСледующий(T.ЛСкобка);
      в = разборВыраженияПрисвой();
      if (проверено(T.Запятая))
        сооб = разборВыраженияПрисвой();
      требуется(T.ПСкобка);
      в = new ВыражениеПодтверди(в, сооб);
      break;
    case T.Смесь:
      требуетсяСледующий(T.ЛСкобка);
      в = разборВыраженияПрисвой();
      требуется(T.ПСкобка);
      в = new ВыражениеСмесь(в);
      break;
    case T.Импорт:
      требуетсяСледующий(T.ЛСкобка);
      в = разборВыраженияПрисвой();
      требуется(T.ПСкобка);
      в = new ВыражениеИмпорта(в);
      break;
    case T.Идтипа:
      требуетсяСледующий(T.ЛСкобка);
      auto тип = разборТипа();
      требуется(T.ПСкобка);
      в = new ВыражениеИдТипа(тип);
      break;
    case T.Является:
      далее();
      auto левСкобка = сема;
      требуется(T.ЛСкобка);

      Тип тип, типСпец;
      Идентификатор* идент; // optional Идентификатор
      Сема* опцСема, спецСема;

      тип = разборДекларатора(идент, да);

      switch (сема.вид)
      {
      case T.Двоеточие, T.Равно:
        опцСема = сема;
        далее();
        switch (сема.вид)
        {
        case T.Типдеф,
             T.Структура,
             T.Союз,
             T.Класс,
             T.Интерфейс,
             T.Перечень,
             T.Функция,
             T.Делегат,
             T.Супер,
             T.Итог:
        case_Const_Invariant:
          спецСема = сема;
          далее();
          break;
        case T.Конст, T.Инвариант:
          if (возьмиСледщ() != T.ЛСкобка)
            goto case_Const_Invariant;
          // Fall through. It's a тип.
        default:
          типСпец = разборТипа();
        }
      default:
      }

      ПараметрыШаблона шпарамы;
    version(D2)
    {
      // is ( Тип Идентификатор : TypeSpecialization , TemplateParameterList )
      // is ( Тип Идентификатор == TypeSpecialization , TemplateParameterList )
      if (идент && типСпец && сема.вид == T.Запятая)
        шпарамы = разборСпискаПараметровШаблона2();
    }
      требуетсяЗакрыв(T.ПСкобка, левСкобка);
      в = new ВыражениеЯвляется(тип, идент, опцСема, спецСема, типСпец, шпарамы);
      break;
    case T.ЛСкобка:
      if (семаПослеСкобкиЯвляется(T.ЛФСкобка)) // Проверим на "(...) {"
      { // ( СписокПараметров ) FunctionBody
        auto параметры = разборСпискаПараметров();
        auto телоФунк = разборТелаФункции();
        в = new ВыражениеЛитералФункции(пусто, параметры, телоФунк);
      }
      else
      { // ( Выражение )
        auto левСкобка = сема;
        пропусти(T.ЛСкобка);
        в = разборВыражения();
        требуетсяЗакрыв(T.ПСкобка, левСкобка);
        в = new ВыражениеРодит(в);
      }
      break;
    version(D2)
    {
    case T.Трэтс:
      требуетсяСледующий(T.ЛСкобка);
      auto ид = требуетсяИдентификатор(сооб.ОжидалсяИдентификатор);
      АргументыШаблона арги;
      if (сема.вид == T.Запятая)
        арги = разборАргументовШаблона2();
      else
        требуется(T.ПСкобка);
      в = new ВыражениеТрактовки(ид, арги);
      break;
    }
    default:
      if (сема.интегральныйТип)
      { // ИнтегральныйТип . Идентификатор
        auto тип = new ИнтегральныйТип(сема.вид);
        далее();
        установи(тип, начало);
        требуется(T.Точка);
        auto идент = требуетсяИдентификатор(сооб.ExpectedIdAfterTypeDot);
        в = new ВыражениеИдТипаТочка(тип, идент);
      }
      else if (сема.спецСема)
      {
        в = new ВыражениеСпецСема(сема);
        далее();
      }
      else
      {
        ошибка2(ИДС.НайденоИноеЧемОжидалось, "Выражение", сема);
        в = new НелегальноеВыражение();
        if (!пробуем)
        { // Вставить a dummy сема and don'т consume current one.
          начало = лексер.вставьПустуюСемуПеред(сема);
          this.предыдущСема = начало;
        }
      }
    }
    установи(в, начало);
    return в;
  }

  Выражение разборВыраженияНов(/*Выражение в*/)
  {
    auto начало = сема;
    пропусти(T.Нов);

    Выражение[] аргиНов;
    Выражение[] аргиКтора;

    if (сема.вид == T.ЛСкобка)
      аргиНов = разборАргументов();

    // ВыражениеНовАнонКласс:
    //         new (ArgumentList)opt class (ArgumentList)opt SuperClassopt ЦелerfaceClassesopt ClassBody
    if (проверено(T.Класс))
    {
      if (сема.вид == T.ЛСкобка)
        аргиКтора = разборАргументов();

      ТипКлассОснова[] основы = сема.вид != T.ЛФСкобка ? разборБазовыхКлассов(нет) : пусто ;

      auto деклы = разборТелаДефиницииДекларации();
      return установи(new ВыражениеНовАнонКласс(/*в, */аргиНов, основы, аргиКтора, деклы), начало);
    }

    // ВыражениеНов:
    //         NewArguments Тип [ ВыражениеПрисвой ]
    //         NewArguments Тип ( ArgumentList )
    //         NewArguments Тип
    auto тип = разборТипа();

    if (сема.вид == T.ЛСкобка)
      аргиКтора = разборАргументов();

    return установи(new ВыражениеНов(/*в, */аргиНов, тип, аргиКтора), начало);
  }

  /// Разбирает Тип.
  Тип разборТипа()
  {
    return разборБазовогоТипа2(разборБазовогоТипа());
  }

  Тип разборТипаИдентификатора()
  {
    auto начало = сема;
    auto идент = требуетсяИдентификатор(сооб.ОжидалсяИдентификатор);
    Тип т;
    if (проверено(T.Не)) // Идентификатор !( АргументыШаблона )
      т = new ТЭкземплярШаблона(идент, разборАргументовШаблона());
    else // Идентификатор
      т = new ТИдентификатор(идент);
    return установи(т, начало);
  }

  Тип разборКвалифицированногоТипа()
  {
    auto начало = сема;
    Тип тип;
    if (сема.вид == T.Точка)
      тип = установи(new ТМасштабМодуля(), начало, начало);
    else if (сема.вид == T.Типа)
      тип = разборТипаТипа();
    else
      тип = разборТипаИдентификатора();

    while (проверено(T.Точка))
      тип = установи(new КвалифицированныйТип(тип, разборТипаИдентификатора()), начало);
    return тип;
  }

  Тип разборБазовогоТипа()
  {
    auto начало = сема;
    Тип т;

    if (сема.интегральныйТип)
    {
      т = new ИнтегральныйТип(сема.вид);
      далее();
    }
    else
    switch (сема.вид)
    {
    case T.Идентификатор, T.Типа, T.Точка:
      т = разборКвалифицированногоТипа();
      return т;
    version(D2)
    {
    case T.Конст:
      // const ( Тип )
      требуетсяСледующий(T.ЛСкобка);
      т = разборТипа();
      требуется(T.ПСкобка);
      т = new ТКонст(т);
      break;
    case T.Инвариант:
      // invariant ( Тип )
      требуетсяСледующий(T.ЛСкобка);
      т = разборТипа();
      требуется(T.ПСкобка);
      т = new ТИнвариант(т);
      break;
    } // version(D2)
    default:
      ошибка2(ИДС.НайденоИноеЧемОжидалось, "BasicType", сема);
      т = new НелегальныйТип();
      далее();
    }
    return установи(т, начало);
  }

  Тип разборБазовогоТипа2(Тип т)
  {
    while (1)
    {
      auto начало = сема;
      switch (сема.вид)
      {
      case T.Умножь:
        т = new ТУказатель(т);
        далее();
        break;
      case T.ЛКвСкобка:
        т = разборТипаМассив(т);
        continue;
      case T.Функция, T.Делегат:
        TOK лекс = сема.вид;
        далее();
        auto параметры = разборСпискаПараметров();
        if (лекс == T.Функция)
          т = new ТФункция(т, параметры);
        else
          т = new ТДелегат(т, параметры);
        break;
      default:
        return т;
      }
      установи(т, начало);
    }
    assert(0);
  }

  /// Возвращает "да", если the сема after the закрывающий parenthesis
  /// matches the searched вид.
  бул семаПослеСкобкиЯвляется(TOK вид)
  {
    assert(сема.вид == T.ЛСкобка);
    auto следщ = сема;
    return пропустиСкобку(следщ) == вид;
  }

  /// определено
  бул семаПослеСкобкиЯвляется(TOK вид, ref Сема* следщ)
  {
    assert(следщ !is пусто && следщ.вид == T.ЛСкобка);
    return пропустиСкобку(следщ) == вид;
  }

  /// Skips в the сема behind the закрывающий parenthesis.
  /// Takes nested parentheses into account.
  TOK пропустиСкобку(ref Сема* следщ)
  {
    assert(следщ !is пусто && следщ.вид == T.ЛСкобка);
    // We счёт nested parentheses семы because template types, typeof и т.д.
    // may appear внутри parameter lists. Напр.: (цел x, Foo!(цел) y)
    бцел уровень = 1;
  Loop:
    while (1)
      switch (возьмиПосле(следщ))
      {
      case T.ЛСкобка:
        ++уровень;
        break;
      case T.ПСкобка:
        if (--уровень == 0)
          return возьмиПосле(следщ); // Closing parenthesis found.
        break;
      case T.КФ:
        return T.КФ;
      default:
      }
    assert(0, "должно быть недоступно");
  }

  /// Разбор типов массивов после декларатора (C-style.) Напр.: цел a[]
  Тип разборСуффиксаДекларатора(Тип lhsType)
  {
    // The Тип chain should be as follows:
    // цел[3]* Идентификатор [][32]
    //   <- <-             ->  -.
    //       ^-----------------´
    // Итогing chain: [][32]*[3]цел
    Тип разборСледующего() // Nested function required в accomplish this.
    {
      if (сема.вид != T.ЛКвСкобка)
        return lhsType; // Всё recursion; return Тип on the левый hand сторона of the Идентификатор.

      auto начало = сема;
      Тип т;
      пропусти(T.ЛКвСкобка);
      if (проверено(T.ПКвСкобка))
        т = new ТМассив(разборСледующего()); // [ ]
      else
      {
        бул успех;
        Тип разборТипаАМ()
        {
          auto тип = разборТипа();
          требуется(T.ПКвСкобка);
          return тип;
        }
        auto ассоцТип = пробуй_(&разборТипаАМ, успех);
        if (успех)
          т = new ТМассив(разборСледующего(), ассоцТип); // [ Тип ]
        else
        {
          Выражение в = разборВыражения(), e2;
          if (проверено(T.Срез))
            e2 = разборВыражения();
          требуетсяЗакрыв(T.ПКвСкобка, начало);
          т = new ТМассив(разборСледующего(), в, e2); // [ Выражение .. Выражение ]
        }
      }
      установи(т, начало);
      return т;
    }
    return разборСледующего();
  }

  Тип разборТипаМассив(Тип т)
  {
    auto начало = сема;
    пропусти(T.ЛКвСкобка);
    if (проверено(T.ПКвСкобка))
      т = new ТМассив(т);
    else
    {
      бул успех;
      Тип разборТипаАМ()
      {
        auto тип = разборТипа();
        требуется(T.ПКвСкобка);
        return тип;
      }
      auto ассоцТип = пробуй_(&разборТипаАМ, успех);
      if (успех)
        т = new ТМассив(т, ассоцТип);
      else
      {
        Выражение в = разборВыражения(), e2;
        if (проверено(T.Срез))
          e2 = разборВыражения();
        требуетсяЗакрыв(T.ПКвСкобка, начало);
        т = new ТМассив(т, в, e2);
      }
    }
    установи(т, начало);
    return т;
  }

  Тип разборТипаУказательНаФункциюСи(Тип тип, ref Идентификатор* идент, бул опцСписокПарам)
  {
    assert(тип !is пусто);
    auto начало = сема;
    пропусти(T.ЛСкобка);

    тип = разборБазовогоТипа2(тип);
    if (сема.вид == T.ЛСкобка)
    { // Can be nested.
      тип = разборТипаУказательНаФункциюСи(тип, идент, да);
    }
    else if (сема.вид == T.Идентификатор)
    { // The идентификатор of the function pointer and the declaration.
      идент = сема.идент;
      далее();
      тип = разборСуффиксаДекларатора(тип);
    }
    требуетсяЗакрыв(T.ПСкобка, начало);

    Параметры парамы;
    if (опцСписокПарам)
      парамы = сема.вид == T.ЛСкобка ? разборСпискаПараметров() : пусто;
    else
      парамы = разборСпискаПараметров();

    тип = new ТУказательНаФункСи(тип, парамы);
    return установи(тип, начало);
  }

  Тип разборДекларатора(ref Идентификатор* идент, бул identOptional = нет)
  {
    auto т = разборТипа();

    if (сема.вид == T.ЛСкобка)
      т = разборТипаУказательНаФункциюСи(т, идент, да);
    else if (сема.вид == T.Идентификатор)
    {
      идент = сема.идент;
      далее();
      т = разборСуффиксаДекларатора(т);
    }

    if (идент is пусто && !identOptional)
      ошибка2(сооб.ОжидалсяИдентификаторДекларатора, сема);

    return т;
  }

  /// Разбирает список of AssignExpressions.
  /// $(PRE
  /// ExpressionList :=
  ///   ВыражениеПрисвой
  ///   ВыражениеПрисвой , ExpressionList
  /// )
  Выражение[] разборСпискаВыражений()
  {
    Выражение[] выражения;
    do
      выражения ~= разборВыраженияПрисвой();
    while(проверено(T.Запятая));
    return выражения;
  }

  /// Разбирает список of Аргументы.
  /// $(PRE
  /// Аргументы :=
  ///   ( )
  ///   ( ExpressionList )
  /// )
  Выражение[] разборАргументов()
  {
    auto левСкобка = сема;
    пропусти(T.ЛСкобка);
    Выражение[] арги;
    if (сема.вид != T.ПСкобка)
      арги = разборСпискаВыражений();
    требуетсяЗакрыв(T.ПСкобка, левСкобка);
    return арги;
  }

  /// Разбирает СписокПараметров.
  Параметры разборСпискаПараметров()
  out(парамы)
  {
    if (парамы.length > 1)
      foreach (парам; парамы.элементы[0..$-1])
      {
        if (парам.вариадический())
          assert(0, "вариадические аргументы могут появляться только в конце списка параметров.");
      }
  }
  body
  {
    auto начало = сема;
    требуется(T.ЛСкобка);

    auto парамы = new Параметры();

    if (проверено(T.ПСкобка))
      return установи(парамы, начало);

    do
    {
      auto началоПарама = сема;
      КлассХранения кхр, stc_;
      Тип тип;
      Идентификатор* идент;
      Выражение дефЗначение;

      проц  pushParameter()
      {
        парамы ~= установи(new Параметр(кхр, тип, идент, дефЗначение), началоПарама);
      }

      if (проверено(T.Эллипсис))
      {
        кхр = КлассХранения.Вариадический;
        pushParameter(); // тип, идент and дефЗначение will be пусто.
        break;
      }

      while (1)
      { // Parse stилиage classes.
        switch (сема.вид)
        {
      version(D2)
      {
        case T.Инвариант: // D2.0
          if (возьмиСледщ() == T.ЛСкобка)
            break;
          stc_ = КлассХранения.Инвариант;
          goto Lcommon;
        case T.Конст: // D2.0
          if (возьмиСледщ() == T.ЛСкобка)
            break;
          stc_ = КлассХранения.Конст;
          goto Lcommon;
        case T.Окончательный: // D2.0
          stc_ = КлассХранения.Окончательный;
          goto Lcommon;
        case T.Масштаб: // D2.0
          stc_ = КлассХранения.Масштаб;
          goto Lcommon;
        case T.Статический: // D2.0
          stc_ = КлассХранения.Статический;
          goto Lcommon;
      }
        case T.Вхо:
          stc_ = КлассХранения.Вхо;
          goto Lcommon;
        case T.Вых:
          stc_ = КлассХранения.Вых;
          goto Lcommon;
        case T.Вховых, T.Реф:
          stc_ = КлассХранения.Реф;
          goto Lcommon;
        case T.Отложенный:
          stc_ = КлассХранения.Отложенный;
          goto Lcommon;
        Lcommon:
          // Проверим на redundancy.
          if (кхр & stc_)
            ошибка2(ИДС.ПовторяющийсяКлассХранения, сема);
          else
            кхр |= stc_;
          далее();
        version(D2)
          continue;
        else
          break; // Вхо D1.0 the grammar only allows one stилиage class.
        default:
        }
        break; // Всё out of inner loop.
      }
      тип = разборДекларатора(идент, да);

      if (проверено(T.Присвоить))
        дефЗначение = разборВыраженияПрисвой();

      if (проверено(T.Эллипсис))
      {
        кхр |= КлассХранения.Вариадический;
        pushParameter();
        break;
      }
      pushParameter();

    } while (проверено(T.Запятая));
    требуетсяЗакрыв(T.ПСкобка, начало);
    return установи(парамы, начало);
  }

  АргументыШаблона разборАргументовШаблона()
  {
    АргументыШаблона шарги;
    auto левСкобка = сема;
    требуется(T.ЛСкобка);
    if (сема.вид != T.ПСкобка)
      шарги = разборАргументовШаблона_();
    требуетсяЗакрыв(T.ПСкобка, левСкобка);
    return шарги;
  }

version(D2)
{
  АргументыШаблона разборАргументовШаблона2()
  {
    пропусти(T.Запятая);
    АргументыШаблона шарги;
    if (сема.вид != T.ПСкобка)
      шарги = разборАргументовШаблона_();
    else
      ошибка(сема, сооб.ОжидалсяТипИлиВыражение);
    требуется(T.ПСкобка);
    return шарги;
  }
} // version(D2)

  АргументыШаблона разборАргументовШаблона_()
  {
    auto начало = сема;
    auto шарги = new АргументыШаблона;
    do
    {
      Тип разборТипа_()
      {
        auto тип = разборТипа();
        if (сема.вид == T.Запятая || сема.вид == T.ПСкобка)
          return тип;
        провал_пробы();
        return пусто;
      }
      бул успех;
      auto typeArgument = пробуй_(&разборТипа_, успех);
      if (успех)
        // TemplateArgument:
        //         Тип
        //         Символ
        шарги ~= typeArgument;
      else
        // TemplateArgument:
        //         ВыражениеПрисвой
        шарги ~= разборВыраженияПрисвой();
    } while (проверено(T.Запятая));
    установи(шарги, начало);
    return шарги;
  }

  /// if ( ConstraintExpression )
  Выражение разборДополнительногоКонстрейнта()
  {
    if (!проверено(T.Если))
      return пусто;
    требуется(T.ЛСкобка);
    auto в = разборВыражения();
    требуется(T.ПСкобка);
    return в;
  }

  ПараметрыШаблона разборСпискаПараметровШаблона()
  {
    auto начало = сема;
    auto шпарамы = new ПараметрыШаблона;
    требуется(T.ЛСкобка);
    if (сема.вид != T.ПСкобка)
      разборСпискаПараметровШаблона_(шпарамы);
    требуетсяЗакрыв(T.ПСкобка, начало);
    return установи(шпарамы, начало);
  }

version(D2)
{
  ПараметрыШаблона разборСпискаПараметровШаблона2()
  {
    пропусти(T.Запятая);
    auto начало = сема;
    auto шпарамы = new ПараметрыШаблона;
    if (сема.вид != T.ПСкобка)
      разборСпискаПараметровШаблона_(шпарамы);
    else
      ошибка(сема, сооб.ОжидалисьПараметрыШаблона);
    return установи(шпарамы, начало);
  }
} // version(D2)

  /// Parses template параметры.
  проц  разборСпискаПараметровШаблона_(ПараметрыШаблона шпарамы)
  {
    do
    {
      auto началоПарама = сема;
      ПараметрШаблона tp;
      Идентификатор* идент;
      Тип типСпец, дефТип;

      проц  разборСпецИИлиДефолтнТипа()
      {
        // : SpecializationType
        if (проверено(T.Двоеточие))
          типСпец = разборТипа();
        // = DefaultType
        if (проверено(T.Присвоить))
          дефТип = разборТипа();
      }

      switch (сема.вид)
      {
      case T.Алиас:
        // ПараметрАлиасШаблона:
        //         alias Идентификатор
        пропусти(T.Алиас);
        идент = требуетсяИдентификатор(сооб.ОжидалсяАлиасПараметраШаблона);
        разборСпецИИлиДефолтнТипа();
        tp = new ПараметрАлиасШаблона(идент, типСпец, дефТип);
        break;
      case T.Идентификатор:
        идент = сема.идент;
        switch (возьмиСледщ())
        {
        case T.Эллипсис:
          // ПараметрКортежШаблона:
          //         Идентификатор ...
          пропусти(T.Идентификатор); пропусти(T.Эллипсис);
          if (сема.вид == T.Запятая)
            ошибка(ИДС.ПараметрКортежШаблона);
          tp = new ПараметрКортежШаблона(идент);
          break;
        case T.Запятая, T.ПСкобка, T.Двоеточие, T.Присвоить:
          // ПараметрТипаШаблона:
          //         Идентификатор
          пропусти(T.Идентификатор);
          разборСпецИИлиДефолтнТипа();
          tp = new ПараметрТипаШаблона(идент, типСпец, дефТип);
          break;
        default:
          // ПараметрШаблонЗначения:
          //         Декларатор
          идент = пусто;
          goto LTemplateValueParameter;
        }
        break;
      version(D2)
      {
      case T.Этот:
        // ПараметрЭтотШаблона
        //         this ПараметрТипаШаблона
        пропусти(T.Этот);
        идент = требуетсяИдентификатор(сооб.ОжидалосьИмяДляПараметраШаблонаThis);
        разборСпецИИлиДефолтнТипа();
        tp = new ПараметрЭтотШаблона(идент, типСпец, дефТип);
        break;
      }
      default:
      LTemplateValueParameter:
        // ПараметрШаблонЗначения:
        //         Декларатор
        Выражение спецЗначение, дефЗначение;
        auto типЗначение = разборДекларатора(идент);
        // : SpecializationValue
        if (проверено(T.Двоеточие))
          спецЗначение = разборУсловнВыражения();
        // = DefaultValue
        if (проверено(T.Присвоить))
          дефЗначение = разборУсловнВыражения();
        tp = new ПараметрШаблонЗначения(типЗначение, идент, спецЗначение, дефЗначение);
      }

      // Push template parameter.
      шпарамы ~= установи(tp, началоПарама);

    } while (проверено(T.Запятая))
  }

  /// Возвращает ткст of a сема printable в the client.
  ткст дайПечатный(Сема* сема)
  { // TODO: there are some другой семы that have в be handled, в.g. тксты.
    return сема.вид == T.КФ ? "КФ" : сема.исхТекст;
  }

  alias требуется ожидаемое;

  /// Requires a сема of вид лекс.
  проц  требуется(TOK лекс)
  {
    if (сема.вид == лекс)
      далее();
    else
      ошибка2(ИДС.НайденоИноеЧемОжидалось, Сема.вТкст(лекс), сема);
  }

  /// Requires the следщ сема в be of вид лекс.
  проц  требуетсяСледующий(TOK лекс)
  {
    далее();
    требуется(лекс);
  }

  /// Optionally parses an идентификатор.
  /// Возвращает: пусто или the идентификатор.
  Идентификатор* дополнительныйИдентификатор()
  {
    Идентификатор* ид;
    if (сема.вид == T.Идентификатор)
      (ид = сема.идент), пропусти(T.Идентификатор);
    return ид;
  }

  Идентификатор* требуетсяИдентификатор()
  {
    Идентификатор* ид;
    if (сема.вид == T.Идентификатор)
      (ид = сема.идент), пропусти(T.Идентификатор);
    else
      ошибка(ИДС.НайденоИноеЧемОжидалось, "Идентификатор", сема.исхТекст);
    return ид;
  }

  /// Отчёт об ошибке if the current сема is not an идентификатор.
  /// Параметры:
  ///   ошСооб = the ошибка сообщение в be used.
  /// Возвращает: пусто или the идентификатор.
  Идентификатор* требуетсяИдентификатор(ткст ошСооб)
  {
    Идентификатор* ид;
    if (сема.вид == T.Идентификатор)
      (ид = сема.идент), пропусти(T.Идентификатор);
    else
      ошибка(сема, ошСооб, сема.исхТекст);
    return ид;
  }

  /// Отчёт об ошибке if the current сема is not an идентификатор.
  /// Параметры:
  ///   идс = the ошибка сообщение ID в be used.
  /// Возвращает: пусто или the идентификатор.
  Идентификатор* требуетсяИдентификатор(ИДС идс)
  {
    Идентификатор* ид;
    if (сема.вид == T.Идентификатор)
      (ид = сема.идент), пропусти(T.Идентификатор);
    else
      ошибка(идс, сема.исхТекст);
    return ид;
  }

  /// Отчёт об ошибке if the current сема is not an идентификатор.
  /// Возвращает: пусто или the сема.
  Сема* требуетсяИд()
  {
    Сема* семаИд;
    if (сема.вид == T.Идентификатор)
      (семаИд = сема), пропусти(T.Идентификатор);
    else
      ошибка(ИДС.НайденоИноеЧемОжидалось, "Идентификатор", сема.исхТекст);
    return семаИд;
  }

  Сема* требуетсяСемаИд(ткст ошСооб)
  {
    Сема* семаИд;
    if (сема.вид == T.Идентификатор)
      (семаИд = сема), пропусти(T.Идентификатор);
    else
    {
      ошибка(сема, ошСооб, сема.исхТекст);
      семаИд = лексер.вставьПустуюСемуПеред(сема);
      this.предыдущСема = семаИд;
    }
    return семаИд;
  }

  /// Отчёт об ошибке if the закрывающий counterpart of a сема is not found.
  проц  требуетсяЗакрыв(TOK закрывающий, Сема* открывающий)
  {
    assert(закрывающий == T.ПФСкобка || закрывающий == T.ПСкобка || закрывающий == T.ПКвСкобка);
    assert(открывающий !is пусто);
    if (!проверено(закрывающий))
    {
      auto место = открывающий.дайРеальноеПоложение();
      auto открывающийLoc = Формат("(открывающий @{},{})", место.номерСтроки, место.номСтолб);
      //ошибка(сема, сооб.ExpectedClosing,
            //Сема.вТкст(закрывающий), открывающийLoc, дайПечатный(сема));
    }
  }

  /// Возвращает "да", если the ткст ткт has an invalid UTF-8 sequence.
  бул естьНеверныйЮ8(ткст ткт, Сема* начало)
  {
    auto invalidUTF8Seq = Лексер.найдиНедействительнуюПоследовательностьУТФ8(ткт);
    if (invalidUTF8Seq.length)
      ошибка(начало, сооб.НедействительнаяПоследовательностьУТФ8ВТексте, invalidUTF8Seq);
    return invalidUTF8Seq.length != 0;
  }

  /// Fилиwards ошибка параметры.
  проц  ошибка(Сема* сема, ткст форматирСооб, ...)
  {
    ошибка_(сема, форматирСооб, _arguments, _argptr);
  }
  /// определено
  проц  ошибка(ИДС идс, ...)
  {
    ошибка_(this.сема, ДайСооб(идс), _arguments, _argptr);
  }

  /// определено
  проц  ошибка2(ткст форматирСооб, Сема* сема)
  {
    ошибка(сема, форматирСооб, дайПечатный(сема));
  }
  /// определено
  проц  ошибка2(ИДС идс, Сема* сема)
  {
    ошибка(идс, дайПечатный(сема));
  }
  /// определено
  проц  ошибка2(ИДС идс, ткст арг, Сема* сема)
  {
    ошибка(идс, арг, дайПечатный(сема));
  }

  /// Создаёт отчёт об ошибках и добавляет его в список.
  /// Параметры:
  ///   сема = используется для получения позиции ошибки.
  ///   форматирСооб = сообщение компилятора об ошибке.
  проц  ошибка_(Сема* сема, ткст форматирСооб, ИнфОТипе[] _arguments, base.спис_ва _argptr)
  {
    if (пробуем)
    {
      счётОшибок++;
      return;
    }
    auto положение = сема.дайПоложениеОшибки();
    auto сооб = Формат(_arguments, _argptr, форматирСооб);
    auto ошибка = new ОшибкаПарсера(положение, сооб);
    ошибки ~= ошибка;
    if (диаг !is пусто)
      диаг ~= ошибка;
  }
}
