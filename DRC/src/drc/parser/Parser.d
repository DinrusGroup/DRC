/// Author: Aziz Köksal
/// License: GPL3
/// $(Maturity very high)
module drc.parser.Parser;

import drc.lexer.Lexer,
       drc.lexer.IdTable;
import drc.ast.Node,
       drc.ast.Declarations,
       drc.ast.Statements,
       drc.ast.Expressions,
       drc.ast.Types,
       drc.ast.Parameters;
import drc.Messages;
import drc.Diagnostics;
import drc.Enums;
import drc.CompilerInfo;
import drc.SourceText;
import drc.Unicode;
import common;

import tango.core.Vararg;

/// Парсер производит полный разбор дерева путём исследования
/// списка сем, предоставляемого Лексером.
class Парсер
{
  Лексер лексер; /// Используется для "лексирования" исходного кода.
  Сема* сема; /// Текущая непробельная сема.
  Сема* предыдущСема; /// Предыдущая непробельная сема.

  Диагностика диаг;
  ОшибкаПарсера[] ошибки; /// Массив сообщений об ошибках парсера.

  ДекларацияИмпорта[] импорты; /// ДекларацииИмпорта в исходном тексте.

  /// Атрибуты оцениваются на фазе парсирования.
  /// TODO: будет удалено. СемантическаяПроходка1 прозводит обработку атрибутов.
  ТипКомпоновки типКомпоновки;
  Защита защита; /// определено
  КлассХранения классХранения; /// определено
  бцел размерРаскладки = РАЗМЕР_РАСКЛАДКИ_ПО_УМОЛЧАНИЮ; /// определено

  private alias TOK T; /// Часто используется данным классом.
  private alias УзелТипа Тип;

  /// Строит объект Парсер.
  /// Параметры:
  ///   исхТекст = the UTF-8 source код.
  ///   диаг = используется для сбора сообщений об ошибке.
  this(ИсходныйТекст исхТекст, Диагностика диаг = null)
  {
    this.диаг = диаг;
    лексер = new Лексер(исхТекст, диаг);
  }

  /// Переходит к первой семе.
  protected проц  иниц()
  {
    далее();
    предыдущСема = сема;
  }

  /// Переходит к следующей семе.
  проц  далее()
  {
    предыдущСема = сема;
    do
    {
      лексер.следщСема();
      сема = лексер.сема;
    } while (сема.пробел_ли) // Skip whitespace
  }

  /// Запускает парсер и возвращает парсированные декларации.
  СложнаяДекларация старт()
  {
    иниц();
    auto начало = сема;
    auto деклы = new СложнаяДекларация;
    if (сема.вид == T.Модуль)
      деклы ~= разборДекларацииМодуля();
    деклы.добавьОпцОтпрыски(разборДефиницииДеклараций());
    установи(деклы, начало);
    return деклы;
  }

  /// Запускает парсер и возвращает парсированные выражения.
  Выражение старт2()
  {
    иниц();
    return разборВыражения();
  }

  // Members related в the method пробуй_().
  бцел пробуем; /// Больше than 0 if Парсер is in пробуй_().
  бцел счётОшибок; /// Используется для отслеживания числа ошибок при обороте пробуй_().

  /// Этот method executes the delegate методРазбора and when an ошибка occurred
  /// the state of the лексер and парсер is restored.
  /// Возвращает: the return значение of методРазбора().
  ТипИтога пробуй_(ТипИтога)(ТипИтога delegate() методРазбора, out бул успех)
  {
    // Save члены.
    auto старСема     = this.сема;
    auto старПредшСема = this.предыдущСема;
    auto старСчёт     = this.счётОшибок;

    ++пробуем;
    auto результат = методРазбора();
    --пробуем;
    // Check if an ошибка occurred.
    if (счётОшибок != старСчёт)
    { // Restore члены.
      сема       = старСема;
      предыдущСема   = старПредшСема;
      лексер.сема = старСема;
      счётОшибок  = старСчёт;
      успех = нет;
    }
    else
      успех = да;
    return результат;
  }

  /// Вызывает неудачное завершение текущего вызова пробуй_().
  проц  провал_пробы()
  {
    assert(пробуем);
    счётОшибок++;
  }

  /// Устанавливает начало и конец семы узла синтактического древа.
  Класс установи(Класс)(Класс узел, Сема* начало)
  {
    узел.установиСемы(начало, this.предыдущСема);
    return узел;
  }

  ///Устанавливает начало и конец семы узла синтактического древа.
  Класс установи(Класс)(Класс узел, Сема* начало, Сема* конец)
  {
    узел.установиСемы(начало, конец);
    return узел;
  }

  /// Returns да if установи() has been called on a узел.
  static бул узелУстановлен(Узел узел)
  {
    return узел.начало !is null && узел.конец !is null;
  }

  /// Возвращает вид следующей семы.
  TOK возьмиСледщ()
  {
    Сема* следщ = сема;
    do
      лексер.возьми(следщ);
    while (следщ.пробел_ли) // Skip whitespace
    return следщ.вид;
  }

  /// Возвращает род семы, следующей за t.
  TOK возьмиПосле(ref Сема* t)
  {
    assert(t !is null);
    do
      лексер.возьми(t);
    while (t.пробел_ли) // Skip whitespace
    return t.вид;
  }

  /// Проверяет теущую сему на соответствие k по виду и возвращает да.
  бул проверено()(TOK k) // Templatized, so it's inlined.
  {
    return сема.вид == k ? (далее(), да) : нет;
  }

  /// Проверяет, чтобы текущая сема была ожидаемого вида,
  /// затем приступает за следующую сему.
  проц  пропусти()(TOK ожидаемыйВид)
  {
    assert(сема.вид == ожидаемыйВид /+|| *(цел*).иниц+/, сема.исхТекст());
    далее();
  }

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                       Методы парсинга деклараций                         |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

  Декларация разборДекларацииМодуля()
  {
    auto начало = сема;
    пропусти(T.Модуль);
    ПКИМодуля пкиМодуля;
    do
      пкиМодуля ~= требуетсяИдентификатор(сооб.ОжидалсяИдентификаторМодуля);
    while (проверено(T.Точка))
    требуется(T.ТочкаЗапятая);
    return установи(new ДекларацияМодуля(пкиМодуля), начало);
  }

  /// Парсирует "Дефиниции Деклараций" (определения объявлений) до конца файла.
  /// $(PRE
  /// DeclDefs :=
  ///     DeclDef
  ///     DeclDefs
  /// )
  Декларация[] разборДефиницииДеклараций()
  {
    Декларация[] деклы;
    while (сема.вид != T.КФ)
      деклы ~= разборДефиницииДекларации();
    return деклы;
  }

  /// Парсирует тело шаблона, класса, интерфейса структуры или союза.
  /// $(PRE
  /// DeclDefsBlock :=
  ///     { }
  ///     { DeclDefs }
  /// )
  СложнаяДекларация разборТелаДефиницииДекларации()
  {
    // Save attributes.
    auto типКомпоновки  = this.типКомпоновки;
    auto защита   = this.защита;
    auto классХранения = this.классХранения;
    // Clear attributes.
    this.типКомпоновки  = ТипКомпоновки.Нет;
    this.защита   = Защита.Нет;
    this.классХранения = КлассХранения.Нет;

    // Parse body.
    auto начало = сема;
    auto деклы = new СложнаяДекларация;
    требуется(T.ЛФСкобка);
    while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
      деклы ~= разборДефиницииДекларации();
    требуетсяЗакрыв(T.ПФСкобка, начало);
    установи(деклы, начало);

    // Restore original значения.
    this.типКомпоновки  = типКомпоновки;
    this.защита   = защита;
    this.классХранения = классХранения;

    return деклы;
  }

  /// Парсирует ДефиницияДекларации.
  Декларация разборДефиницииДекларации()
  out(декл)
  { assert(узелУстановлен(декл)); }
  body
  {
    auto начало = сема;
    Декларация декл;
    switch (сема.вид)
    {
    case T.Расклад,
         T.Прагма,
         // Защита attributes
         T.Экспорт,
         T.Приватный,
         T.Пакет,
         T.Защищённый,
         T.Публичный:
      декл = парсируйОпределительАтрибута();
      break;
    // Storage classes
    case T.Экстерн,
         T.Устаревший,
         T.Перепись,
         T.Абстрактный,
         T.Синхронизованный,
         //T.Статический,
         T.Окончательный,
         T.Конст,
         //T.Инвариант, // D 2.0
         T.Авто,
         T.Масштаб:
    случай_СтатичАтрибут:
    случай_АтрибутИнвариант: // D 2.0
    случай_АтрибутПеречень: // D 2.0
      return парсируйАтрибутСохранения();
    case T.Алиас:
      далее();
      декл = new ДекларацияАлиаса(парсируйПеременнаяИлиФункция());
      break;
    case T.Типдеф:
      далее();
      декл = new ДекларацияТипдефа(парсируйПеременнаяИлиФункция());
      break;
    case T.Статический:
      switch (возьмиСледщ())
      {
      case T.Импорт:
        goto случай_Импорт;
      case T.Этот:
        декл = парсируйДекларациюСтатичКонструктора();
        break;
      case T.Тильда:
        декл = парсируйДекларациюСтатичДеструктора();
        break;
      case T.Если:
        декл = парсируйДекларациюСтатичЕсли();
        break;
      case T.Подтвердить:
        декл = парсируйДекларациюСтатичАссерта();
        break;
      default:
        goto случай_СтатичАтрибут;
      }
      break;
    case T.Импорт:
    случай_Импорт:
      декл = разборДекларацииИмпорта();
      импорты ~= декл.в!(ДекларацияИмпорта);
      // Handle specially. КлассХранения mustn't be установи.
      декл.установиЗащиту(this.защита);
      return установи(декл, начало);
    case T.Перечень:
    version(D2)
    {
      if (манифестПеречня_ли())
        goto случай_АтрибутПеречень;
    }
      декл = парсируйДекларациюПеречня();
      break;
    case T.Класс:
      декл = парсируйДекларациюКласса();
      break;
    case T.Интерфейс:
      декл = парсируйДекларациюИнтерфейса();
      break;
    case T.Структура, T.Союз:
      декл = парсируйДекларациюСтруктурыИлиСоюза();
      break;
    case T.Этот:
      декл = парсируйДекларациюКонструктора();
      break;
    case T.Тильда:
      декл = парсируйДекларациюДеструктора();
      break;
    case T.Инвариант:
    version(D2)
    {
      auto следщ = сема;
      if (возьмиПосле(следщ) == T.ЛСкобка)
      {
        if (возьмиПосле(следщ) != T.ПСкобка)
          goto случай_Декларация;  // invariant ( Тип )
      }
      else
        goto случай_АтрибутИнвариант; // invariant as КлассХранения.
    }
      декл = парсируйДекларациюИнварианта(); // invariant ( )
      break;
    case T.Юниттест:
      декл = парсируйДекларациюЮниттеста();
      break;
    case T.Отладка:
      декл = парсируйДекларациюОтладки();
      break;
    case T.Версия:
      декл = парсируйДекларациюВерсии();
      break;
    case T.Шаблон:
      декл = парсируйДекларациюШаблона();
      break;
    case T.Нов:
      декл = парсируйДекларациюНов();
      break;
    case T.Удалить:
      декл = парсируйДекларациюУдалить();
      break;
    case T.Смесь:
      декл = парсируйМиксин!(ДекларацияСмеси)();
      break;
    case T.ТочкаЗапятая:
      далее();
      декл = new ПустаяДекларация();
      break;
    // Декларация
    case T.Идентификатор, T.Точка, T.Типа:
    случай_Декларация:
      return парсируйПеременнаяИлиФункция(this.классХранения, this.защита, this.типКомпоновки);
    default:
      if (сема.интегральныйТип_ли)
        goto случай_Декларация;
      else if (сема.вид == T.Модуль)
      {
        декл = разборДекларацииМодуля();
        ошибка(начало, сооб.ДекларацияМодуляНеПервая);
        return декл;
      }

      декл = new НелегальнаяДекларация();
      // Skip в следщ valid сема.
      do
        далее();
      while (!сема.началоДефДекл_ли &&
              сема.вид != T.ПФСкобка &&
              сема.вид != T.КФ)
      auto текст = Сема.textSpan(начало, this.предыдущСема);
      ошибка(начало, сооб.НелегальнаяДекларация, текст);
    }
    декл.установиЗащиту(this.защита);
    декл.установиКлассХранения(this.классХранения);
    assert(!узелУстановлен(декл));
    установи(декл, начало);
    return декл;
  }

  /// Parses a DeclarationsBlock.
  /// $(PRE
  /// DeclarationsBlock :=
  ///     : DeclDefs
  ///     { }
  ///     { DeclDefs }
  ///     DeclDef
  /// )
  Декларация разборБлокаДеклараций(/+бул noДвоеточие = нет+/)
  {
    Декларация d;
    switch (сема.вид)
    {
    case T.ЛФСкобка:
      auto начало = сема;
      далее();
      auto деклы = new СложнаяДекларация;
      while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
        деклы ~= разборДефиницииДекларации();
      требуетсяЗакрыв(T.ПФСкобка, начало);
      d = установи(деклы, начало);
      break;
    case T.Двоеточие:
      // if (noДвоеточие == да)
      //   goto default;
      далее();
      auto начало = сема;
      auto деклы = new СложнаяДекларация;
      while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
        деклы ~= разборДефиницииДекларации();
      d = установи(деклы, начало);
      break;
    default:
      d = разборДефиницииДекларации();
    }
    assert(узелУстановлен(d));
    return d;
  }

  // Декларация разборБлокаДекларацийNoДвоеточие()
  // {
  //   return разборБлокаДеклараций(да);
  // }

  /// Parses either a ДекларацияПеременной or a ДекларацияФункции.
  /// Параметры:
  ///   кхр = предшiously parsed storage classes
  ///   защита = предшiously parsed защита attribute
  ///   типКомпоновки = предшiously parsed linkage тип
  ///   testAutoDeclaration = whether в check for an ДекларацияАвто
  ///   optionalParameterList = a hint for how в разбор C-style function pointers
  Декларация парсируйПеременнаяИлиФункция(КлассХранения кхр = КлассХранения.Нет,
                                      Защита защита = Защита.Нет,
                                      ТипКомпоновки типКомпоновки = ТипКомпоновки.Нет,
                                      бул testAutoDeclaration = нет,
                                      бул optionalParameterList = да)
  {
    auto начало = сема;
    Тип тип;
    Идентификатор* имя;

    // Check for ДекларацияАвто: КлассыСохранения Идентификатор =
    if (testAutoDeclaration && сема.вид == T.Идентификатор)
    {
      auto вид = возьмиСледщ();
      if (вид == T.Присвоить)
      { // Авто переменная declaration.
        имя = сема.идент;
        пропусти(T.Идентификатор);
        goto LparseVariables;
      }
      else version(D2) if (вид == T.ЛСкобка)
      { // Check for auto return тип template function.
        // КлассыСохранения Name ( TemplateParameterList ) ( ParameterList )
        имя = сема.идент;
        auto следщ = сема;
        возьмиПосле(следщ);
        if (tokenAfterParenIs(T.ЛСкобка, следщ))
        {
          пропусти(T.Идентификатор);
          assert(сема.вид == T.ЛСкобка);
          goto LparseTPList; // Далее with parsing a template function.
        }
      }
    }

    тип = разборТипа(); // VariableType or ТипИтога

    if (сема.вид == T.ЛСкобка)
    { // Указатели на функции в стиле Си усложняют грамматику.
      // С ними приходится иметь дело отдельно, в масштабе функции.
      // Пример:
      //   проц  foo() {
      //     // Указатель на функцию, принимающий целое число и возвращающий 'some_type'.
      //     some_type (*p_func)(цел);
      //     // Вхо the following case precedence is given в a ВыражениеВызов.
      //     something(*p); // 'something' may be a function/method or an object having opCall overloaded.
      //   }
      //   // A pointer в a function taking no parameters and returning 'something'.
      //   something(*p);
      тип = parseCFunctionPointerType(тип, имя, optionalParameterList);
    }
    else if (возьмиСледщ() == T.ЛСкобка)
    { // Тип FunctionName ( ParameterList ) FunctionBody
      имя = требуетсяИдентификатор(сооб.ОжидалосьНазваниеФункции);
      имя || далее(); // Skip non-identifier сема.
      assert(сема.вид == T.ЛСкобка);
      // It's a function declaration
      ПараметрыШаблона шпарамы;
      Выражение констрейнт;

      if (tokenAfterParenIs(T.ЛСкобка))
      LparseTPList:
        // ( TemplateParameterList ) ( ParameterList )
        шпарамы = parseTemplateParameterList();

      auto парамы = parseParameterList();
    version(D2)
    {
      if (шпарамы) // Если ( ConstraintExpression )
        констрейнт = parseOptionalConstraint();
      switch (сема.вид)
      {
      case T.Конст:
        кхр |= КлассХранения.Конст;
        далее();
        break;
      case T.Инвариант:
        кхр |= КлассХранения.Инвариант;
        далее();
        break;
      default:
      }
    }
      // ТипИтога FunctionName ( ParameterList )
      auto телоФунк = разборТелаФункции();
      auto дф = new ДекларацияФункции(тип, имя,/+ шпарамы,+/ парамы, телоФунк);
      дф.установиКлассХранения(кхр);
      дф.установиТипКомпоновки(типКомпоновки);
      дф.установиЗащиту(защита);
      if (шпарамы)
      {
        auto d = поместиДекларациюВнутреннегоШаблона(начало, имя, дф, шпарамы, констрейнт);
        d.установиКлассХранения(кхр);
        d.установиЗащиту(защита);
        return установи(d, начало);
      }
      return установи(дф, начало);
    }
    else
    { // Тип VariableName DeclaratorSuffix
      имя = требуетсяИдентификатор(сооб.ОжидалосьНазваниеПеременной);
      тип = parseDeclaratorSuffix(тип);
    }

  LparseVariables:
    // It's a переменные declaration.
    Идентификатор*[] имена = [имя]; // One identifier has been parsed already.
    Выражение[] значения;
    goto LenterLoop; // Enter the loop and check for an initializer.
    while (проверено(T.Запятая))
    {
      имена ~= требуетсяИдентификатор(сооб.ОжидалосьНазваниеПеременной);
    LenterLoop:
      if (проверено(T.Присвоить))
        значения ~= parseInitializer();
      else
        значения ~= null;
    }
    требуется(T.ТочкаЗапятая);
    auto d = new ДекларацияПеременных(тип, имена, значения);
    d.установиКлассХранения(кхр);
    d.установиТипКомпоновки(типКомпоновки);
    d.установиЗащиту(защита);
    return установи(d, начало);
  }

  /// Parses a переменная initializer.
  Выражение parseInitializer()
  {
    if (сема.вид == T.Проц)
    {
      auto начало = сема;
      auto следщ = возьмиСледщ();
      if (следщ == T.Запятая || следщ == T.ТочкаЗапятая)
      {
        пропусти(T.Проц);
        return установи(new ВыражениеИницПроц(), начало);
      }
    }
    return parseNonVoidInitializer();
  }

  Выражение parseNonVoidInitializer()
  {
    auto начало = сема;
    Выражение иниц;
    switch (сема.вид)
    {
    case T.ЛКвСкобка:
      // ArrayInitializer:
      //         [ ]
      //         [ ArrayMemberInitializations ]
      Выражение[] ключи;
      Выражение[] значения;

      пропусти(T.ЛКвСкобка);
      while (сема.вид != T.ПКвСкобка)
      {
        auto в = parseNonVoidInitializer();
        if (проверено(T.Двоеточие))
        {
          ключи ~= в;
          значения ~= parseNonVoidInitializer();
        }
        else
        {
          ключи ~= null;
          значения ~= в;
        }

        if (!проверено(T.Запятая))
          break;
      }
      требуетсяЗакрыв(T.ПКвСкобка, начало);
      иниц = new ВыражениеИницМассива(ключи, значения);
      break;
    case T.ЛФСкобка:
      // StructInitializer:
      //         { }
      //         { StructMemberInitializers }
      Выражение parseStructInitializer()
      {
        Идентификатор*[] idents;
        Выражение[] значения;

        пропусти(T.ЛФСкобка);
        while (сема.вид != T.ПФСкобка)
        {
          if (сема.вид == T.Идентификатор &&
              // Peek for colon в see if this is a член identifier.
              возьмиСледщ() == T.Двоеточие)
          {
            idents ~= сема.идент;
            пропусти(T.Идентификатор), пропусти(T.Двоеточие);
          }
          else
            idents ~= null;

          // NonVoidInitializer
          значения ~= parseNonVoidInitializer();

          if (!проверено(T.Запятая))
            break;
        }
        требуетсяЗакрыв(T.ПФСкобка, начало);
        return new ВыражениеИницСтрукуры(idents, значения);
      }

      бул успех;
      auto si = пробуй_(&parseStructInitializer, успех);
      if (успех)
      {
        иниц = si;
        break;
      }
      assert(сема.вид == T.ЛФСкобка);
      //goto default;
    default:
      иниц = parseAssignExpression();
    }
    установи(иниц, начало);
    return иниц;
  }

  ИнструкцияТелаФункции разборТелаФункции()
  {
    auto начало = сема;
    auto func = new ИнструкцияТелаФункции;
    while (1)
    {
      switch (сема.вид)
      {
      case T.ЛФСкобка:
        func.телоФунк = parseStatements();
        break;
      case T.ТочкаЗапятая:
        далее();
        break;
      case T.Вхо:
        if (func.телоВхо)
          ошибка(ИДС.InContract);
        далее();
        func.телоВхо = parseStatements();
        continue;
      case T.Вых:
        if (func.телоВых)
          ошибка(ИДС.OutContract);
        далее();
        if (проверено(T.ЛСкобка))
        {
          auto leftParen = this.предыдущСема;
          func.outIdent = требуетсяИдентификатор(сооб.ОжидалсяИдентификатор);
          требуетсяЗакрыв(T.ПСкобка, leftParen);
        }
        func.телоВых = parseStatements();
        continue;
      case T.Тело:
        далее();
        goto case T.ЛФСкобка;
      default:
        ошибка2(сооб.ОжидалосьТелоФункции, сема);
      }
      break; // Exit loop.
    }
    установи(func, начало);
    func.завершиКонструкцию();
    return func;
  }

  ТипКомпоновки parseLinkageType()
  {
    ТипКомпоновки типКомпоновки;

    if (!проверено(T.ЛСкобка))
      return типКомпоновки;

    if (проверено(T.ПСкобка))
    { // extern()
      ошибка(ИДС.MissingLinkageType);
      return типКомпоновки;
    }

    auto identTok = requireId();

    ВИД видИд = identTok ? identTok.идент.видИд : ВИД.Нуль;

    switch (видИд)
    {
    case ВИД.C:
      if (проверено(T.ПлюсПлюс))
      {
        типКомпоновки = ТипКомпоновки.Cpp;
        break;
      }
      типКомпоновки = ТипКомпоновки.C;
      break;
    case ВИД.D:
      типКомпоновки = ТипКомпоновки.D;
      break;
    case ВИД.Windows:
      типКомпоновки = ТипКомпоновки.Windows;
      break;
    case ВИД.Pascal:
      типКомпоновки = ТипКомпоновки.Pascal;
      break;
    case ВИД.System:
      типКомпоновки = ТипКомпоновки.Система;
      break;
    default:
      ошибка2(ИДС.UnrecognizedLinkageType, сема);
    }
    требуется(T.ПСкобка);
    return типКомпоновки;
  }

  проц  checkLinkageType(ref ТипКомпоновки предш_lt, ТипКомпоновки lt, Сема* начало)
  {
    if (предш_lt == ТипКомпоновки.Нет)
      предш_lt = lt;
    else
      ошибка(начало, сооб.ПовторяющийсяТипЛинковки, Сема.textSpan(начало, this.предыдущСема));
  }

  Декларация парсируйАтрибутСохранения()
  {
    КлассХранения кхр, stc_tmp;
    ТипКомпоновки предш_linkageType;

    auto saved_storageClass = this.классХранения; // Save.
    // Nested function.
    Декларация разбор()
    {
      Декларация декл;
      auto начало = сема;
      switch (сема.вид)
      {
      case T.Экстерн:
        if (возьмиСледщ() != T.ЛСкобка)
        {
          stc_tmp = КлассХранения.Экстерн;
          goto Lcommon;
        }

        далее();
        auto типКомпоновки = parseLinkageType();
        checkLinkageType(предш_linkageType, типКомпоновки, начало);

        auto saved = this.типКомпоновки; // Save.
        this.типКомпоновки = типКомпоновки; // Set.
        декл = new ДекларацияКомпоновки(типКомпоновки, разбор());
        установи(декл, начало);
        this.типКомпоновки = saved; // Restore.
        break;
      case T.Перепись:
        stc_tmp = КлассХранения.Перепись;
        goto Lcommon;
      case T.Устаревший:
        stc_tmp = КлассХранения.Устаревший;
        goto Lcommon;
      case T.Абстрактный:
        stc_tmp = КлассХранения.Абстрактный;
        goto Lcommon;
      case T.Синхронизованный:
        stc_tmp = КлассХранения.Синхронизованный;
        goto Lcommon;
      case T.Статический:
        stc_tmp = КлассХранения.Статический;
        goto Lcommon;
      case T.Окончательный:
        stc_tmp = КлассХранения.Окончательный;
        goto Lcommon;
      case T.Конст:
      version(D2)
      {
        if (возьмиСледщ() == T.ЛСкобка)
          goto случай_Декларация;
      }
        stc_tmp = КлассХранения.Конст;
        goto Lcommon;
      version(D2)
      {
      case T.Инвариант: // D 2.0
        auto следщ = сема;
        if (возьмиПосле(следщ) == T.ЛСкобка)
        {
          if (возьмиПосле(следщ) != T.ПСкобка)
            goto случай_Декларация; // invariant ( Тип )
          декл = парсируйДекларациюИнварианта(); // invariant ( )
          // NB: this must be similar в the код at the конец of
          //     разборДефиницииДекларации().
          декл.установиЗащиту(this.защита);
          декл.установиКлассХранения(кхр);
          установи(декл, начало);
          break;
        }
        // invariant as КлассХранения.
        stc_tmp = КлассХранения.Инвариант;
        goto Lcommon;
      case T.Перечень: // D 2.0
        if (!манифестПеречня_ли())
        { // A normal enum declaration.
          декл = парсируйДекларациюПеречня();
          // NB: this must be similar в the код at the конец of
          //     разборДефиницииДекларации().
          декл.установиЗащиту(this.защита);
          декл.установиКлассХранения(кхр);
          установи(декл, начало);
          break;
        }
        // enum as КлассХранения.
        stc_tmp = КлассХранения.Манифест;
        goto Lcommon;
      } // version(D2)
      case T.Авто:
        stc_tmp = КлассХранения.Авто;
        goto Lcommon;
      case T.Масштаб:
        stc_tmp = КлассХранения.Масштаб;
        goto Lcommon;
      Lcommon:
        // Issue ошибка if redundant.
        if (кхр & stc_tmp)
          ошибка2(ИДС.RedundantStorageClass, сема);
        else
          кхр |= stc_tmp;

        далее();
        декл = new ДекларацияКлассаХранения(stc_tmp, разбор());
        установи(декл, начало);
        break;
      case T.Идентификатор:
      случай_Декларация:
        // Этот could be a normal Декларация or an ДекларацияАвто
        декл = парсируйПеременнаяИлиФункция(кхр, this.защита, предш_linkageType, да);
        break;
      default:
        this.классХранения = кхр; // Set.
        декл = разборБлокаДеклараций();
        this.классХранения = saved_storageClass; // Reset.
      }
      assert(узелУстановлен(декл));
      return декл;
    }
    return разбор();
  }

  бцел parseAlignAttribute()
  {
    пропусти(T.Расклад);
    бцел размер = РАЗМЕР_РАСКЛАДКИ_ПО_УМОЛЧАНИЮ; // Global default.
    if (проверено(T.ЛСкобка))
    {
      if (сема.вид == T.Цел32)
        (размер = сема.цел_), пропусти(T.Цел32);
      else
        ожидаемое(T.Цел32);
      требуется(T.ПСкобка);
    }
    return размер;
  }

  Декларация парсируйОпределительАтрибута()
  {
    Декларация декл;

    switch (сема.вид)
    {
    case T.Расклад:
      бцел размерРаскладки = parseAlignAttribute();
      auto saved = this.размерРаскладки; // Save.
      this.размерРаскладки = размерРаскладки; // Set.
      декл = new ДекларацияРазложи(размерРаскладки, разборБлокаДеклараций());
      this.размерРаскладки = saved; // Restore.
      break;
    case T.Прагма:
      // Прагма:
      //     pragma ( Идентификатор )
      //     pragma ( Идентификатор , ExpressionList )
      далее();
      Идентификатор* идент;
      Выражение[] арги;

      требуется(T.ЛСкобка);
      идент = требуетсяИдентификатор(сооб.ОжидалсяИдентификаторПрагмы);

      if (проверено(T.Запятая))
        арги = parseExpressionList();
      требуется(T.ПСкобка);

      декл = new ДекларацияПрагмы(идент, арги, разборБлокаДеклараций());
      break;
    default:
      // Защита attributes
      Защита защ;
      switch (сема.вид)
      {
      case T.Приватный:
        защ = Защита.Приватный; break;
      case T.Пакет:
        защ = Защита.Пакет; break;
      case T.Защищённый:
        защ = Защита.Защищённый; break;
      case T.Публичный:
        защ = Защита.Публичный; break;
      case T.Экспорт:
        защ = Защита.Экспорт; break;
      default:
        assert(0);
      }
      далее();
      auto saved = this.защита; // Save.
      this.защита = защ; // Set.
      декл = new ДекларацияЗащиты(защ, разборБлокаДеклараций());
      this.защита = saved; // Restore.
    }
    return декл;
  }

  Декларация разборДекларацииИмпорта()
  {
    бул статический_ли = проверено(T.Статический);
    пропусти(T.Импорт);

    ПКИМодуля[] пкиМодулей;
    Идентификатор*[] алиасыМодуля;
    Идентификатор*[] связанныеИмена;
    Идентификатор*[] связанныеАлиасы;

    do
    {
      ПКИМодуля пкиМодуля;
      Идентификатор* moduleAlias;
      // AliasName = ModuleName
      if (возьмиСледщ() == T.Присвоить)
      {
        moduleAlias = требуетсяИдентификатор(сооб.ExpectedAliasModuleName);
        пропусти(T.Присвоить);
      }
      // Идентификатор ("." Идентификатор)*
      do
        пкиМодуля ~= требуетсяИдентификатор(сооб.ОжидалсяИдентификаторМодуля);
      while (проверено(T.Точка))
      // Push identifiers.
      пкиМодулей ~= пкиМодуля;
      алиасыМодуля ~= moduleAlias;
    } while (проверено(T.Запятая))

    if (проверено(T.Двоеточие))
    { // BindAlias "=" BindName ("," BindAlias "=" BindName)*;
      // BindName ("," BindName)*;
      do
      {
        Идентификатор* bindAlias;
        // BindAlias = BindName
        if (возьмиСледщ() == T.Присвоить)
        {
          bindAlias = требуетсяИдентификатор(сооб.ExpectedAliasImportName);
          пропусти(T.Присвоить);
        }
        // Push identifiers.
        связанныеИмена ~= требуетсяИдентификатор(сооб.ExpectedImportName);
        связанныеАлиасы ~= bindAlias;
      } while (проверено(T.Запятая))
    }
    требуется(T.ТочкаЗапятая);

    return new ДекларацияИмпорта(пкиМодулей, алиасыМодуля, связанныеИмена, связанныеАлиасы, статический_ли);
  }

version(D2)
{
  /// Возвращает да, если это an enum manifest or
  /// нет if it's a normal enum declaration.
  бул манифестПеречня_ли()
  {
    assert(сема.вид == T.Перечень);
    auto следщ = сема;
    auto вид = возьмиПосле(следщ);
    if (вид == T.Двоеточие || вид == T.ЛФСкобка)
      return нет; // Anonymous enum.
    else if (вид == T.Идентификатор)
    {
      вид = возьмиПосле(следщ);
      if (вид == T.Двоеточие || вид == T.ЛФСкобка || вид == T.ТочкаЗапятая)
        return нет; // Named enum.
    }
    return да; // Манифест enum.
  }
}

  Декларация парсируйДекларациюПеречня()
  {
    пропусти(T.Перечень);

    Идентификатор* enumName;
    Тип типОснова;
    ДекларацияЧленаПеречня[] члены;
    бул естьТело;

    enumName = optionalIdentifier();

    if (проверено(T.Двоеточие))
      типОснова = parseBasicType();

    if (enumName && проверено(T.ТочкаЗапятая))
    {}
    else if (проверено(T.ЛФСкобка))
    {
      auto leftBrace = this.предыдущСема;
      естьТело = да;
      while (сема.вид != T.ПФСкобка)
      {
        auto начало = сема;

        Тип тип;
      version(D2)
      {
        бул успех;
        пробуй_({
          // Тип Идентификатор = ВыражениеПрисвой
          тип = разборТипа(); // Set outer тип переменная.
          if (сема.вид != T.Идентификатор)
            провал_пробы(), (тип = null);
          return null;
        }, успех);
      }

        auto имя = требуетсяИдентификатор(сооб.ОжидалсяЧленПеречня);
        Выражение значение;

        if (проверено(T.Присвоить))
          значение = parseAssignExpression();

        члены ~= установи(new ДекларацияЧленаПеречня(тип, имя, значение), начало);

        if (!проверено(T.Запятая))
          break;
      }
      требуетсяЗакрыв(T.ПФСкобка, leftBrace);
    }
    else
      ошибка2(сооб.ОжидалосьТелоПеречня, сема);

    return new ДекларацияПеречня(enumName, типОснова, члены, естьТело);
  }

  /// Wraps a declaration внутри a template declaration.
  /// Параметры:
  ///   начало = начало сема of декл.
  ///   имя = имя of декл.
  ///   декл = the declaration в be wrapped.
  ///   шпарамы = the template parameters.
  ///   констрейнт = the констрейнт expression.
  ДекларацияШаблона поместиДекларациюВнутреннегоШаблона(Сема* начало,
                                                   Идентификатор* имя,
                                                   Декларация декл,
                                                   ПараметрыШаблона шпарамы,
                                                   Выражение констрейнт)
  {
    установи(декл, начало);
    auto cd = new СложнаяДекларация;
    cd ~= декл;
    установи(cd, начало);
    return new ДекларацияШаблона(имя, шпарамы, констрейнт, cd);
  }

  Декларация парсируйДекларациюКласса()
  {
    auto начало = сема;
    пропусти(T.Класс);

    Идентификатор* имяКласса;
    ПараметрыШаблона шпарамы;
    Выражение констрейнт;
    ТипКлассОснова[] основы;
    СложнаяДекларация деклы;

    имяКласса = требуетсяИдентификатор(сооб.ОжидалосьНазваниеКласса);

    if (сема.вид == T.ЛСкобка)
    {
      шпарамы = parseTemplateParameterList();
      version(D2) констрейнт = parseOptionalConstraint();
    }

    if (сема.вид == T.Двоеточие)
      основы = parseBaseClasses();

    if (основы.length == 0 && проверено(T.ТочкаЗапятая))
    {}
    else if (сема.вид == T.ЛФСкобка)
      деклы = разборТелаДефиницииДекларации();
    else
      ошибка2(сооб.ОжидалосьТелоКласса, сема);

    Декларация d = new ДекларацияКласса(имяКласса, /+шпарамы, +/основы, деклы);
    if (шпарамы)
      d = поместиДекларациюВнутреннегоШаблона(начало, имяКласса, d, шпарамы, констрейнт);
    return d;
  }

  ТипКлассОснова[] parseBaseClasses(бул colonLeadsOff = да)
  {
    colonLeadsOff && пропусти(T.Двоеточие);

    ТипКлассОснова[] основы;
    do
    {
      Защита защ = Защита.Публичный;
      switch (сема.вид)
      {
      case T.Идентификатор, T.Точка, T.Типа: goto LparseBasicType;
      case T.Приватный:   защ = Защита.Приватный;   break;
      case T.Защищённый: защ = Защита.Защищённый; break;
      case T.Пакет:   защ = Защита.Пакет;   break;
      case T.Публичный:  /*защ = Защита.Публичный;*/  break;
      default:
        ошибка2(ИДС.ExpectedBaseClasses, сема);
        return основы;
      }
      далее(); // Skip защита attribute.
    LparseBasicType:
      auto начало = сема;
      auto тип = parseBasicType();
      основы ~= установи(new ТипКлассОснова(защ, тип), начало);
    } while (проверено(T.Запятая))
    return основы;
  }

  Декларация парсируйДекларациюИнтерфейса()
  {
    auto начало = сема;
    пропусти(T.Интерфейс);

    Идентификатор* имя;
    ПараметрыШаблона шпарамы;
    Выражение констрейнт;
    ТипКлассОснова[] основы;
    СложнаяДекларация деклы;

    имя = требуетсяИдентификатор(сооб.ОжидалосьНазваниеИнтерфейса);

    if (сема.вид == T.ЛСкобка)
    {
      шпарамы = parseTemplateParameterList();
      version(D2) констрейнт = parseOptionalConstraint();
    }

    if (сема.вид == T.Двоеточие)
      основы = parseBaseClasses();

    if (основы.length == 0 && проверено(T.ТочкаЗапятая))
    {}
    else if (сема.вид == T.ЛФСкобка)
      деклы = разборТелаДефиницииДекларации();
    else
      ошибка2(сооб.ОжидалосьТелоИнтерфейса, сема);

    Декларация d = new ДекларацияИнтерфейса(имя, /+шпарамы, +/основы, деклы);
    if (шпарамы)
      d = поместиДекларациюВнутреннегоШаблона(начало, имя, d, шпарамы, констрейнт);
    return d;
  }

  Декларация парсируйДекларациюСтруктурыИлиСоюза()
  {
    assert(сема.вид == T.Структура || сема.вид == T.Союз);
    auto начало = сема;
    пропусти(сема.вид);

    Идентификатор* имя;
    ПараметрыШаблона шпарамы;
    Выражение констрейнт;
    СложнаяДекларация деклы;

    имя = optionalIdentifier();

    if (имя && сема.вид == T.ЛСкобка)
    {
      шпарамы = parseTemplateParameterList();
      version(D2) констрейнт = parseOptionalConstraint();
    }

    if (имя && проверено(T.ТочкаЗапятая))
    {}
    else if (сема.вид == T.ЛФСкобка)
      деклы = разборТелаДефиницииДекларации();
    else
      ошибка2(начало.вид == T.Структура ?
             сооб.ОжидалосьТелоСтруктуры :
             сооб.ОжидалосьТелоСоюза, сема);

    Декларация d;
    if (начало.вид == T.Структура)
    {
      auto sd = new ДекларацияСтруктуры(имя, /+шпарамы, +/деклы);
      sd.установиРазмерРаскладки(this.размерРаскладки);
      d = sd;
    }
    else
      d = new ДекларацияСоюза(имя, /+шпарамы, +/деклы);

    if (шпарамы)
      d = поместиДекларациюВнутреннегоШаблона(начало, имя, d, шпарамы, констрейнт);
    return d;
  }

  Декларация парсируйДекларациюКонструктора()
  {
    пропусти(T.Этот);
    auto parameters = parseParameterList();
    auto телоФунк = разборТелаФункции();
    return new ДекларацияКонструктора(parameters, телоФунк);
  }

  Декларация парсируйДекларациюДеструктора()
  {
    пропусти(T.Тильда);
    требуется(T.Этот);
    требуется(T.ЛСкобка);
    требуется(T.ПСкобка);
    auto телоФунк = разборТелаФункции();
    return new ДекларацияДеструктора(телоФунк);
  }

  Декларация парсируйДекларациюСтатичКонструктора()
  {
    пропусти(T.Статический);
    пропусти(T.Этот);
    требуется(T.ЛСкобка);
    требуется(T.ПСкобка);
    auto телоФунк = разборТелаФункции();
    return new ДекларацияСтатическогоКонструктора(телоФунк);
  }

  Декларация парсируйДекларациюСтатичДеструктора()
  {
    пропусти(T.Статический);
    пропусти(T.Тильда);
    требуется(T.Этот);
    требуется(T.ЛСкобка);
    требуется(T.ПСкобка);
    auto телоФунк = разборТелаФункции();
    return new ДекларацияСтатическогоДеструктора(телоФунк);
  }

  Декларация парсируйДекларациюИнварианта()
  {
    пропусти(T.Инвариант);
    // Optional () for getting ready porting в D 2.0
    if (проверено(T.ЛСкобка))
      требуется(T.ПСкобка);
    auto телоФунк = разборТелаФункции();
    return new ДекларацияИнварианта(телоФунк);
  }

  Декларация парсируйДекларациюЮниттеста()
  {
    пропусти(T.Юниттест);
    auto телоФунк = разборТелаФункции();
    return new ДекларацияЮниттеста(телоФунк);
  }

  Сема* parseIdentOrЦел()
  {
    if (проверено(T.Цел32) || проверено(T.Идентификатор))
      return this.предыдущСема;
    ошибка2(сооб.ОжидалсяИдентИлиЦел, сема);
    return null;
  }

  Сема* parseVersionCondition()
  {
  version(D2)
  {
    if (проверено(T.Юниттест))
      return this.предыдущСема;
  }
    return parseIdentOrЦел();
  }

  Декларация парсируйДекларациюОтладки()
  {
    пропусти(T.Отладка);

    Сема* спец;
    Сема* услов;
    Декларация деклы, деклыИначе;

    if (проверено(T.Присвоить))
    { // debug = Integer ;
      // debug = Идентификатор ;
      спец = parseIdentOrЦел();
      требуется(T.ТочкаЗапятая);
    }
    else
    { // ( Condition )
      if (проверено(T.ЛСкобка))
      {
        услов = parseIdentOrЦел();
        требуется(T.ПСкобка);
      }
      // debug DeclarationsBlock
      // debug ( Condition ) DeclarationsBlock
      деклы = разборБлокаДеклараций();
      // else DeclarationsBlock
      if (проверено(T.Иначе))
        деклыИначе = разборБлокаДеклараций();
    }

    return new ДекларацияОтладки(спец, услов, деклы, деклыИначе);
  }

  Декларация парсируйДекларациюВерсии()
  {
    пропусти(T.Версия);

    Сема* спец;
    Сема* услов;
    Декларация деклы, деклыИначе;

    if (проверено(T.Присвоить))
    { // version = Integer ;
      // version = Идентификатор ;
      спец = parseIdentOrЦел();
      требуется(T.ТочкаЗапятая);
    }
    else
    { // ( Condition )
      требуется(T.ЛСкобка);
      услов = parseVersionCondition();
      требуется(T.ПСкобка);
      // version ( Condition ) DeclarationsBlock
      деклы = разборБлокаДеклараций();
      // else DeclarationsBlock
      if (проверено(T.Иначе))
        деклыИначе = разборБлокаДеклараций();
    }

    return new ДекларацияВерсии(спец, услов, деклы, деклыИначе);
  }

  Декларация парсируйДекларациюСтатичЕсли()
  {
    пропусти(T.Статический);
    пропусти(T.Если);

    Выражение условие;
    Декларация деклыЕсли, деклыИначе;

    auto leftParen = сема;
    требуется(T.ЛСкобка);
    условие = parseAssignExpression();
    требуетсяЗакрыв(T.ПСкобка, leftParen);

    деклыЕсли = разборБлокаДеклараций();

    if (проверено(T.Иначе))
      деклыИначе = разборБлокаДеклараций();

    return new ДекларацияСтатическогоЕсли(условие, деклыЕсли, деклыИначе);
  }

  Декларация парсируйДекларациюСтатичАссерта()
  {
    пропусти(T.Статический);
    пропусти(T.Подтвердить);
    Выражение условие, сообщение;
    auto leftParen = сема;
    требуется(T.ЛСкобка);
    условие = parseAssignExpression();
    if (проверено(T.Запятая))
      сообщение = parseAssignExpression();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    требуется(T.ТочкаЗапятая);
    return new ДекларацияСтатическогоПодтверди(условие, сообщение);
  }

  Декларация парсируйДекларациюШаблона()
  {
    пропусти(T.Шаблон);
    auto имя = требуетсяИдентификатор(сооб.ОжидалосьНазваниеШаблона);
    auto шпарамы = parseTemplateParameterList();
    auto констрейнт = parseOptionalConstraint();
    auto деклы = разборТелаДефиницииДекларации();
    return new ДекларацияШаблона(имя, шпарамы, констрейнт, деклы);
  }

  Декларация парсируйДекларациюНов()
  {
    пропусти(T.Нов);
    auto parameters = parseParameterList();
    auto телоФунк = разборТелаФункции();
    return new ДекларацияНов(parameters, телоФунк);
  }

  Декларация парсируйДекларациюУдалить()
  {
    пропусти(T.Удалить);
    auto parameters = parseParameterList();
    auto телоФунк = разборТелаФункции();
    return new ДекларацияУдали(parameters, телоФунк);
  }

  Тип parseTypeofType()
  {
    auto начало = сема;
    пропусти(T.Типа);
    auto leftParen = сема;
    требуется(T.ЛСкобка);
    Тип тип;
    switch (сема.вид)
    {
    version(D2)
    {
    case T.Итог:
      далее();
      тип = new ТипТипа();
      break;
    }
    default:
      тип = new ТипТипа(разборВыражения());
    }
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    установи(тип, начало);
    return тип;
  }

  /// Parses a ДекларацияСмеси or ИнструкцияСмесь.
  /// $(PRE
  /// TemplateMixin :=
  ///         mixin ( ВыражениеПрисвой ) ;
  ///         mixin TemplateIdentifier ;
  ///         mixin TemplateIdentifier MixinIdentifier ;
  ///         mixin TemplateIdentifier !( АргументыШаблона ) ;
  ///         mixin TemplateIdentifier !( АргументыШаблона ) MixinIdentifier ;
  /// )
  Класс парсируйМиксин(Класс)()
  {
  static assert(is(Класс == ДекларацияСмеси) || is(Класс == ИнструкцияСмесь));
    пропусти(T.Смесь);

  static if (is(Класс == ДекларацияСмеси))
  {
    if (проверено(T.ЛСкобка))
    {
      auto leftParen = сема;
      auto в = parseAssignExpression();
      требуетсяЗакрыв(T.ПСкобка, leftParen);
      требуется(T.ТочкаЗапятая);
      return new ДекларацияСмеси(в);
    }
  }

    auto начало = сема;
    Выражение в;
    Идентификатор* идентСмеси;

    if (проверено(T.Точка))
      в = установи(new ВыражениеМасштабМодуля(parseIdentifierExpression()), начало);
    else
      в = parseIdentifierExpression();

    while (проверено(T.Точка))
      в = установи(new ВыражениеТочка(в, parseIdentifierExpression()), начало);

    идентСмеси = optionalIdentifier();
    требуется(T.ТочкаЗапятая);

    return new Класс(в, идентСмеси);
  }

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                         Инструкция parsing methods                         |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

  СложнаяИнструкция parseStatements()
  {
    auto начало = сема;
    требуется(T.ЛФСкобка);
    auto инструкции = new СложнаяИнструкция();
    while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
      инструкции ~= parseStatement();
    требуетсяЗакрыв(T.ПФСкобка, начало);
    return установи(инструкции, начало);
  }

  /// Parses a Инструкция.
  Инструкция parseStatement()
  {
    auto начало = сема;
    Инструкция s;
    Декларация d;

    if (сема.интегральныйТип_ли)
    {
      d = парсируйПеременнаяИлиФункция();
      goto LreturnDeclarationStatement;
    }

    switch (сема.вид)
    {
    case T.Расклад:
      бцел размер = parseAlignAttribute();
      // Reтктict align attribute в structs in parsing phase.
      ДекларацияСтруктуры structDecl;
      if (сема.вид == T.Структура)
      {
        auto begin2 = сема;
        structDecl = парсируйДекларациюСтруктурыИлиСоюза().в!(ДекларацияСтруктуры);
        structDecl.установиРазмерРаскладки(размер);
        установи(structDecl, begin2);
      }
      else
        ожидаемое(T.Структура);

      d = new ДекларацияРазложи(размер, structDecl ? cast(Декларация)structDecl : new СложнаяДекларация);
      goto LreturnDeclarationStatement;
      /+ Не applicable for инструкции.
         T.Приватный, T.Пакет, T.Защищённый, T.Публичный, T.Экспорт,
         T.Устаревший, T.Перепись, T.Абстрактный,+/
    case T.Экстерн,
         T.Окончательный,
         T.Конст,
         T.Авто:
         //T.Масштаб
         //T.Статический
    case_parseAttribute:
      s = parseAttributeStatement();
      return s;
    case T.Идентификатор:
      if (возьмиСледщ() == T.Двоеточие)
      {
        auto идент = сема.идент;
        пропусти(T.Идентификатор); пропусти(T.Двоеточие);
        s = new ИнструкцияСМеткой(идент, parseNoScopeOrEmptyStatement());
        break;
      }
      goto case T.Точка;
    case T.Точка, T.Типа:
      бул успех;
      d = пробуй_(delegate {
          return парсируйПеременнаяИлиФункция(КлассХранения.Нет,
                                         Защита.Нет,
                                         ТипКомпоновки.Нет, нет, нет);
        }, успех
      );
      if (успех)
        goto LreturnDeclarationStatement; // Декларация
      else
        goto case_parseExpressionStatement; // Выражение

    case T.Если:
      s = parseЕслиStatement();
      break;
    case T.Пока:
      s = parseWhileStatement();
      break;
    case T.Делай:
      s = parseDoWhileStatement();
      break;
    case T.При:
      s = parseForStatement();
      break;
    case T.Длявсех, T.Длявсех_реверс:
      s = parseForeachStatement();
      break;
    case T.Щит:
      s = parseSwitchStatement();
      break;
    case T.Реле:
      s = parseCaseStatement();
      break;
    case T.Дефолт:
      s = parseDefaultStatement();
      break;
    case T.Далее:
      s = parseContinueStatement();
      break;
    case T.Всё:
      s = parseBreakStatement();
      break;
    case T.Итог:
      s = parseReturnStatement();
      break;
    case T.Переход:
      s = parseGotoStatement();
      break;
    case T.Для:
      s = parseWithStatement();
      break;
    case T.Синхронизованный:
      s = parseSynchronizedStatement();
      break;
    case T.Пробуй:
      s = parseTryStatement();
      break;
    case T.Брось:
      s = parseБросьStatement();
      break;
    case T.Масштаб:
      if (возьмиСледщ() != T.ЛСкобка)
        goto case_parseAttribute;
      s = parseScopeGuardStatement();
      break;
    case T.Volatile:
      s = parseVolatileStatement();
      break;
    case T.Asm:
      s = parseAsmBlockStatement();
      break;
    case T.Прагма:
      s = parsePragmaStatement();
      break;
    case T.Смесь:
      if (возьмиСледщ() == T.ЛСкобка)
        goto case_parseExpressionStatement; // Parse as expression.
      s = парсируйМиксин!(ИнструкцияСмесь)();
      break;
    case T.Статический:
      switch (возьмиСледщ())
      {
      case T.Если:
        s = parseStaticЕслиStatement();
        break;
      case T.Подтвердить:
        s = parseStaticAssertStatement();
        break;
      default:
        goto case_parseAttribute;
      }
      break;
    case T.Отладка:
      s = parseDebugStatement();
      break;
    case T.Версия:
      s = parseVersionStatement();
      break;
    // DeclDef
    case T.Алиас, T.Типдеф:
      d = разборДефиницииДекларации();
      goto LreturnDeclarationStatement;
    case T.Перечень:
    version(D2)
    {
      if (манифестПеречня_ли())
        goto case_parseAttribute;
    }
      d = парсируйДекларациюПеречня();
      goto LreturnDeclarationStatement;
    case T.Класс:
      d = парсируйДекларациюКласса();
      goto LreturnDeclarationStatement;
    case T.Интерфейс:
      d = парсируйДекларациюИнтерфейса();
      goto LreturnDeclarationStatement;
    case T.Структура, T.Союз:
      d = парсируйДекларациюСтруктурыИлиСоюза();
      // goto LreturnDeclarationStatement;
    LreturnDeclarationStatement:
      установи(d, начало);
      s = new ИнструкцияДекларация(d);
      break;
    case T.ЛФСкобка:
      s = parseScopeStatement();
      break;
    case T.ТочкаЗапятая:
      далее();
      s = new ПустаяИнструкция();
      break;
    // Parse an ИнструкцияВыражение:
    // Токены that старт a PrimaryExpression.
    // case T.Идентификатор, T.Точка, T.Типа:
    case T.Этот:
    case T.Супер:
    case T.Нуль:
    case T.Истина, T.Ложь:
    // case T.Доллар:
    case T.Цел32, T.Цел64, T.Бцел32, T.Бцел64:
    case T.Плав32, T.Плав64, T.Плав80,
         T.Мнимое32, T.Мнимое64, T.Мнимое80:
    case T.СимЛитерал:
    case T.Ткст:
    case T.ЛКвСкобка:
    // case T.ЛФСкобка:
    case T.Функция, T.Делегат:
    case T.Подтвердить:
    // case T.Смесь:
    case T.Импорт:
    case T.Идтипа:
    case T.Является:
    case T.ЛСкобка:
    case T.Traits: // D2.0
    // Токены that can старт a УнарноеВыражение:
    case T.ИБинарное, T.ПлюсПлюс, T.МинусМинус, T.Умножь, T.Минус,
         T.Плюс, T.Не, T.Тильда, T.Нов, T.Удалить, T.Каст:
    case_parseExpressionStatement:
      s = new ИнструкцияВыражение(разборВыражения());
      требуется(T.ТочкаЗапятая);
      break;
    default:
      if (сема.спецСема_ли)
        goto case_parseExpressionStatement;

      if (сема.вид != T.Доллар)
        // Подтвердить that this isn't a valid expression.
        assert(delegate бул(){
            бул успех;
            auto expression = пробуй_(&разборВыражения, успех);
            return успех;
          }() == нет, "Didn't expect valid expression."
        );

      // Report ошибка: it's an illegal statement.
      s = new НелегальнаяИнструкция();
      // Skip в следщ valid сема.
      do
        далее();
      while (!сема.началоИнстр_ли &&
              сема.вид != T.ПФСкобка &&
              сема.вид != T.КФ)
      auto текст = Сема.textSpan(начало, this.предыдущСема);
      ошибка(начало, сооб.НелегальнаяИнструкция, текст);
    }
    assert(s !is null);
    установи(s, начало);
    return s;
  }

  /// $(PRE
  /// Parses a ИнструкцияМасштаб.
  /// ИнструкцияМасштаб :=
  ///     NoScopeStatement
  /// )
  Инструкция parseScopeStatement()
  {
    return new ИнструкцияМасштаб(parseNoScopeStatement());
  }

  /// $(PRE
  /// NoScopeStatement :=
  ///     NonEmptyStatement
  ///     BlockStatement
  /// BlockStatement :=
  ///     { }
  ///     { StatementList }
  /// )
  Инструкция parseNoScopeStatement()
  {
    auto начало = сема;
    Инструкция s;
    if (проверено(T.ЛФСкобка))
    {
      auto ss = new СложнаяИнструкция();
      while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
        ss ~= parseStatement();
      требуетсяЗакрыв(T.ПФСкобка, начало);
      s = установи(ss, начало);
    }
    else if (сема.вид == T.ТочкаЗапятая)
    {
      ошибка(сема, сооб.ОжидаласьНеПустаяИнструкция);
      далее();
      s = установи(new ПустаяИнструкция(), начало);
    }
    else
      s = parseStatement();
    return s;
  }

  /// $(PRE
  /// NoScopeOrEmptyStatement :=
  ///     ;
  ///     NoScopeStatement
  /// )
  Инструкция parseNoScopeOrEmptyStatement()
  {
    if (проверено(T.ТочкаЗапятая))
      return установи(new ПустаяИнструкция(), this.предыдущСема);
    else
      return parseNoScopeStatement();
  }

  Инструкция parseAttributeStatement()
  {
    КлассХранения кхр, stc_tmp;
    ТипКомпоновки предш_linkageType;

    Декларация разбор() // Nested function.
    {
      auto начало = сема;
      Декларация декл;
      switch (сема.вид)
      {
      case T.Экстерн:
        if (возьмиСледщ() != T.ЛСкобка)
        {
          stc_tmp = КлассХранения.Экстерн;
          goto Lcommon;
        }

        далее();
        auto типКомпоновки = parseLinkageType();
        checkLinkageType(предш_linkageType, типКомпоновки, начало);

        декл = new ДекларацияКомпоновки(типКомпоновки, разбор());
        break;
      case T.Статический:
        stc_tmp = КлассХранения.Статический;
        goto Lcommon;
      case T.Окончательный:
        stc_tmp = КлассХранения.Окончательный;
        goto Lcommon;
      case T.Конст:
      version(D2)
      {
        if (возьмиСледщ() == T.ЛСкобка)
          goto случай_Декларация;
      }
        stc_tmp = КлассХранения.Конст;
        goto Lcommon;
      version(D2)
      {
      case T.Инвариант: // D 2.0
        if (возьмиСледщ() == T.ЛСкобка)
          goto случай_Декларация;
        stc_tmp = КлассХранения.Инвариант;
        goto Lcommon;
      case T.Перечень: // D 2.0
        if (!манифестПеречня_ли())
        { // A normal enum declaration.
          декл = парсируйДекларациюПеречня();
          // NB: this must be similar в the код at the конец of
          //     разборДефиницииДекларации().
          декл.установиЗащиту(this.защита);
          декл.установиКлассХранения(кхр);
          установи(декл, начало);
          return декл;
        }
        // enum as КлассХранения.
        stc_tmp = КлассХранения.Манифест;
        goto Lcommon;
      }
      case T.Авто:
        stc_tmp = КлассХранения.Авто;
        goto Lcommon;
      case T.Масштаб:
        stc_tmp = КлассХранения.Масштаб;
        goto Lcommon;
      Lcommon:
        // Issue ошибка if redundant.
        if (кхр & stc_tmp)
          ошибка2(ИДС.RedundantStorageClass, сема);
        else
          кхр |= stc_tmp;

        далее();
        декл = new ДекларацияКлассаХранения(stc_tmp, разбор());
        break;
      case T.Класс, T.Интерфейс, T.Структура, T.Союз, T.Алиас, T.Типдеф:
        декл = разборДефиницииДекларации();
        декл.установиЗащиту(Защита.Нет);
        декл.установиКлассХранения(КлассХранения.Нет);
        return декл;
      default:
      случай_Декларация:
        return парсируйПеременнаяИлиФункция(кхр, Защита.Нет, предш_linkageType, да);
      }
      return установи(декл, начало);
    }
    return new ИнструкцияДекларация(разбор());
  }

  Инструкция parseЕслиStatement()
  {
    пропусти(T.Если);

    Инструкция переменная;
    Выражение условие;
    Инструкция телоЕсли, телоИначе;

    auto leftParen = сема;
    требуется(T.ЛСкобка);

    Идентификатор* идент;
    auto начало = сема; // При старт of ДекларацияАвто or normal Декларация.
    // auto Идентификатор = Выражение
    if (проверено(T.Авто))
    {
      идент = требуетсяИдентификатор(сооб.ОжидалосьНазваниеПеременной);
      требуется(T.Присвоить);
      auto иниц = разборВыражения();
      auto v = new ДекларацияПеременных(null, [идент], [иниц]);
      установи(v, начало.следщНепроб);
      auto d = new ДекларацияКлассаХранения(КлассХранения.Авто, v);
      установи(d, начало);
      переменная = new ИнструкцияДекларация(d);
      установи(переменная, начало);
    }
    else
    { // Declarator = Выражение
      Тип parseDeclaratorAssign()
      {
        auto тип = parseDeclarator(идент);
        требуется(T.Присвоить);
        return тип;
      }
      бул успех;
      auto тип = пробуй_(&parseDeclaratorAssign, успех);
      if (успех)
      {
        auto иниц = разборВыражения();
        auto v = new ДекларацияПеременных(тип, [идент], [иниц]);
        установи(v, начало);
        переменная = new ИнструкцияДекларация(v);
        установи(переменная, начало);
      }
      else
        условие = разборВыражения();
    }
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    телоЕсли = parseScopeStatement();
    if (проверено(T.Иначе))
      телоИначе = parseScopeStatement();
    return new ИнструкцияЕсли(переменная, условие, телоЕсли, телоИначе);
  }

  Инструкция parseWhileStatement()
  {
    пропусти(T.Пока);
    auto leftParen = сема;
    требуется(T.ЛСкобка);
    auto условие = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    return new ИнструкцияПока(условие, parseScopeStatement());
  }

  Инструкция parseDoWhileStatement()
  {
    пропусти(T.Делай);
    auto телоДелай = parseScopeStatement();
    требуется(T.Пока);
    auto leftParen = сема;
    требуется(T.ЛСкобка);
    auto условие = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    return new ИнструкцияДелайПока(условие, телоДелай);
  }

  Инструкция parseForStatement()
  {
    пропусти(T.При);

    Инструкция иниц, телоПри;
    Выражение условие, инкремент;

    auto leftParen = сема;
    требуется(T.ЛСкобка);
    if (!проверено(T.ТочкаЗапятая))
      иниц = parseNoScopeStatement();
    if (сема.вид != T.ТочкаЗапятая)
      условие = разборВыражения();
    требуется(T.ТочкаЗапятая);
    if (сема.вид != T.ПСкобка)
      инкремент = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    телоПри = parseScopeStatement();
    return new ИнструкцияПри(иниц, условие, инкремент, телоПри);
  }

  Инструкция parseForeachStatement()
  {
    assert(сема.вид == T.Длявсех || сема.вид == T.Длявсех_реверс);
    TOK лекс = сема.вид;
    далее();

    auto парамы = new Параметры;
    Выражение в; // Агрегат or LwrExpression

    auto leftParen = сема;
    требуется(T.ЛСкобка);
    auto paramsBegin = сема;
    do
    {
      auto paramBegin = сема;
      КлассХранения кхр;
      Тип тип;
      Идентификатор* идент;

      switch (сема.вид)
      {
      case T.Реф, T.Вховых:
        кхр = КлассХранения.Реф;
        далее();
        // fall through
      case T.Идентификатор:
        auto следщ = возьмиСледщ();
        if (следщ == T.Запятая || следщ == T.ТочкаЗапятая || следщ == T.ПСкобка)
        {
          идент = требуетсяИдентификатор(сооб.ОжидалосьНазваниеПеременной);
          break;
        }
        // fall through
      default:
        тип = parseDeclarator(идент);
      }

      парамы ~= установи(new Параметр(кхр, тип, идент, null), paramBegin);
    } while (проверено(T.Запятая))
    установи(парамы, paramsBegin);
    требуется(T.ТочкаЗапятая);
    в = разборВыражения();
  version(D2)
  { //Длявсех (ForeachType; LwrExpression .. UprExpression ) ИнструкцияМасштаб
    if (проверено(T.Срез))
    {
      // if (парамы.length != 1)
        // ошибка(ИДС.XYZ); // TODO: issue ошибка сооб
      auto верхний = разборВыражения();
      требуетсяЗакрыв(T.ПСкобка, leftParen);
      auto телоПри = parseScopeStatement();
      return new ИнструкцияДиапазонСКаждым(лекс, парамы, в, верхний, телоПри);
    }
  }
    // Длявсех (ForeachTypeList; Агрегат) ИнструкцияМасштаб
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    auto телоПри = parseScopeStatement();
    return new ИнструкцияСКаждым(лекс, парамы, в, телоПри);
  }

  Инструкция parseSwitchStatement()
  {
    пропусти(T.Щит);
    auto leftParen = сема;
    требуется(T.ЛСкобка);
    auto условие = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    auto телоЩит = parseScopeStatement();
    return new ИнструкцияЩит(условие, телоЩит);
  }

  /// Helper function for parsing the body of a default or case statement.
  Инструкция parseCaseOrDefaultBody()
  {
    // Этот function is similar в parseNoScopeStatement()
    auto начало = сема;
    auto s = new СложнаяИнструкция();
    while (сема.вид != T.Реле &&
           сема.вид != T.Дефолт &&
           сема.вид != T.ПФСкобка &&
           сема.вид != T.КФ)
      s ~= parseStatement();
    установи(s, начало);
    return установи(new ИнструкцияМасштаб(s), начало);
  }

  Инструкция parseCaseStatement()
  {
    пропусти(T.Реле);
    auto значения = parseExpressionList();
    требуется(T.Двоеточие);
    auto телоРеле = parseCaseOrDefaultBody();
    return new ИнструкцияРеле(значения, телоРеле);
  }

  Инструкция parseDefaultStatement()
  {
    пропусти(T.Дефолт);
    требуется(T.Двоеточие);
    auto телоДефолта = parseCaseOrDefaultBody();
    return new ИнструкцияДефолт(телоДефолта);
  }

  Инструкция parseContinueStatement()
  {
    пропусти(T.Далее);
    auto идент = optionalIdentifier();
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияДалее(идент);
  }

  Инструкция parseBreakStatement()
  {
    пропусти(T.Всё);
    auto идент = optionalIdentifier();
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияВсё(идент);
  }

  Инструкция parseReturnStatement()
  {
    пропусти(T.Итог);
    Выражение выр;
    if (сема.вид != T.ТочкаЗапятая)
      выр = разборВыражения();
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияИтог(выр);
  }

  Инструкция parseGotoStatement()
  {
    пропусти(T.Переход);
    Идентификатор* идент;
    Выражение вырРеле;
    switch (сема.вид)
    {
    case T.Реле:
      идент = сема.идент;
      далее();
      if (сема.вид == T.ТочкаЗапятая)
        break;
      вырРеле = разборВыражения();
      break;
    case T.Дефолт:
      идент = сема.идент;
      далее();
      break;
    default:
      идент = требуетсяИдентификатор(сооб.ОжидалсяИдентификатор);
    }
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияПереход(идент, вырРеле);
  }

  Инструкция parseWithStatement()
  {
    пропусти(T.Для);
    auto leftParen = сема;
    требуется(T.ЛСкобка);
    auto выр = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    return new ИнструкцияДля(выр, parseScopeStatement());
  }

  Инструкция parseSynchronizedStatement()
  {
    пропусти(T.Синхронизованный);
    Выражение выр;
    if (проверено(T.ЛСкобка))
    {
      auto leftParen = this.предыдущСема;
      выр = разборВыражения();
      требуетсяЗакрыв(T.ПСкобка, leftParen);
    }
    return new ИнструкцияСинхр(выр, parseScopeStatement());
  }

  Инструкция parseTryStatement()
  {
    auto начало = сема;
    пропусти(T.Пробуй);

    auto телоПробуй = parseScopeStatement();
    ИнструкцияЛови[] телаЛови;
    ИнструкцияИтожь finBody;

    while (проверено(T.Кэтч))
    {
      Параметр парам;
      if (проверено(T.ЛСкобка))
      {
        auto begin2 = сема;
        Идентификатор* идент;
        auto тип = parseDeclarator(идент, да);
        парам = new Параметр(КлассХранения.Нет, тип, идент, null);
        установи(парам, begin2);
        требуется(T.ПСкобка);
      }
      телаЛови ~= установи(new ИнструкцияЛови(парам, parseNoScopeStatement()), начало);
      if (парам is null)
        break; // Этот is a LastCatch
      начало = сема;
    }

    if (проверено(T.Finally))
      finBody = установи(new ИнструкцияИтожь(parseNoScopeStatement()), предыдущСема);

    if (телаЛови.length == 0 && finBody is null)
      assert(начало.вид == T.Пробуй), ошибка(начало, сооб.НеДостаетCatchИлиFinally);

    return new ИнструкцияПробуй(телоПробуй, телаЛови, finBody);
  }

  Инструкция parseБросьStatement()
  {
    пропусти(T.Брось);
    auto выр = разборВыражения();
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияБрось(выр);
  }

  Инструкция parseScopeGuardStatement()
  {
    пропусти(T.Масштаб);
    пропусти(T.ЛСкобка);
    auto условие = требуетсяИдентификатор(сооб.ОжидалсяИдентификаторМасштаба);
    if (условие)
      switch (условие.видИд)
      {
      case ВИД.выход, ВИД.успех, ВИД.сбой:
        break;
      default:
        ошибка2(сооб.НеверныйИдентификаторМасштаба, this.предыдущСема);
      }
    требуется(T.ПСкобка);
    Инструкция телоМасштаба;
    if (сема.вид == T.ЛФСкобка)
      телоМасштаба = parseScopeStatement();
    else
      телоМасштаба = parseNoScopeStatement();
    return new ИнструкцияСтражМасштаба(условие, телоМасштаба);
  }

  Инструкция parseVolatileStatement()
  {
    пропусти(T.Volatile);
    Инструкция телоЛетучего;
    if (сема.вид == T.ТочкаЗапятая)
      далее();
    else if (сема.вид == T.ЛФСкобка)
      телоЛетучего = parseScopeStatement();
    else
      телоЛетучего = parseStatement();
    return new ИнструкцияЛетучее(телоЛетучего);
  }

  Инструкция parsePragmaStatement()
  {
    пропусти(T.Прагма);

    Идентификатор* идент;
    Выражение[] арги;
    Инструкция телоПрагмы;

    auto leftParen = сема;
    требуется(T.ЛСкобка);
    идент = требуетсяИдентификатор(сооб.ОжидалсяИдентификаторПрагмы);

    if (проверено(T.Запятая))
      арги = parseExpressionList();
    требуетсяЗакрыв(T.ПСкобка, leftParen);

    телоПрагмы = parseNoScopeOrEmptyStatement();

    return new ИнструкцияПрагма(идент, арги, телоПрагмы);
  }

  Инструкция parseStaticЕслиStatement()
  {
    пропусти(T.Статический);
    пропусти(T.Если);
    Выражение условие;
    Инструкция телоЕсли, телоИначе;

    auto leftParen = сема;
    требуется(T.ЛСкобка);
    условие = разборВыражения();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    телоЕсли = parseNoScopeStatement();
    if (проверено(T.Иначе))
      телоИначе = parseNoScopeStatement();
    return new ИнструкцияСтатическоеЕсли(условие, телоЕсли, телоИначе);
  }

  Инструкция parseStaticAssertStatement()
  {
    пропусти(T.Статический);
    пропусти(T.Подтвердить);
    Выражение условие, сообщение;

    требуется(T.ЛСкобка);
    условие = parseAssignExpression(); // Condition.
    if (проверено(T.Запятая))
      сообщение = parseAssignExpression(); // Ошибка сообщение.
    требуется(T.ПСкобка);
    требуется(T.ТочкаЗапятая);
    return new ИнструкцияСтатическоеПодтверди(условие, сообщение);
  }

  Инструкция parseDebugStatement()
  {
    пропусти(T.Отладка);
    Сема* услов;
    Инструкция телоОтладки, телоИначе;

    // ( Condition )
    if (проверено(T.ЛСкобка))
    {
      услов = parseIdentOrЦел();
      требуется(T.ПСкобка);
    }
    // debug Инструкция
    // debug ( Condition ) Инструкция
    телоОтладки = parseNoScopeStatement();
    // else Инструкция
    if (проверено(T.Иначе))
      телоИначе = parseNoScopeStatement();

    return new ИнструкцияОтладка(услов, телоОтладки, телоИначе);
  }

  Инструкция parseVersionStatement()
  {
    пропусти(T.Версия);
    Сема* услов;
    Инструкция телоВерсии, телоИначе;

    // ( Condition )
    требуется(T.ЛСкобка);
    услов = parseVersionCondition();
    требуется(T.ПСкобка);
    // version ( Condition ) Инструкция
    телоВерсии = parseNoScopeStatement();
    // else Инструкция
    if (проверено(T.Иначе))
      телоИначе = parseNoScopeStatement();

    return new ИнструкцияВерсия(услов, телоВерсии, телоИначе);
  }

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                         Assembler parsing methods                         |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

  /// Parses an ИнструкцияБлокАсм.
  Инструкция parseAsmBlockStatement()
  {
    пропусти(T.Asm);
    auto leftBrace = сема;
    требуется(T.ЛФСкобка);
    auto ss = new СложнаяИнструкция;
    while (сема.вид != T.ПФСкобка && сема.вид != T.КФ)
      ss ~= parseAsmStatement();
    требуетсяЗакрыв(T.ПФСкобка, leftBrace);
    return new ИнструкцияБлокАсм(ss);
  }

  Инструкция parseAsmStatement()
  {
    auto начало = сема;
    Инструкция s;
    Идентификатор* идент;
    switch (сема.вид)
    {
    // Keywords that are valid opcodes.
    case T.Вхо, T.Цел, T.Вых:
      идент = сема.идент;
      далее();
      goto LOpcode;
    case T.Идентификатор:
      идент = сема.идент;
      далее();
      if (проверено(T.Двоеточие))
      { // Идентификатор : ИнструкцияАсм
        s = new ИнструкцияСМеткой(идент, parseAsmStatement());
        break;
      }

    LOpcode:
      // Opcode ;
      // Opcode Operands ;
      // Opcode
      //     Идентификатор
      Выражение[] es;
      if (сема.вид != T.ТочкаЗапятая)
        do
          es ~= parseAsmExpression();
        while (проверено(T.Запятая))
      требуется(T.ТочкаЗапятая);
      s = new ИнструкцияАсм(идент, es);
      break;
    case T.Расклад:
      // align Integer;
      далее();
      цел число = -1;
      if (сема.вид == T.Цел32)
        (число = сема.цел_), пропусти(T.Цел32);
      else
        ошибка2(сооб.ExpectedIntegerAfterAlign, сема);
      требуется(T.ТочкаЗапятая);
      s = new ИнструкцияАсмРасклад(число);
      break;
    case T.ТочкаЗапятая:
      s = new ПустаяИнструкция();
      далее();
      break;
    default:
      s = new ИнструкцияНелегальныйАсм();
      // Skip в следщ valid сема.
      do
        далее();
      while (!сема.началоАсмИнстр_ли &&
              сема.вид != T.ПФСкобка &&
              сема.вид != T.КФ)
      auto текст = Сема.textSpan(начало, this.предыдущСема);
      ошибка(начало, сооб.ИнструкцияНелегальныйАсм, текст);
    }
    установи(s, начало);
    return s;
  }

  Выражение parseAsmExpression()
  {
    auto начало = сема;
    auto в = parseAsmOrOrExpression();
    if (проверено(T.Вопрос))
    {
      auto лекс = this.предыдущСема;
      auto iftrue = parseAsmExpression();
      требуется(T.Двоеточие);
      auto iffalse = parseAsmExpression();
      в = new ВыражениеУсловия(в, iftrue, iffalse, лекс);
      установи(в, начало);
    }
    // TODO: create AsmExpression that contains в?
    return в;
  }

  Выражение parseAsmOrOrExpression()
  {
    alias parseAsmAndAndExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (сема.вид == T.ИлиЛогическое)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИлиИли(в, parseNext(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAsmAndAndExpression()
  {
    alias parseAsmOrExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (сема.вид == T.ИЛогическое)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИИ(в, parseNext(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAsmOrExpression()
  {
    alias parseAsmXorExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (сема.вид == T.ИлиБинарное)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИли(в, parseNext(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAsmXorExpression()
  {
    alias parseAsmAndExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (сема.вид == T.ИИли)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИИли(в, parseNext(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAsmAndExpression()
  {
    alias parseAsmCmpExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (сема.вид == T.ИБинарное)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИ(в, parseNext(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAsmCmpExpression()
  {
    alias parseAsmShiftExpression parseNext;
    auto начало = сема;
    auto в = parseNext();

    auto operator = сема;
    switch (operator.вид)
    {
    case T.Равно, T.НеРавно:
      далее();
      в = new ВыражениеРавно(в, parseNext(), operator);
      break;
    case T.МеньшеРавно, T.Меньше, T.БольшеРавно, T.Больше:
      далее();
      в = new ВыражениеОтнош(в, parseNext(), operator);
      break;
    default:
      return в;
    }
    установи(в, начало);
    return в;
  }

  Выражение parseAsmShiftExpression()
  {
    alias parseAsmAddExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (1)
    {
      auto operator = сема;
      switch (operator.вид)
      {
      case T.ЛСдвиг:  далее(); в = new ВыражениеЛСдвиг(в, parseNext(), operator); break;
      case T.ПСдвиг:  далее(); в = new ВыражениеПСдвиг(в, parseNext(), operator); break;
      case T.URShift: далее(); в = new ВыражениеБПСдвиг(в, parseNext(), operator); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение parseAsmAddExpression()
  {
    alias parseAsmMulExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (1)
    {
      auto operator = сема;
      switch (operator.вид)
      {
      case T.Плюс:  далее(); в = new ВыражениеПлюс(в, parseNext(), operator); break;
      case T.Минус: далее(); в = new ВыражениеМинус(в, parseNext(), operator); break;
      // Не allowed in asm
      //case T.Тильда: далее(); в = new ВыражениеСоедини(в, parseNext(), operator); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение parseAsmMulExpression()
  {
    alias parseAsmPostExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (1)
    {
      auto operator = сема;
      switch (operator.вид)
      {
      case T.Умножь: далее(); в = new ВыражениеУмножь(в, parseNext(), operator); break;
      case T.Деление: далее(); в = new ВыражениеДели(в, parseNext(), operator); break;
      case T.Модуль: далее(); в = new ВыражениеМод(в, parseNext(), operator); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение parseAsmPostExpression()
  {
    auto начало = сема;
    auto в = parseAsmUnaryExpression();
    while (проверено(T.ЛКвСкобка))
    {
      auto leftBracket = this.предыдущСема;
      в = new ВыражениеАсмПослеСкобки(в, parseAsmExpression());
      требуетсяЗакрыв(T.ПКвСкобка, leftBracket);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAsmUnaryExpression()
  {
    auto начало = сема;
    Выражение в;
    switch (сема.вид)
    {
    case T.Байт,  T.Крат,  T.Цел,
         T.Плав, T.Дво, T.Реал:
      goto LAsmTypePrefix;
    case T.Идентификатор:
      switch (сема.идент.видИд)
      {
      case ВИД.near, ВИД.far,/* "байт",  "крат",  "цел",*/
           ВИД.word, ВИД.dword, ВИД.qword/*, "плав", "дво", "реал"*/:
      LAsmTypePrefix:
        далее();
        if (сема.вид == T.Идентификатор && сема.идент is Идент.ptr)
          пропусти(T.Идентификатор);
        else
          ошибка2(ИДС.ExpectedButFound, "ptr", сема);
        в = new ВыражениеТипАсм(parseAsmExpression());
        break;
      case ВИД.offset:
        далее();
        в = new ВыражениеСмещениеАсм(parseAsmExpression());
        break;
      case ВИД.seg:
        далее();
        в = new ВыражениеСегАсм(parseAsmExpression());
        break;
      default:
        goto LparseAsmPrimaryExpression;
      }
      break;
    case T.Минус:
    case T.Плюс:
      далее();
      в = new ВыражениеЗнак(parseAsmUnaryExpression());
      break;
    case T.Не:
      далее();
      в = new ВыражениеНе(parseAsmUnaryExpression());
      break;
    case T.Тильда:
      далее();
      в = new ВыражениеКомп(parseAsmUnaryExpression());
      break;
    case T.Точка:
      далее();
      в = new ВыражениеМасштабМодуля(parseIdentifierExpression());
      while (проверено(TOK.Точка))
      {
        в = new ВыражениеТочка(в, parseIdentifierExpression());
        установи(в, начало);
      }
      break;
    default:
    LparseAsmPrimaryExpression:
      в = parseAsmPrimaryExpression();
      return в;
    }
    установи(в, начало);
    return в;
  }

  Выражение parseAsmPrimaryExpression()
  {
    auto начало = сема;
    Выражение в;
    switch (сема.вид)
    {
    case T.Цел32, T.Цел64, T.Бцел32, T.Бцел64:
      в = new ЦелВыражение(сема);
      далее();
      break;
    case T.Плав32, T.Плав64, T.Плав80,
         T.Мнимое32, T.Мнимое64, T.Мнимое80:
      в = new ВыражениеРеал(сема);
      далее();
      break;
    case T.Доллар:
      в = new ВыражениеДоллар();
      далее();
      break;
    case T.ЛКвСкобка:
      // [ AsmExpression ]
      auto leftBracket = сема;
      далее();
      в = parseAsmExpression();
      требуетсяЗакрыв(T.ПКвСкобка, leftBracket);
      в = new ВыражениеАсмСкобка(в);
      break;
    case T.Идентификатор:
      auto register = сема.идент;
      switch (register.видИд)
      {
      // __LOCAL_SIZE
      case ВИД.__LOCAL_SIZE:
        далее();
        в = new ВыражениеЛокальногоРазмераАсм();
        break;
      // Register
      case ВИД.ST:
        далее();
        // (1) - (7)
        цел число = -1;
        if (проверено(T.ЛСкобка))
        {
          if (сема.вид == T.Цел32)
            (число = сема.цел_), пропусти(T.Цел32);
          else
            ожидаемое(T.Цел32);
          требуется(T.ПСкобка);
        }
        в = new ВыражениеАсмРегистр(register, число);
        break;
      case ВИД.FS:
        далее();
        // TODO: is the colon-число part optional?
        цел число = -1;
        if (проверено(T.Двоеточие))
        {
          // :0, :4, :8
          if (сема.вид == T.Цел32)
            (число = сема.цел_), пропусти(T.Цел32);
          if (число != 0 && число != 4 && число != 8)
            ошибка2(ИДС.ExpectedButFound, "0, 4 or 8", сема);
        }
        в = new ВыражениеАсмРегистр(register, число);
        break;
      case ВИД.AL, ВИД.AH, ВИД.AX, ВИД.EAX,
           ВИД.BL, ВИД.BH, ВИД.BX, ВИД.EBX,
           ВИД.CL, ВИД.CH, ВИД.CX, ВИД.ECX,
           ВИД.DL, ВИД.DH, ВИД.DX, ВИД.EDX,
           ВИД.BP, ВИД.EBP, ВИД.SP, ВИД.ESP,
           ВИД.DI, ВИД.EDI, ВИД.SI, ВИД.ESI,
           ВИД.ES, ВИД.CS, ВИД.SS, ВИД.DS, ВИД.GS,
           ВИД.CR0, ВИД.CR2, ВИД.CR3, ВИД.CR4,
           ВИД.DR0, ВИД.DR1, ВИД.DR2, ВИД.DR3, ВИД.DR6, ВИД.DR7,
           ВИД.TR3, ВИД.TR4, ВИД.TR5, ВИД.TR6, ВИД.TR7,
           ВИД.MM0, ВИД.MM1, ВИД.MM2, ВИД.MM3,
           ВИД.MM4, ВИД.MM5, ВИД.MM6, ВИД.MM7,
           ВИД.XMM0, ВИД.XMM1, ВИД.XMM2, ВИД.XMM3,
           ВИД.XMM4, ВИД.XMM5, ВИД.XMM6, ВИД.XMM7:
        далее();
        в = new ВыражениеАсмРегистр(register);
        break;
      default:
        в = parseIdentifierExpression();
        while (проверено(TOK.Точка))
        {
          в = new ВыражениеТочка(в, parseIdentifierExpression());
          установи(в, начало);
        }
      } // конец of switch
      break;
    default:
      ошибка2(ИДС.ExpectedButFound, "Выражение", сема);
      в = new НелегальноеВыражение();
      if (!пробуем)
      { // Insert a dummy сема and don't consume current one.
        начало = лексер.insertEmptyTokenBefore(сема);
        this.предыдущСема = начало;
      }
    }
    установи(в, начало);
    return в;
  }

  /+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  |                        Выражение parsing methods                         |
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+/

  /// Parses an Выражение.
  Выражение разборВыражения()
  {
    alias parseAssignExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (сема.вид == T.Запятая)
    {
      auto comma = сема;
      далее();
      в = new ВыражениеЗапятая(в, parseNext(), comma);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAssignExpression()
  {
    alias parseAssignExpression parseNext;
    auto начало = сема;
    auto в = parseCondExpression();
    switch (сема.вид)
    {
    case T.Присвоить:
      далее(); в = new ВыражениеПрисвой(в, parseNext()); break;
    case T.ЛСдвигПрисвой:
      далее(); в = new ВыражениеПрисвойЛСдвиг(в, parseNext()); break;
    case T.ПСдвигПрисвой:
      далее(); в = new ВыражениеПрисвойПСдвиг(в, parseNext()); break;
    case T.URShiftAssign:
      далее(); в = new ВыражениеПрисвойБПСдвиг(в, parseNext()); break;
    case T.ИлиПрисвой:
      далее(); в = new ВыражениеПрисвойИли(в, parseNext()); break;
    case T.ИПрисвой:
      далее(); в = new ВыражениеПрисвойИ(в, parseNext()); break;
    case T.ПлюсПрисвой:
      далее(); в = new ВыражениеПрисвойПлюс(в, parseNext()); break;
    case T.МинусПрисвой:
      далее(); в = new ВыражениеПрисвойМинус(в, parseNext()); break;
    case T.ДелениеПрисвой:
      далее(); в = new ВыражениеПрисвойДел(в, parseNext()); break;
    case T.УмножьПрисвой:
      далее(); в = new ВыражениеПрисвойУмн(в, parseNext()); break;
    case T.МодульПрисвой:
      далее(); в = new ВыражениеПрисвойМод(в, parseNext()); break;
    case T.ИИлиПрисвой:
      далее(); в = new ВыражениеПрисвойИИли(в, parseNext()); break;
    case T.CatAssign:
      далее(); в = new ВыражениеПрисвойСоед(в, parseNext()); break;
    default:
      return в;
    }
    установи(в, начало);
    return в;
  }

  Выражение parseCondExpression()
  {
    auto начало = сема;
    auto в = parseOrOrExpression();
    if (сема.вид == T.Вопрос)
    {
      auto лекс = сема;
      далее();
      auto iftrue = разборВыражения();
      требуется(T.Двоеточие);
      auto iffalse = parseCondExpression();
      в = new ВыражениеУсловия(в, iftrue, iffalse, лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseOrOrExpression()
  {
    alias parseAndAndExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (сема.вид == T.ИлиЛогическое)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИлиИли(в, parseNext(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAndAndExpression()
  {
    alias parseOrExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (сема.вид == T.ИЛогическое)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИИ(в, parseNext(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseOrExpression()
  {
    alias parseXorExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (сема.вид == T.ИлиБинарное)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИли(в, parseNext(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseXorExpression()
  {
    alias parseAndExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (сема.вид == T.ИИли)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИИли(в, parseNext(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseAndExpression()
  {
    alias parseCmpExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (сема.вид == T.ИБинарное)
    {
      auto лекс = сема;
      далее();
      в = new ВыражениеИ(в, parseNext(), лекс);
      установи(в, начало);
    }
    return в;
  }

  Выражение parseCmpExpression()
  {
    alias parseShiftExpression parseNext;
    auto начало = сема;
    auto в = parseShiftExpression();

    auto operator = сема;
    switch (operator.вид)
    {
    case T.Равно, T.НеРавно:
      далее();
      в = new ВыражениеРавно(в, parseNext(), operator);
      break;
    case T.Не:
      if (возьмиСледщ() != T.Является)
        break;
      далее();
      // fall through
    case T.Является:
      далее();
      в = new ВыражениеРавенство(в, parseNext(), operator);
      break;
    case T.МеньшеРавно, T.Меньше, T.БольшеРавно, T.Больше,
         T.Unordered, T.UorE, T.UorG, T.UorGorE,
         T.UorL, T.UorLorE, T.LorEorG, T.LorG:
      далее();
      в = new ВыражениеОтнош(в, parseNext(), operator);
      break;
    case T.Вхо:
      далее();
      в = new ВыражениеВхо(в, parseNext(), operator);
      break;
    default:
      return в;
    }
    установи(в, начало);
    return в;
  }

  Выражение parseShiftExpression()
  {
    alias parseAddExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (1)
    {
      auto operator = сема;
      switch (operator.вид)
      {
      case T.ЛСдвиг:  далее(); в = new ВыражениеЛСдвиг(в, parseNext(), operator); break;
      case T.ПСдвиг:  далее(); в = new ВыражениеПСдвиг(в, parseNext(), operator); break;
      case T.URShift: далее(); в = new ВыражениеБПСдвиг(в, parseNext(), operator); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение parseAddExpression()
  {
    alias parseMulExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (1)
    {
      auto operator = сема;
      switch (operator.вид)
      {
      case T.Плюс:  далее(); в = new ВыражениеПлюс(в, parseNext(), operator); break;
      case T.Минус: далее(); в = new ВыражениеМинус(в, parseNext(), operator); break;
      case T.Тильда: далее(); в = new ВыражениеСоедини(в, parseNext(), operator); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение parseMulExpression()
  {
    alias parsePostExpression parseNext;
    auto начало = сема;
    auto в = parseNext();
    while (1)
    {
      auto operator = сема;
      switch (operator.вид)
      {
      case T.Умножь: далее(); в = new ВыражениеУмножь(в, parseNext(), operator); break;
      case T.Деление: далее(); в = new ВыражениеДели(в, parseNext(), operator); break;
      case T.Модуль: далее(); в = new ВыражениеМод(в, parseNext(), operator); break;
      default:
        return в;
      }
      установи(в, начало);
    }
    assert(0);
  }

  Выражение parsePostExpression()
  {
    auto начало = сема;
    auto в = parseUnaryExpression();
    while (1)
    {
      while (проверено(T.Точка))
      {
        в = new ВыражениеТочка(в, parseNewOrIdentifierExpression());
        установи(в, начало);
      }

      switch (сема.вид)
      {
      case T.ПлюсПлюс:
        в = new ВыражениеПостИнкр(в);
        break;
      case T.МинусМинус:
        в = new ВыражениеПостДекр(в);
        break;
      case T.ЛСкобка:
        в = new ВыражениеВызов(в, parseArguments());
        goto Lset;
      case T.ЛКвСкобка:
        // разбор Срез- and ВыражениеИндекс
        auto leftBracket = сема;
        далее();
        // [] is a ВыражениеСрез
        if (сема.вид == T.ПКвСкобка)
        {
          в = new ВыражениеСрез(в, null, null);
          break;
        }

        Выражение[] es = [parseAssignExpression()];

        // [ ВыражениеПрисвой .. ВыражениеПрисвой ]
        if (проверено(T.Срез))
        {
          в = new ВыражениеСрез(в, es[0], parseAssignExpression());
          требуетсяЗакрыв(T.ПКвСкобка, leftBracket);
          goto Lset;
        }

        // [ ExpressionList ]
        if (проверено(T.Запятая))
           es ~= parseExpressionList();
        требуетсяЗакрыв(T.ПКвСкобка, leftBracket);

        в = new ВыражениеИндекс(в, es);
        goto Lset;
      default:
        return в;
      }
      далее();
    Lset: // Jumped here в пропусти далее().
      установи(в, начало);
    }
    assert(0);
  }

  Выражение parseUnaryExpression()
  {
    auto начало = сема;
    Выражение в;
    switch (сема.вид)
    {
    case T.ИБинарное:
      далее();
      в = new ВыражениеАдрес(parseUnaryExpression());
      break;
    case T.ПлюсПлюс:
      далее();
      в = new ВыражениеПреИнкр(parseUnaryExpression());
      break;
    case T.МинусМинус:
      далее();
      в = new ВыражениеПреДекр(parseUnaryExpression());
      break;
    case T.Умножь:
      далее();
      в = new ВыражениеДереф(parseUnaryExpression());
      break;
    case T.Минус:
    case T.Плюс:
      далее();
      в = new ВыражениеЗнак(parseUnaryExpression());
      break;
    case T.Не:
      далее();
      в = new ВыражениеНе(parseUnaryExpression());
      break;
    case T.Тильда:
      далее();
      в = new ВыражениеКомп(parseUnaryExpression());
      break;
    case T.Нов:
      в = parseNewExpression();
      return в;
    case T.Удалить:
      далее();
      в = new ВыражениеУдали(parseUnaryExpression());
      break;
    case T.Каст:
      requireNext(T.ЛСкобка);
      Тип тип;
      switch (сема.вид)
      {
      version(D2)
      {
      auto begin2 = сема;
      case T.Конст:
        тип = new ТипКонст(null);
        goto case_break;
      case T.Инвариант:
        тип = new ТипИнвариант(null);
      case_break:
        далее();
        установи(тип, begin2);
        break;
      }
      default:
       тип = разборТипа();
      }
      требуется(T.ПСкобка);
      в = new ВыражениеКаст(parseUnaryExpression(), тип);
      break;
    case T.ЛСкобка:
      // ( Тип ) . Идентификатор
      Тип parseType_()
      {
        пропусти(T.ЛСкобка);
        auto тип = разборТипа();
        требуется(T.ПСкобка);
        требуется(T.Точка);
        return тип;
      }
      бул успех;
      auto тип = пробуй_(&parseType_, успех);
      if (успех)
      {
        auto идент = требуетсяИдентификатор(сооб.ExpectedIdAfterTypeDot);
        в = new ВыражениеИдТипаТочка(тип, идент);
        break;
      }
      goto default;
    case T.Точка:
      далее();
      в = new ВыражениеМасштабМодуля(parseIdentifierExpression());
      break;
    default:
      в = parsePrimaryExpression();
      return в;
    }
    assert(в !is null);
    установи(в, начало);
    return в;
  }

  /// $(PRE
  /// ВыражениеИдентификатор :=
  ///         Идентификатор
  ///         TemplateInstance
  /// TemplateInstance :=
  ///         Идентификатор !( АргументыШаблона )
  /// )
  Выражение parseIdentifierExpression()
  {
    auto начало = сема;
    auto идент = требуетсяИдентификатор(сооб.ОжидалсяИдентификатор);
    Выражение в;
    // Peek for '(' в avoid matching: ид !is ид
    if (сема.вид == T.Не && возьмиСледщ() == T.ЛСкобка)
    { // Идентификатор !( АргументыШаблона )
      пропусти(T.Не);
      auto шпарамы = parseTemplateArguments();
      в = new ВыражениеЭкземплярШаблона(идент, шпарамы);
    }
    else // Идентификатор
      в = new ВыражениеИдентификатор(идент);
    return установи(в, начало);
  }

  Выражение parseNewOrIdentifierExpression()
  {
    return сема.вид == T.Нов ? parseNewExpression() :  parseIdentifierExpression();
  }

  Выражение parsePrimaryExpression()
  {
    auto начало = сема;
    Выражение в;
    switch (сема.вид)
    {
    case T.Идентификатор:
      в = parseIdentifierExpression();
      return в;
    case T.Типа:
      в = new ВыражениеТипа(parseTypeofType());
      break;
    case T.Этот:
      далее();
      в = new ВыражениеЭтот();
      break;
    case T.Супер:
      далее();
      в = new ВыражениеСупер();
      break;
    case T.Нуль:
      далее();
      в = new ВыражениеНуль();
      break;
    case T.Истина, T.Ложь:
      далее();
      в = new БулевоВыражение(сема.вид == T.Истина);
      break;
    case T.Доллар:
      далее();
      в = new ВыражениеДоллар();
      break;
    case T.Цел32, T.Цел64, T.Бцел32, T.Бцел64:
      в = new ЦелВыражение(сема);
      далее();
      break;
    case T.Плав32, T.Плав64, T.Плав80,
         T.Мнимое32, T.Мнимое64, T.Мнимое80:
      в = new ВыражениеРеал(сема);
      далее();
      break;
    case T.СимЛитерал:
      в = new ВыражениеСим(сема.дим_);
      далее();
      break;
    case T.Ткст:
      сим[] ткт = сема.ткт;
      сим postfix = сема.pf;
      далее();
      while (сема.вид == T.Ткст)
      {
        /+if (postfix == 0)
            postfix = сема.pf;
        else+/
        if (сема.pf && сема.pf != postfix)
          ошибка(сема, сооб.StringPostfixMismatch);
        ткт.length = ткт.length - 1; // Exclude '\0'.
        ткт ~= сема.ткт;
        далее();
      }
      switch (postfix)
      {
      case 'w':
        if (hasInvalidUTF8(ткт, начало))
          goto default;
        в = new ТекстовоеВыражение(drc.Unicode.вЮ16(ткт)); break;
      case 'd':
        if (hasInvalidUTF8(ткт, начало))
          goto default;
        в = new ТекстовоеВыражение(drc.Unicode.вЮ32(ткт)); break;
      case 'c':
      default:
        // No checking done в allow for binary данные.
        в = new ТекстовоеВыражение(ткт); break;
      }
      break;
    case T.ЛКвСкобка:
      Выражение[] значения;

      далее();
      if (!проверено(T.ПКвСкобка))
      {
        в = parseAssignExpression();
        if (проверено(T.Двоеточие))
          goto LparseAssocArray;
        if (проверено(T.Запятая))
          значения = [в] ~ parseExpressionList();
        требуетсяЗакрыв(T.ПКвСкобка, начало);
      }

      в = new ВыражениеЛитералМассива(значения);
      break;

    LparseAssocArray:
      Выражение[] ключи = [в];

      goto LenterLoop;
      do
      {
        ключи ~= parseAssignExpression();
        требуется(T.Двоеточие);
      LenterLoop:
        значения ~= parseAssignExpression();
      } while (проверено(T.Запятая))
      требуетсяЗакрыв(T.ПКвСкобка, начало);
      в = new ВыражениеЛитералАМассива(ключи, значения);
      break;
    case T.ЛФСкобка:
      // DelegateLiteral := { Statements }
      auto телоФунк = разборТелаФункции();
      в = new ВыражениеЛитералФункции(телоФунк);
      break;
    case T.Функция, T.Делегат:
      // FunctionLiteral := ("function"|"delegate") Тип? "(" ArgumentList ")" FunctionBody
      далее(); // Skip function or delegate keyword.
      Тип типВозврата;
      Параметры parameters;
      if (сема.вид != T.ЛФСкобка)
      {
        if (сема.вид != T.ЛСкобка) // Optional return тип
          типВозврата = разборТипа();
        parameters = parseParameterList();
      }
      auto телоФунк = разборТелаФункции();
      в = new ВыражениеЛитералФункции(типВозврата, parameters, телоФунк);
      break;
    case T.Подтвердить:
      Выражение сооб;
      requireNext(T.ЛСкобка);
      в = parseAssignExpression();
      if (проверено(T.Запятая))
        сооб = parseAssignExpression();
      требуется(T.ПСкобка);
      в = new ВыражениеПодтверди(в, сооб);
      break;
    case T.Смесь:
      requireNext(T.ЛСкобка);
      в = parseAssignExpression();
      требуется(T.ПСкобка);
      в = new ВыражениеСмесь(в);
      break;
    case T.Импорт:
      requireNext(T.ЛСкобка);
      в = parseAssignExpression();
      требуется(T.ПСкобка);
      в = new ВыражениеИмпорта(в);
      break;
    case T.Идтипа:
      requireNext(T.ЛСкобка);
      auto тип = разборТипа();
      требуется(T.ПСкобка);
      в = new ВыражениеИдТипа(тип);
      break;
    case T.Является:
      далее();
      auto leftParen = сема;
      требуется(T.ЛСкобка);

      Тип тип, типСпец;
      Идентификатор* идент; // optional Идентификатор
      Сема* opTok, specTok;

      тип = parseDeclarator(идент, да);

      switch (сема.вид)
      {
      case T.Двоеточие, T.Равно:
        opTok = сема;
        далее();
        switch (сема.вид)
        {
        case T.Типдеф,
             T.Структура,
             T.Союз,
             T.Класс,
             T.Интерфейс,
             T.Перечень,
             T.Функция,
             T.Делегат,
             T.Супер,
             T.Итог:
        case_Const_Invariant:
          specTok = сема;
          далее();
          break;
        case T.Конст, T.Инвариант:
          if (возьмиСледщ() != T.ЛСкобка)
            goto case_Const_Invariant;
          // Fall through. It's a тип.
        default:
          типСпец = разборТипа();
        }
      default:
      }

      ПараметрыШаблона шпарамы;
    version(D2)
    {
      // is ( Тип Идентификатор : TypeSpecialization , TemplateParameterList )
      // is ( Тип Идентификатор == TypeSpecialization , TemplateParameterList )
      if (идент && типСпец && сема.вид == T.Запятая)
        шпарамы = parseTemplateParameterList2();
    }
      требуетсяЗакрыв(T.ПСкобка, leftParen);
      в = new ВыражениеЯвляется(тип, идент, opTok, specTok, типСпец, шпарамы);
      break;
    case T.ЛСкобка:
      if (tokenAfterParenIs(T.ЛФСкобка)) // Check for "(...) {"
      { // ( ParameterList ) FunctionBody
        auto parameters = parseParameterList();
        auto телоФунк = разборТелаФункции();
        в = new ВыражениеЛитералФункции(null, parameters, телоФунк);
      }
      else
      { // ( Выражение )
        auto leftParen = сема;
        пропусти(T.ЛСкобка);
        в = разборВыражения();
        требуетсяЗакрыв(T.ПСкобка, leftParen);
        в = new ВыражениеРодит(в);
      }
      break;
    version(D2)
    {
    case T.Traits:
      requireNext(T.ЛСкобка);
      auto ид = требуетсяИдентификатор(сооб.ОжидалсяИдентификатор);
      АргументыШаблона арги;
      if (сема.вид == T.Запятая)
        арги = parseTemplateArguments2();
      else
        требуется(T.ПСкобка);
      в = new ВыражениеТрактовки(ид, арги);
      break;
    }
    default:
      if (сема.интегральныйТип_ли)
      { // ИнтегральныйТип . Идентификатор
        auto тип = new ИнтегральныйТип(сема.вид);
        далее();
        установи(тип, начало);
        требуется(T.Точка);
        auto идент = требуетсяИдентификатор(сооб.ExpectedIdAfterTypeDot);
        в = new ВыражениеИдТипаТочка(тип, идент);
      }
      else if (сема.спецСема_ли)
      {
        в = new ВыражениеСпецСема(сема);
        далее();
      }
      else
      {
        ошибка2(ИДС.ExpectedButFound, "Выражение", сема);
        в = new НелегальноеВыражение();
        if (!пробуем)
        { // Insert a dummy сема and don't consume current one.
          начало = лексер.insertEmptyTokenBefore(сема);
          this.предыдущСема = начало;
        }
      }
    }
    установи(в, начало);
    return в;
  }

  Выражение parseNewExpression(/*Выражение в*/)
  {
    auto начало = сема;
    пропусти(T.Нов);

    Выражение[] newArguments;
    Выражение[] ctorArguments;

    if (сема.вид == T.ЛСкобка)
      newArguments = parseArguments();

    // ВыражениеНовАнонКласс:
    //         new (ArgumentList)opt class (ArgumentList)opt SuperClassopt ЦелerfaceClassesopt ClassBody
    if (проверено(T.Класс))
    {
      if (сема.вид == T.ЛСкобка)
        ctorArguments = parseArguments();

      ТипКлассОснова[] основы = сема.вид != T.ЛФСкобка ? parseBaseClasses(нет) : null ;

      auto деклы = разборТелаДефиницииДекларации();
      return установи(new ВыражениеНовАнонКласс(/*в, */newArguments, основы, ctorArguments, деклы), начало);
    }

    // ВыражениеНов:
    //         NewArguments Тип [ ВыражениеПрисвой ]
    //         NewArguments Тип ( ArgumentList )
    //         NewArguments Тип
    auto тип = разборТипа();

    if (сема.вид == T.ЛСкобка)
      ctorArguments = parseArguments();

    return установи(new ВыражениеНов(/*в, */newArguments, тип, ctorArguments), начало);
  }

  /// Parses a Тип.
  Тип разборТипа()
  {
    return parseBasicType2(parseBasicType());
  }

  Тип parseIdentifierType()
  {
    auto начало = сема;
    auto идент = требуетсяИдентификатор(сооб.ОжидалсяИдентификатор);
    Тип t;
    if (проверено(T.Не)) // Идентификатор !( АргументыШаблона )
      t = new ТипЭкземплярШаблона(идент, parseTemplateArguments());
    else // Идентификатор
      t = new ТипИдентификатор(идент);
    return установи(t, начало);
  }

  Тип parseQualifiedType()
  {
    auto начало = сема;
    Тип тип;
    if (сема.вид == T.Точка)
      тип = установи(new ТипМасштабаМодуля(), начало, начало);
    else if (сема.вид == T.Типа)
      тип = parseTypeofType();
    else
      тип = parseIdentifierType();

    while (проверено(T.Точка))
      тип = установи(new КвалифицированныйТип(тип, parseIdentifierType()), начало);
    return тип;
  }

  Тип parseBasicType()
  {
    auto начало = сема;
    Тип t;

    if (сема.интегральныйТип_ли)
    {
      t = new ИнтегральныйТип(сема.вид);
      далее();
    }
    else
    switch (сема.вид)
    {
    case T.Идентификатор, T.Типа, T.Точка:
      t = parseQualifiedType();
      return t;
    version(D2)
    {
    case T.Конст:
      // const ( Тип )
      requireNext(T.ЛСкобка);
      t = разборТипа();
      требуется(T.ПСкобка);
      t = new ТипКонст(t);
      break;
    case T.Инвариант:
      // invariant ( Тип )
      requireNext(T.ЛСкобка);
      t = разборТипа();
      требуется(T.ПСкобка);
      t = new ТипИнвариант(t);
      break;
    } // version(D2)
    default:
      ошибка2(ИДС.ExpectedButFound, "BasicType", сема);
      t = new НелегальныйТип();
      далее();
    }
    return установи(t, начало);
  }

  Тип parseBasicType2(Тип t)
  {
    while (1)
    {
      auto начало = сема;
      switch (сема.вид)
      {
      case T.Умножь:
        t = new ТипУказатель(t);
        далее();
        break;
      case T.ЛКвСкобка:
        t = parseArrayType(t);
        continue;
      case T.Функция, T.Делегат:
        TOK лекс = сема.вид;
        далее();
        auto parameters = parseParameterList();
        if (лекс == T.Функция)
          t = new ТипФункция(t, parameters);
        else
          t = new ТипДелегат(t, parameters);
        break;
      default:
        return t;
      }
      установи(t, начало);
    }
    assert(0);
  }

  /// Returns да if the сема after the закрывающий parenthesis
  /// matches the searched вид.
  бул tokenAfterParenIs(TOK вид)
  {
    assert(сема.вид == T.ЛСкобка);
    auto следщ = сема;
    return пропустиParens(следщ) == вид;
  }

  /// определено
  бул tokenAfterParenIs(TOK вид, ref Сема* следщ)
  {
    assert(следщ !is null && следщ.вид == T.ЛСкобка);
    return пропустиParens(следщ) == вид;
  }

  /// Skips в the сема behind the закрывающий parenthesis.
  /// Takes nested parentheses into account.
  TOK пропустиParens(ref Сема* следщ)
  {
    assert(следщ !is null && следщ.вид == T.ЛСкобка);
    // We счёт nested parentheses семы because template types, typeof etc.
    // may appear внутри parameter lists. E.g.: (цел x, Foo!(цел) y)
    бцел уровень = 1;
  Loop:
    while (1)
      switch (возьмиПосле(следщ))
      {
      case T.ЛСкобка:
        ++уровень;
        break;
      case T.ПСкобка:
        if (--уровень == 0)
          return возьмиПосле(следщ); // Closing parenthesis found.
        break;
      case T.КФ:
        return T.КФ;
      default:
      }
    assert(0, "should be unreachable");
  }

  /// Parse the массив types after the declarator (C-style.) E.g.: цел a[]
  Тип parseDeclaratorSuffix(Тип lhsType)
  {
    // The Тип chain should be as follows:
    // цел[3]* Идентификатор [][32]
    //   <- <-             ->  -.
    //       ^-----------------´
    // Итогing chain: [][32]*[3]цел
    Тип parseNext() // Nested function required в accomplish this.
    {
      if (сема.вид != T.ЛКвСкобка)
        return lhsType; // Всё recursion; return Тип on the левый hand сторона of the Идентификатор.

      auto начало = сема;
      Тип t;
      пропусти(T.ЛКвСкобка);
      if (проверено(T.ПКвСкобка))
        t = new ТипМассив(parseNext()); // [ ]
      else
      {
        бул успех;
        Тип parseAAType()
        {
          auto тип = разборТипа();
          требуется(T.ПКвСкобка);
          return тип;
        }
        auto ассоцТип = пробуй_(&parseAAType, успех);
        if (успех)
          t = new ТипМассив(parseNext(), ассоцТип); // [ Тип ]
        else
        {
          Выражение в = разборВыражения(), e2;
          if (проверено(T.Срез))
            e2 = разборВыражения();
          требуетсяЗакрыв(T.ПКвСкобка, начало);
          t = new ТипМассив(parseNext(), в, e2); // [ Выражение .. Выражение ]
        }
      }
      установи(t, начало);
      return t;
    }
    return parseNext();
  }

  Тип parseArrayType(Тип t)
  {
    auto начало = сема;
    пропусти(T.ЛКвСкобка);
    if (проверено(T.ПКвСкобка))
      t = new ТипМассив(t);
    else
    {
      бул успех;
      Тип parseAAType()
      {
        auto тип = разборТипа();
        требуется(T.ПКвСкобка);
        return тип;
      }
      auto ассоцТип = пробуй_(&parseAAType, успех);
      if (успех)
        t = new ТипМассив(t, ассоцТип);
      else
      {
        Выражение в = разборВыражения(), e2;
        if (проверено(T.Срез))
          e2 = разборВыражения();
        требуетсяЗакрыв(T.ПКвСкобка, начало);
        t = new ТипМассив(t, в, e2);
      }
    }
    установи(t, начало);
    return t;
  }

  Тип parseCFunctionPointerType(Тип тип, ref Идентификатор* идент, бул optionalParamList)
  {
    assert(тип !is null);
    auto начало = сема;
    пропусти(T.ЛСкобка);

    тип = parseBasicType2(тип);
    if (сема.вид == T.ЛСкобка)
    { // Can be nested.
      тип = parseCFunctionPointerType(тип, идент, да);
    }
    else if (сема.вид == T.Идентификатор)
    { // The identifier of the function pointer and the declaration.
      идент = сема.идент;
      далее();
      тип = parseDeclaratorSuffix(тип);
    }
    требуетсяЗакрыв(T.ПСкобка, начало);

    Параметры парамы;
    if (optionalParamList)
      парамы = сема.вид == T.ЛСкобка ? parseParameterList() : null;
    else
      парамы = parseParameterList();

    тип = new ТипУказателяНаФункСи(тип, парамы);
    return установи(тип, начало);
  }

  Тип parseDeclarator(ref Идентификатор* идент, бул identOptional = нет)
  {
    auto t = разборТипа();

    if (сема.вид == T.ЛСкобка)
      t = parseCFunctionPointerType(t, идент, да);
    else if (сема.вид == T.Идентификатор)
    {
      идент = сема.идент;
      далее();
      t = parseDeclaratorSuffix(t);
    }

    if (идент is null && !identOptional)
      ошибка2(сооб.ExpectedDeclaratorIdentifier, сема);

    return t;
  }

  /// Parses a список of AssignExpressions.
  /// $(PRE
  /// ExpressionList :=
  ///   ВыражениеПрисвой
  ///   ВыражениеПрисвой , ExpressionList
  /// )
  Выражение[] parseExpressionList()
  {
    Выражение[] expressions;
    do
      expressions ~= parseAssignExpression();
    while(проверено(T.Запятая))
    return expressions;
  }

  /// Parses a список of Аргументы.
  /// $(PRE
  /// Аргументы :=
  ///   ( )
  ///   ( ExpressionList )
  /// )
  Выражение[] parseArguments()
  {
    auto leftParen = сема;
    пропусти(T.ЛСкобка);
    Выражение[] арги;
    if (сема.вид != T.ПСкобка)
      арги = parseExpressionList();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    return арги;
  }

  /// Parses a ParameterList.
  Параметры parseParameterList()
  out(парамы)
  {
    if (парамы.length > 1)
      foreach (парам; парамы.элементы[0..$-1])
      {
        if (парам.вариадический_ли())
          assert(0, "variadic arguments can only appear at the конец of the parameter список.");
      }
  }
  body
  {
    auto начало = сема;
    требуется(T.ЛСкобка);

    auto парамы = new Параметры();

    if (проверено(T.ПСкобка))
      return установи(парамы, начало);

    do
    {
      auto paramBegin = сема;
      КлассХранения кхр, stc_;
      Тип тип;
      Идентификатор* идент;
      Выражение дефЗначение;

      проц  pushParameter()
      {
        парамы ~= установи(new Параметр(кхр, тип, идент, дефЗначение), paramBegin);
      }

      if (проверено(T.Эллипсис))
      {
        кхр = КлассХранения.Вариадический;
        pushParameter(); // тип, идент and дефЗначение will be null.
        break;
      }

      while (1)
      { // Parse storage classes.
        switch (сема.вид)
        {
      version(D2)
      {
        case T.Инвариант: // D2.0
          if (возьмиСледщ() == T.ЛСкобка)
            break;
          stc_ = КлассХранения.Инвариант;
          goto Lcommon;
        case T.Конст: // D2.0
          if (возьмиСледщ() == T.ЛСкобка)
            break;
          stc_ = КлассХранения.Конст;
          goto Lcommon;
        case T.Окончательный: // D2.0
          stc_ = КлассХранения.Окончательный;
          goto Lcommon;
        case T.Масштаб: // D2.0
          stc_ = КлассХранения.Масштаб;
          goto Lcommon;
        case T.Статический: // D2.0
          stc_ = КлассХранения.Статический;
          goto Lcommon;
      }
        case T.Вхо:
          stc_ = КлассХранения.Вхо;
          goto Lcommon;
        case T.Вых:
          stc_ = КлассХранения.Вых;
          goto Lcommon;
        case T.Вховых, T.Реф:
          stc_ = КлассХранения.Реф;
          goto Lcommon;
        case T.Отложенный:
          stc_ = КлассХранения.Отложенный;
          goto Lcommon;
        Lcommon:
          // Check for redundancy.
          if (кхр & stc_)
            ошибка2(ИДС.RedundantStorageClass, сема);
          else
            кхр |= stc_;
          далее();
        version(D2)
          continue;
        else
          break; // Вхо D1.0 the grammar only allows one storage class.
        default:
        }
        break; // Всё out of inner loop.
      }
      тип = parseDeclarator(идент, да);

      if (проверено(T.Присвоить))
        дефЗначение = parseAssignExpression();

      if (проверено(T.Эллипсис))
      {
        кхр |= КлассХранения.Вариадический;
        pushParameter();
        break;
      }
      pushParameter();

    } while (проверено(T.Запятая))
    требуетсяЗакрыв(T.ПСкобка, начало);
    return установи(парамы, начало);
  }

  АргументыШаблона parseTemplateArguments()
  {
    АргументыШаблона шарги;
    auto leftParen = сема;
    требуется(T.ЛСкобка);
    if (сема.вид != T.ПСкобка)
      шарги = parseTemplateArguments_();
    требуетсяЗакрыв(T.ПСкобка, leftParen);
    return шарги;
  }

version(D2)
{
  АргументыШаблона parseTemplateArguments2()
  {
    пропусти(T.Запятая);
    АргументыШаблона шарги;
    if (сема.вид != T.ПСкобка)
      шарги = parseTemplateArguments_();
    else
      ошибка(сема, сооб.ExpectedTypeOrExpression);
    требуется(T.ПСкобка);
    return шарги;
  }
} // version(D2)

  АргументыШаблона parseTemplateArguments_()
  {
    auto начало = сема;
    auto шарги = new АргументыШаблона;
    do
    {
      Тип parseType_()
      {
        auto тип = разборТипа();
        if (сема.вид == T.Запятая || сема.вид == T.ПСкобка)
          return тип;
        провал_пробы();
        return null;
      }
      бул успех;
      auto typeArgument = пробуй_(&parseType_, успех);
      if (успех)
        // TemplateArgument:
        //         Тип
        //         Символ
        шарги ~= typeArgument;
      else
        // TemplateArgument:
        //         ВыражениеПрисвой
        шарги ~= parseAssignExpression();
    } while (проверено(T.Запятая))
    установи(шарги, начало);
    return шарги;
  }

  /// if ( ConstraintExpression )
  Выражение parseOptionalConstraint()
  {
    if (!проверено(T.Если))
      return null;
    требуется(T.ЛСкобка);
    auto в = разборВыражения();
    требуется(T.ПСкобка);
    return в;
  }

  ПараметрыШаблона parseTemplateParameterList()
  {
    auto начало = сема;
    auto шпарамы = new ПараметрыШаблона;
    требуется(T.ЛСкобка);
    if (сема.вид != T.ПСкобка)
      parseTemplateParameterList_(шпарамы);
    требуетсяЗакрыв(T.ПСкобка, начало);
    return установи(шпарамы, начало);
  }

version(D2)
{
  ПараметрыШаблона parseTemplateParameterList2()
  {
    пропусти(T.Запятая);
    auto начало = сема;
    auto шпарамы = new ПараметрыШаблона;
    if (сема.вид != T.ПСкобка)
      parseTemplateParameterList_(шпарамы);
    else
      ошибка(сема, сооб.ExpectedTemplateParameters);
    return установи(шпарамы, начало);
  }
} // version(D2)

  /// Parses template parameters.
  проц  parseTemplateParameterList_(ПараметрыШаблона шпарамы)
  {
    do
    {
      auto paramBegin = сема;
      ПараметрШаблона tp;
      Идентификатор* идент;
      Тип типСпец, дефТип;

      проц  parseSpecAndOrDefaultType()
      {
        // : SpecializationType
        if (проверено(T.Двоеточие))
          типСпец = разборТипа();
        // = DefaultType
        if (проверено(T.Присвоить))
          дефТип = разборТипа();
      }

      switch (сема.вид)
      {
      case T.Алиас:
        // ПараметрАлиасШаблона:
        //         alias Идентификатор
        пропусти(T.Алиас);
        идент = требуетсяИдентификатор(сооб.ExpectedAliasTemplateParam);
        parseSpecAndOrDefaultType();
        tp = new ПараметрАлиасШаблона(идент, типСпец, дефТип);
        break;
      case T.Идентификатор:
        идент = сема.идент;
        switch (возьмиСледщ())
        {
        case T.Эллипсис:
          // ПараметрКортежШаблона:
          //         Идентификатор ...
          пропусти(T.Идентификатор); пропусти(T.Эллипсис);
          if (сема.вид == T.Запятая)
            ошибка(ИДС.ПараметрКортежШаблона);
          tp = new ПараметрКортежШаблона(идент);
          break;
        case T.Запятая, T.ПСкобка, T.Двоеточие, T.Присвоить:
          // ПараметрТипаШаблона:
          //         Идентификатор
          пропусти(T.Идентификатор);
          parseSpecAndOrDefaultType();
          tp = new ПараметрТипаШаблона(идент, типСпец, дефТип);
          break;
        default:
          // ПараметрШаблонЗначения:
          //         Declarator
          идент = null;
          goto LTemplateValueParameter;
        }
        break;
      version(D2)
      {
      case T.Этот:
        // ПараметрЭтотШаблона
        //         this ПараметрТипаШаблона
        пропусти(T.Этот);
        идент = требуетсяИдентификатор(сооб.ExpectedNameForThisTempParam);
        parseSpecAndOrDefaultType();
        tp = new ПараметрЭтотШаблона(идент, типСпец, дефТип);
        break;
      }
      default:
      LTemplateValueParameter:
        // ПараметрШаблонЗначения:
        //         Declarator
        Выражение спецЗначение, дефЗначение;
        auto типЗначение = parseDeclarator(идент);
        // : SpecializationValue
        if (проверено(T.Двоеточие))
          спецЗначение = parseCondExpression();
        // = DefaultValue
        if (проверено(T.Присвоить))
          дефЗначение = parseCondExpression();
        tp = new ПараметрШаблонЗначения(типЗначение, идент, спецЗначение, дефЗначение);
      }

      // Push template parameter.
      шпарамы ~= установи(tp, paramBegin);

    } while (проверено(T.Запятая))
  }

  /// Returns the ткст of a сема printable в the client.
  сим[] getPrintable(Сема* сема)
  { // TODO: there are some другой семы that have в be handled, в.g. тксты.
    return сема.вид == T.КФ ? "КФ" : сема.исхТекст;
  }

  alias требуется ожидаемое;

  /// Requires a сема of вид лекс.
  проц  требуется(TOK лекс)
  {
    if (сема.вид == лекс)
      далее();
    else
      ошибка2(ИДС.ExpectedButFound, Сема.вТкст(лекс), сема);
  }

  /// Requires the следщ сема в be of вид лекс.
  проц  requireNext(TOK лекс)
  {
    далее();
    требуется(лекс);
  }

  /// Optionally parses an identifier.
  /// Возвращает: null or the identifier.
  Идентификатор* optionalIdentifier()
  {
    Идентификатор* ид;
    if (сема.вид == T.Идентификатор)
      (ид = сема.идент), пропусти(T.Идентификатор);
    return ид;
  }

  Идентификатор* требуетсяИдентификатор()
  {
    Идентификатор* ид;
    if (сема.вид == T.Идентификатор)
      (ид = сема.идент), пропусти(T.Идентификатор);
    else
      ошибка(ИДС.ExpectedButFound, "Идентификатор", сема.исхТекст);
    return ид;
  }

  /// Reports an ошибка if the current сема is not an identifier.
  /// Параметры:
  ///   errorMsg = the ошибка сообщение в be used.
  /// Возвращает: null or the identifier.
  Идентификатор* требуетсяИдентификатор(сим[] errorMsg)
  {
    Идентификатор* ид;
    if (сема.вид == T.Идентификатор)
      (ид = сема.идент), пропусти(T.Идентификатор);
    else
      ошибка(сема, errorMsg, сема.исхТекст);
    return ид;
  }

  /// Reports an ошибка if the current сема is not an identifier.
  /// Параметры:
  ///   идс = the ошибка сообщение ID в be used.
  /// Возвращает: null or the identifier.
  Идентификатор* требуетсяИдентификатор(ИДС идс)
  {
    Идентификатор* ид;
    if (сема.вид == T.Идентификатор)
      (ид = сема.идент), пропусти(T.Идентификатор);
    else
      ошибка(идс, сема.исхТекст);
    return ид;
  }

  /// Reports an ошибка if the current сема is not an identifier.
  /// Возвращает: null or the сема.
  Сема* requireId()
  {
    Сема* idtok;
    if (сема.вид == T.Идентификатор)
      (idtok = сема), пропусти(T.Идентификатор);
    else
      ошибка(ИДС.ExpectedButFound, "Идентификатор", сема.исхТекст);
    return idtok;
  }

  Сема* requireIdToken(сим[] errorMsg)
  {
    Сема* idtok;
    if (сема.вид == T.Идентификатор)
      (idtok = сема), пропусти(T.Идентификатор);
    else
    {
      ошибка(сема, errorMsg, сема.исхТекст);
      idtok = лексер.insertEmptyTokenBefore(сема);
      this.предыдущСема = idtok;
    }
    return idtok;
  }

  /// Reports an ошибка if the закрывающий counterpart of a сема is not found.
  проц  требуетсяЗакрыв(TOK закрывающий, Сема* открывающий)
  {
    assert(закрывающий == T.ПФСкобка || закрывающий == T.ПСкобка || закрывающий == T.ПКвСкобка);
    assert(открывающий !is null);
    if (!проверено(закрывающий))
    {
      auto место = открывающий.getRealLocation();
      auto открывающийLoc = Формат("(открывающий @{},{})", место.номСтр, место.номСтолб);
      //ошибка(сема, сооб.ExpectedClosing,
            //Сема.вТкст(закрывающий), открывающийLoc, getPrintable(сема));
    }
  }

  /// Returns да if the ткст ткт has an invalid UTF-8 sequence.
  бул hasInvalidUTF8(ткст ткт, Сема* начало)
  {
    auto invalidUTF8Seq = Лексер.найдиНедействительнуюПоследовательностьУТФ8(ткт);
    if (invalidUTF8Seq.length)
      ошибка(начало, сооб.НедействительнаяПоследовательностьУТФ8ВТексте, invalidUTF8Seq);
    return invalidUTF8Seq.length != 0;
  }

  /// Forwards ошибка parameters.
  проц  ошибка(Сема* сема, сим[] форматирСооб, ...)
  {
    error_(сема, форматирСооб, _arguments, _argptr);
  }
  /// определено
  проц  ошибка(ИДС идс, ...)
  {
    error_(this.сема, ДайСооб(идс), _arguments, _argptr);
  }

  /// определено
  проц  ошибка2(сим[] форматирСооб, Сема* сема)
  {
    ошибка(сема, форматирСооб, getPrintable(сема));
  }
  /// определено
  проц  ошибка2(ИДС идс, Сема* сема)
  {
    ошибка(идс, getPrintable(сема));
  }
  /// определено
  проц  ошибка2(ИДС идс, сим[] арг, Сема* сема)
  {
    ошибка(идс, арг, getPrintable(сема));
  }

  /// Creates an ошибка report and appends it в a список.
  /// Параметры:
  ///   сема = used в get the положение of where the ошибка is.
  ///   форматирСооб = the compiler ошибка сообщение.
  проц  error_(Сема* сема, сим[] форматирСооб, TypeInfo[] _arguments, va_list _argptr)
  {
    if (пробуем)
    {
      счётОшибок++;
      return;
    }
    auto положение = сема.дайПоложениеОшибки();
    auto сооб = Формат(_arguments, _argptr, форматирСооб);
    auto ошибка = new ОшибкаПарсера(положение, сооб);
    ошибки ~= ошибка;
    if (диаг !is null)
      диаг ~= ошибка;
  }
}
