module drc.Unicode;

import util.uni : униАльфа;

/// U+FFFD = �. Используется для замены неверных символов Юникод.
const дим СИМ_ЗАМЕНЫ = '\uFFFD';
const сим[3] СТР_ЗАМЕНЫ = \uFFFD; /// Ditto
/// Неверный символ, возвращается при ошибке.
const дим СИМ_ОШИБКИ = 0xD800;

/// Возвращает: "да", если this символ is not a surrogate
/// код point and not higher than 0x10FFFF.
бул верноСимвол(дим d)
{
  return d < 0xD800 || d > 0xDFFF && d <= 0x10FFFF;
}

/// There are a всего of 66 noncharacters.
/// Возвращает: "да", если this is one of them.
/// See_also: Chapter 16.7 Noncharacters in Юникод 5.0
бул неСимвол(дим d)
{
  return 0xFDD0 <= d && d <= 0xFDEF || // 32
         d <= 0x10FFFF && (d & 0xFFFF) >= 0xFFFE; // 34
}

/// Возвращает: "да", если this есть trail байт of a UTF-8 sequence.
бул ведомыйБайт(ббайт b)
{
  return (b & 0xC0) == 0x80; // 10xx_xxxx
}

/// Возвращает: "да", если this есть lead байт of a UTF-8 sequence.
бул ведущийБайт(ббайт b)
{
  return (b & 0xC0) == 0xC0; // 11xx_xxxx
}

/// Advances ссыл_ук only if this есть valid Юникод alpha символ.
/// Параметры:
///   ссыл_ук = установи в the last trail байт of the valid UTF-8 sequence.
бул юАльфа(ref сим* ссыл_ук, сим* конец)
in { assert(ссыл_ук && ссыл_ук < конец); }
body
{
  if (*ссыл_ук < 0x80)
    return нет;
  auto у = ссыл_ук;
  auto с = раскодируй(у, конец);
  if (!униАльфа(с))
    return нет;
  ссыл_ук = у-1; // Subtract 1 because of раскодируй().
  return да;
}

/// Раскодирует a символ из ткт at индекс.
/// Параметры:
///   индекс = установи в one past the ASCII сим или one past the last trail байт
///           of the valid UTF-8 sequence.
дим раскодируй(ткст ткт, ref т_мера индекс)
in { assert(ткт.length && индекс < ткт.length); }
out { assert(индекс <= ткт.length); }
body
{
  сим* у = ткт.ptr + индекс;
  сим* конец = ткт.ptr + ткт.length;
  дим с = раскодируй(у, конец);
  if (с != СИМ_ОШИБКИ)
    индекс = у - ткт.ptr;
  return с;
}

/// Раскодирует a символ starting at ссыл_ук.
/// Параметры:
///   ссыл_ук = установи в one past the ASCII сим или one past the last trail байт
///           of the valid UTF-8 sequence.
дим раскодируй(ref сим* ссыл_ук, сим* конец)
in { assert(ссыл_ук && ссыл_ук < конец); }
out(с) { assert(ссыл_ук <= конец && (верноСимвол(с) || с == СИМ_ОШИБКИ)); }
body
{
  сим* у = ссыл_ук;
  дим с = *у;

  if (с < 0x80)
    return ссыл_ук++, с;

  у++; // Перейти ко второму байту.
  if (!(у < конец))
    return СИМ_ОШИБКИ;

  // Ошибка, если второй байт не трейлбайт.
  if (!ведомыйБайт(*у))
    return СИМ_ОШИБКИ;

  // Проверка на сверхдлинные последовательности.
  switch (с)
  {
  case 0xE0, // 11100000 100xxxxx
       0xF0, // 11110000 1000xxxx
       0xF8, // 11111000 10000xxx
       0xFC: // 11111100 100000xx
    if ((*у & с) == 0x80)
      return СИМ_ОШИБКИ;
  default:
    if ((с & 0xFE) == 0xC0) // 1100000x
      return СИМ_ОШИБКИ;
  }

  const ткст проверьСледующийБайт = "if (!(++у < конец && ведомыйБайт(*у)))"
                                "  return СИМ_ОШИБКИ;";
  const ткст добавьШестьБит = "с = (с << 6) | *у & 0b0011_1111;";

  // Раскодировка
  if ((с & 0b1110_0000) == 0b1100_0000)
  {
    // 110xxxxx 10xxxxxx
    с &= 0b0001_1111;
    mixin(добавьШестьБит);
  }
  else if ((с & 0b1111_0000) == 0b1110_0000)
  {
    // 1110xxxx 10xxxxxx 10xxxxxx
    с &= 0b0000_1111;
    mixin(добавьШестьБит ~
          проверьСледующийБайт ~ добавьШестьБит);
  }
  else if ((с & 0b1111_1000) == 0b1111_0000)
  {
    // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
    с &= 0b0000_0111;
    mixin(добавьШестьБит ~
          проверьСледующийБайт ~ добавьШестьБит ~
          проверьСледующийБайт ~ добавьШестьБит);
  }
  else
    // 5 and 6 байт UTF-8 sequences are not allowed yet.
    // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
    // 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
    return СИМ_ОШИБКИ;

  assert(ведомыйБайт(*у));

  if (!верноСимвол(с))
    return СИМ_ОШИБКИ;
  ссыл_ук = у+1;
  return с;
}

/// Кодирует символ и прибавляет его к ткт.
проц  кодируй(ref ткст ткт, дим с)
{
  assert(верноСимвол(с), "проверка валидности перед вызовом кодируй().");
  сим[6] b = void;
  if (с < 0x80)
    ткт ~= с;
  else if (с < 0x800)
  {
    b[0] = 0xC0 | (с >> 6);
    b[1] = 0x80 | (с & 0x3F);
    ткт ~= b[0..2];
  }
  else if (с < 0x10000)
  {
    b[0] = 0xE0 | (с >> 12);
    b[1] = 0x80 | ((с >> 6) & 0x3F);
    b[2] = 0x80 | (с & 0x3F);
    ткт ~= b[0..3];
  }
  else if (с < 0x200000)
  {
    b[0] = 0xF0 | (с >> 18);
    b[1] = 0x80 | ((с >> 12) & 0x3F);
    b[2] = 0x80 | ((с >> 6) & 0x3F);
    b[3] = 0x80 | (с & 0x3F);
    ткт ~= b[0..4];
  }
  /+ // There are no 5 and 6 байт UTF-8 sequences yet.
  else if (с < 0x4000000)
  {
    b[0] = 0xF8 | (с >> 24);
    b[1] = 0x80 | ((с >> 18) & 0x3F);
    b[2] = 0x80 | ((с >> 12) & 0x3F);
    b[3] = 0x80 | ((с >> 6) & 0x3F);
    b[4] = 0x80 | (с & 0x3F);
    ткт ~= b[0..5];
  }
  else if (с < 0x80000000)
  {
    b[0] = 0xFC | (с >> 30);
    b[1] = 0x80 | ((с >> 24) & 0x3F);
    b[2] = 0x80 | ((с >> 18) & 0x3F);
    b[3] = 0x80 | ((с >> 12) & 0x3F);
    b[4] = 0x80 | ((с >> 6) & 0x3F);
    b[5] = 0x80 | (с & 0x3F);
    ткт ~= b[0..6];
  }
  +/
  else
    assert(0);
}

/// Кодирует символ и прибавляет его к ткт.
проц  кодируй(ref шим[] ткт, дим с)
in { assert(верноСимвол(с)); }
body
{
  if (с < 0x10000)
    ткт ~= cast(шим)с;
  else
  { // EnКод with surrogate пара.
    шим[2] пара = void;
    с -= 0x10000; // с'
    // higher10bits(с') | 0b1101_10xx_xxxx_xxxx
    пара[0] = (с >> 10) | 0xD800;
    // lower10bits(с') | 0b1101_11yy_yyyy_yyyy
    пара[1] = (с & 0x3FF) | 0xDC00;
    ткт ~= пара;
  }
}

/// Раскодирует a символ из a UTF-16 sequence.
/// Параметры:
///   ткт = the UTF-16 sequence.
///   индекс = where в старт из.
/// Возвращает: СИМ_ОШИБКИ in case of an ошибка in the sequence.
дим раскодируй(шим[] ткт, ref т_мера индекс)
{
  assert(ткт.length && индекс < ткт.length);
  дим с = ткт[индекс];
  if (0xD800 > с || с > 0xDFFF)
  {
    ++индекс;
    return с;
  }
  if (с <= 0xDBFF && индекс+1 != ткт.length)
  {
    шим c2 = ткт[индекс+1];
    if (0xDC00 <= c2 && c2 <= 0xDFFF)
    { // Раскодировка surrogate пара.
      // (с - 0xD800) << 10 + 0x10000 ->
      // (с - 0xD800 + 0x40) << 10 ->
      с = (с - 0xD7C0) << 10;
      с |= (c2 & 0x3FF);
      индекс += 2;
      return с;
    }
  }
  return СИМ_ОШИБКИ;
}

/// Раскодирует a символ из a UTF-16 sequence.
/// Параметры:
///   у = старт of the UTF-16 sequence.
///   конец = one past the конец of the sequence.
/// Возвращает: СИМ_ОШИБКИ in case of an ошибка in the sequence.
дим раскодируй(ref шим* у, шим* конец)
{
  assert(у && у < конец);
  дим с = *у;
  if (0xD800 > с || с > 0xDFFF)
  {
    ++у;
    return с;
  }
  if (с <= 0xDBFF && у+1 != конец)
  {
    шим c2 = у[1];
    if (0xDC00 <= c2 && c2 <= 0xDFFF)
    {
      с = (с - 0xD7C0) << 10;
      с |= (c2 & 0x3FF);
      у += 2;
      return с;
    }
  }
  return СИМ_ОШИБКИ;
}

/// Раскодирует a символ из a zero-terminated UTF-16 ткст.
/// Параметры:
///   у = старт of the UTF-16 sequence.
/// Возвращает: СИМ_ОШИБКИ in case of an ошибка in the sequence.
дим раскодируй(ref шим* у)
{
  assert(у);
  дим с = *у;
  if (0xD800 > с || с > 0xDFFF)
  {
    ++у;
    return с;
  }
  if (с <= 0xDBFF)
  {
    шим c2 = у[1];
    if (0xDC00 <= c2 && c2 <= 0xDFFF)
    {
      с = (с - 0xD7C0) << 10;
      с |= (c2 & 0x3FF);
      у += 2;
      return с;
    }
  }
  return СИМ_ОШИБКИ;
}

/// Преобразует текст из UTF-8 в UTF-16 ткст.
шим[] вЮ16(ткст ткт)
{
  шим[] результат;
  т_мера idx;
  while (idx < ткт.length)
  {
    auto с = раскодируй(ткт, idx);
    if (с == СИМ_ОШИБКИ)
    { // Пропустим trail bytes.
      while (++idx < ткт.length && ведомыйБайт(ткт[idx]))
      {}
      с = СИМ_ЗАМЕНЫ;
    }
    кодируй(результат, с);
  }
  return результат;
}

/// Преобразует текст из UTF-8 в UTF-32 ткст.
дим[] вЮ32(ткст ткт)
{
  дим[] результат;
  т_мера idx;
  while (idx < ткт.length)
  {
    auto с = раскодируй(ткт, idx);
    if (с == СИМ_ОШИБКИ)
    { // Пропустим trail bytes.
      while (++idx < ткт.length && ведомыйБайт(ткт[idx]))
      {}
      с = СИМ_ЗАМЕНЫ;
    }
    результат ~= с;
  }
  return результат;
}
