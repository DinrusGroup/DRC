/// Author: Aziz Köksal
/// License: GPL3
/// $(Maturity high)
module drc.ModuleManager;

import drc.semantic.Module,
       drc.semantic.Package;
import drc.Diagnostics;
import drc.Messages;
import common;

import io.FilePath,
       io.FileSystem,
       io.model;
import util.PathUtil : нормализуйПуть = нормализуй;

alias ФайлКонст.СимПутьРазд папРазд;

/// Manages loaded модули in a таблица.
class МодульМенеджер
{
  /// Корневой пакет. Содержит все прочие модули и пакеты.
  Пакет корневойПакет;
  /// Maps полные имена пакетов в пакеты. E.g.: drc.ast
  Пакет[ткст] таблицаПакетов;
  /// Maps ПКИ пути в модули. E.g.: dil/ast/Узел
  Модуль[ткст] таблицаПКИПутейКМодулям;
  /// Карта абсолютных путей к файлам модулей. Напр.: /home/user/dil/src/main.d
  Модуль[ткст] таблицаАбсФПутей;
  Модуль[] загруженныеМодули; /// Загруженные модули в последовательном порядке.
  ткст[] путиИмпорта; /// Где искаль файлы модулей.
  Диагностика диаг;

  /// Строит МодульМенеджер объект.
  this(ткст[] путиИмпорта, Диагностика диаг)
  {
    this.корневойПакет = new Пакет(null);
    таблицаПакетов[""] = this.корневойПакет;
    this.путиИмпорта = путиИмпорта;
    this.диаг = диаг;
  }

  /// Загружает модуль по заданному файловому пути.
  Модуль загрузиФайлМодуля(ткст путьКФайлуМодуля)
  {
    auto абсФПуть = ФСистема.вАбсолют(путьКФайлуМодуля);
    // FIXME: нормализуй() doesn't simplify //. Handle the exception it throws.
    абсФПуть = нормализуйПуть(абсФПуть); // Remove ./ /. ../ and /..
    if (auto сущМодуль = абсФПуть in таблицаАбсФПутей)
      return *сущМодуль;

    // Create a new module.
    auto новМодуль = new Модуль(путьКФайлуМодуля, диаг);
    новМодуль.разбор();

    auto путьПоПКНМодуля = новМодуль.дайПутьПКН();
    if (auto сущМодуль = путьПоПКНМодуля in таблицаПКИПутейКМодулям)
    { // Ошибка: two module files have the same f.q. module имя.
      auto положение = новМодуль.дайСемуДеклМодуля().дайПоложениеОшибки();
      auto сооб = Формат(сооб.КонфликтующиеФайлыМодулей, новМодуль.путьКФайлу());
      диаг ~= new ОшибкаСемантики(положение, сооб);
      return *сущМодуль;
    }

    // Insert new module.
    таблицаПКИПутейКМодулям[путьПоПКНМодуля] = новМодуль;
    таблицаАбсФПутей[абсФПуть] = новМодуль;
    загруженныеМодули ~= новМодуль;
    // Add the module в its package.
    auto пкт = дайПакет(новМодуль.имяПакета);
    пкт.добавь(новМодуль);

    if (auto p = новМодуль.дайПКН() in таблицаПакетов)
    { // Ошибка: module and package share the same имя.
      auto положение = новМодуль.дайСемуДеклМодуля().дайПоложениеОшибки();
      auto сооб = Формат(сооб.КонфликтующиеМодульИПакет, новМодуль.дайПКН());
      диаг ~= new ОшибкаСемантики(положение, сооб);
    }

    return новМодуль;
  }

  /// Возвращает package given a f.q. package имя.
  /// Возвращает корень package for an empty ткст.
  Пакет дайПакет(ткст пКНПкта)
  {
    auto pPckg = пКНПкта in таблицаПакетов;
    if (pPckg)
      return *pPckg;

    ткст предшПКН, последнИмяПкта;
    // E.g.: пКНПкта = 'drc.ast', предшПКН = 'dil', последнИмяПкта = 'ast'
    разбейПКНПакета(пКНПкта, предшПКН, последнИмяПкта);
    // Recursively build package hierarchy.
    auto родПкт = дайПакет(предшПКН); // E.g.: 'dil'

    // Create a new package.
    auto пкт = new Пакет(последнИмяПкта); // E.g.: 'ast'
    родПкт.добавь(пкт); // 'dil'.добавь('ast')

    // Insert the package into the таблица.
    таблицаПакетов[пКНПкта] = пкт;

    return пкт;
  }

  /// Splits в.g. 'drc.ast.xyz' into 'drc.ast' and 'xyz'.
  /// Параметры:
  ///   пКНПкта = the full package имя в be split.
  ///   предшПКН = установи в 'drc.ast' in the example.
  ///   последнИмя = the last package имя; установи в 'xyz' in the example.
  проц  разбейПКНПакета(ткст пКНПкта, ref ткст предшПКН, ref ткст последнИмя)
  {
    бцел последнИндксТчки;
    foreach_reverse (i, c; пКНПкта)
      if (c == '.')
      { последнИндксТчки = i; break; } // Found last dot.
    if (последнИндксТчки == 0)
      последнИмя = пКНПкта; // Special case - no dot found.
    else
    {
      предшПКН = пКНПкта[0..последнИндксТчки];
      последнИмя = пКНПкта[последнИндксТчки+1..$];
    }
  }

  /// Loads a module given an ПКИ путь.
  Модуль загрузиМодуль(ткст путьПоПКНМодуля)
  {
    // Look up in таблица if the module is already loaded.
    Модуль* уМодуль = путьПоПКНМодуля in таблицаПКИПутейКМодулям;
    if (уМодуль)
      return *уМодуль;

    // Locate the module in the file system.
    auto путьКФайлуМодуля = найдиПутьКФайлуМодуля(путьПоПКНМодуля, путиИмпорта);
    if (!путьКФайлуМодуля.length)
      return null;

    // Load the found module file.
    auto модуль = загрузиФайлМодуля(путьКФайлуМодуля);
    if (модуль.дайПутьПКН() != путьПоПКНМодуля)
    { // Ошибка: the requested module is not in the correct package.
      auto положение = модуль.дайСемуДеклМодуля().дайПоложениеОшибки();
      auto сооб = Формат(сооб.ВПакетеНетМодуля, дайПКНПакета(путьПоПКНМодуля));
      диаг ~= new ОшибкаСемантики(положение, сооб);
    }

    return модуль;
  }

  /// Returns в.g. 'drc.ast' for 'dil/ast/Узел'.
  static ткст дайПКНПакета(ткст путьПоПКНМодуля)
  {
    ткст пкт = путьПоПКНМодуля.dup;
    бцел последнПапРазд;
    foreach (i, c; пкт)
      if (c == папРазд)
        (пкт[i] = '.'), (последнПапРазд = i);
    return пкт[0..последнПапРазд];
  }

  /// Searches for a module in the file system looking in путиИмпорта.
  /// Возвращает: the file путь в the module, or null if it wasn't found.
  static ткст найдиПутьКФайлуМодуля(ткст путьПоПКНМодуля, ткст[] путиИмпорта)
  {
    auto путьКФайлу = new ФПуть();
    foreach (путьИмпорта; путиИмпорта)
    {
      путьКФайлу.установи(путьИмпорта); // E.g.: ист/
      путьКФайлу.добавь(путьПоПКНМодуля); // E.g.: dil/ast/Узел
      foreach (суффиксМодуля; [".d", ".di"/*interface file*/])
      {
        путьКФайлу.суффикс(суффиксМодуля);
        if (путьКФайлу.есть_ли()) // E.g.: ист/dil/ast/Узел.d
          return путьКФайлу.вТкст();
      }
    }
    return null;
  }
}
