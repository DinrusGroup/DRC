module drc.Converter;

import drc.lexer.Funcs;
import drc.Diagnostics;
import drc.Location;
import drc.Unicode;
import drc.FileBOM;
import drc.Messages;
import common;
import base;

version (Windows)
{
	version = ЛитлЭндиан;
}

/// Преобразует различные форматы кодировки Юникод в UTF-8.
struct Преобразователь
{
  ткст путьКФайлу; /// Для сообщений об ошибках.
  Диагностика диаг;

  static Преобразователь opCall(ткст путьКФайлу, Диагностика диаг)
  {
    Преобразователь конв;
    конв.путьКФайлу = путьКФайлу;
    конв.диаг = диаг;
    return конв;
  }

  /// Инвертирует байты в с.
  дим инвертироватьБайты(дим с)
  {
    return с = (с << 24) |
               (с >> 24) |
              ((с >> 8) & 0xFF00) |
              ((с << 8) & 0xFF0000);
  }

  /// Инвертирует байты в с.
  шим инвертироватьБайты(шим с)
  {
    return (с << 8) | (с >> 8);
  }

  /// Инвертирует байты на машине с ЛитлЭндиан.
  дим БЕВМашинноеДслово(дим с)
  {
    version(ЛитлЭндиан)
      return инвертироватьБайты(с);
    else
      return с;
  }

  /// Инвертирует байты в с на машине с БигЭндиан.
  дим ЛЕВМашинноеДслово(дим с)
  {
    version(ЛитлЭндиан)
      return с;
    else
      return инвертироватьБайты(с);
  }

  /// Инвертирует байты в с на машине с ЛитлЭндиан.
  шим БЕВМашинноеСлово(шим с)
  {
    version(ЛитлЭндиан)
      return инвертироватьБайты(с);
    else
      return с;
  }

  /// Инвертирует байты в с на машине с БигЭндианe.
  шим ЛЕВМашинноеСлово(шим с)
  {
    version(ЛитлЭндиан)
      return с;
    else
      return инвертироватьБайты(с);
  }

  /// Преобразует текст в UTF-32 в UTF-8.
  ткст УТФ32вУТФ8(бул БЕ)(ббайт[] данные)
  {
    if (данные.length == 0)
      return пусто;

    ткст результат;
    бцел номерСтроки = 1;
    дим[] текст = cast(дим[]) данные[0 .. $-($%4)]; 
    foreach (дим с; текст)
    {
      static if (БЕ)
        с = БЕВМашинноеДслово(с);
      else
        с = ЛЕВМашинноеДслово(с);

      if (!верноСимвол(с))
      {
        диаг ~= new ОшибкаЛексера(
          new Положение(путьКФайлу, номерСтроки),
          Формат(сооб.НеверныйСимволУТФ32, с)
        );
        с = СИМ_ЗАМЕНЫ;
      }

      if (новСтр(с))
        ++номерСтроки;
      drc.Unicode.кодируй(результат, с);
    }

    if (данные.length % 4)
      диаг ~= new ОшибкаЛексера(
        new Положение(путьКФайлу, номерСтроки),
        сооб.ФайлУТФ32ДолженДелитьсяНа4
      );

    return результат;
  }

  alias УТФ32вУТФ8!(да) УТФ32БЭ_в_УТФ8; /// Создание экземпляра для UTF-32 BE.
  alias УТФ32вУТФ8!(нет) УТФ32ЛЭ_в_УТФ8; /// Создание экземпляра для UTF-32 LE.

  /// Конвертирует текст UTF-16 в UTF-8.
  ткст УТФ16вУТФ8(бул БЕ)(ббайт[] данные)
  {
    if (данные.length == 0)
      return пусто;

    шим[] текст = cast(шим[]) данные[0 .. $-($%2)]; 
    шим* у = текст.ptr,
         конец = текст.ptr + текст.length;
    ткст результат;
    бцел номерСтроки = 1;

    for (; у < конец; у++)
    {
      дим с = *у;
      static if (БЕ)
        с = БЕВМашинноеСлово(с);
      else
        с = ЛЕВМашинноеСлово(с);

      if (0xD800 > с || с > 0xDFFF)
      {}
      else if (с <= 0xDBFF && у+1 < конец)
      { // Декодировать суррогатные пары.
        шим c2 = у[1];
        static if (БЕ)
          c2 = БЕВМашинноеСлово(c2);
        else
          c2 = ЛЕВМашинноеСлово(c2);

        if (0xDC00 <= c2 && c2 <= 0xDFFF)
        {
          с = (с - 0xD7C0) << 10;
          с |= (c2 & 0x3FF);
          ++у;
        }
      }
      else
      {
        диаг ~= new ОшибкаЛексера(
          new Положение(путьКФайлу, номерСтроки),
          Формат(сооб.НеверныйСимволУТФ16, с)
        );
        с = СИМ_ЗАМЕНЫ;
      }

      if (новСтр(с))
        ++номерСтроки;
      drc.Unicode.кодируй(результат, с);
    }

    if (данные.length % 2)
      диаг ~= new ОшибкаЛексера(
        new Положение(путьКФайлу, номерСтроки),
        сооб.ФайлУТФ16ДолженДелитьсяНа2
      );
    return результат;
  }

  alias УТФ16вУТФ8!(да) UTF16BEtoUTF8; /// Создание экземпляра для UTF-16 BE.
  alias УТФ16вУТФ8!(нет) UTF16LEtoUTF8; /// Создание экземпляра для UTF-16 LE.

  /// Преобразует текст в данные в UTF-8.
  /// Оставляет данные неизменными, если он уже в UTF-8.
  ткст данныеВУТФ8(ббайт[] данные)
  {
    if (данные.length == 0)
      return "";

    ткст текст;
    МПБ мпб = опишиМПБ(данные);

    switch (мпб)
    {
    case МПБ.Нет:
      // МПБ (метка порядка байтов, eng. BOM) не найдена.
	 //  Согласно спецификациям, первый символ
    //   должен быть символом ASCII.
      if (данные.length >= 4)
      {
        if (данные[0..3] == cast(ббайт[3])x"00 00 00")
        {
          текст = УТФ32БЭ_в_УТФ8(данные); // UTF-32BE: 00 00 00 XX
          break;
        }
        else if (данные[1..4] == cast(ббайт[3])x"00 00 00")
        {
          текст = УТФ32ЛЭ_в_УТФ8(данные); // UTF-32LE: XX 00 00 00
          break;
        }
      }
      if (данные.length >= 2)
      {
        if (данные[0] == 0) // UTF-16BE: 00 XX
        {
          текст = UTF16BEtoUTF8(данные);
          break;
        }
        else if (данные[1] == 0) // UTF-16LE: XX 00
        {
          текст = UTF16LEtoUTF8(данные);
          break;
        }
      }
      текст = cast(сим[])данные; // UTF-8
      break;
    case МПБ.Ю8:
      текст = cast(сим[])данные[3..$];
      break;
    case МПБ.Ю16БЕ:
      текст = UTF16BEtoUTF8(данные[2..$]);
      break;
    case МПБ.Ю16ЛЕ:
      текст = UTF16LEtoUTF8(данные[2..$]);
      break;
    case МПБ.Ю32БЕ:
      текст = УТФ32БЭ_в_УТФ8(данные[4..$]);
      break;
    case МПБ.Ю32ЛЕ:
      текст = УТФ32ЛЭ_в_УТФ8(данные[4..$]);
      break;
    default:
      assert(0);
    }
    return текст;
  }
}

/// Заменяет неверные последовательности UTF-8 на U+FFFD (если места достаточно,)
/// а Newlines на '\n'.
ткст обеззаразьТекст(ткст текст)
{
  if (!текст.length)
    return пусто;

  сим* у = текст.ptr; // Reader.
  сим* конец = у + текст.length;
  сим* q = у; // Writer.

  for (; у < конец; у++, q++)
  {
    assert(q <= у);
    if (аски(*у)) {
      *q = *у; // Just копируй ASCII characters.
      continue;
    }
    switch (*у)
    {
    case '\r':
      if (у+1 < конец && у[1] == '\n')
        у++;
    case '\n':
      *q = '\n'; // Copy newlines as '\n'.
      continue;
    default:
      if (у+2 < конец && новСтрЮ(у))
      {
        у += 2;
        goto case '\n';
      }

      auto p2 = у; // Запомнить начало цепочки UTF-8.
      дим с = раскодируй(у, конец);

      if (с == СИМ_ОШИБКИ)
      { // Пропустим в следщ ASCII символ или valid UTF-8 sequence.
        while (++у < конец && ведомыйБайт(*у))
        {}
        alias СТР_ЗАМЕНЫ R;
        if (q+2 < у) // Copy replacement сим if there is enough space.
          (*q = R[0]), (*++q = R[1]), (*++q = R[2]);
        у--;
      }
      else
      { // Copy the valid UTF-8 sequence.
        while (p2 < у) // у points в one past the last trail байт.
          *q++ = *p2++; // Copy код units.
        q--;
        у--;
      }
    }
  }
  assert(у == конец);
  текст.length = q - текст.ptr;
  return текст;
}

unittest
{
  выдай("Тестируется функция Преобразователь.\n");
  struct Data2Text
  {
    ткст текст;
    ткст ожидаемое = "source";
    ббайт[] данные()
    { return cast(ббайт[])текст; }
  }
  const Data2Text[] карта = [
    // Without МПБ
    {"source"},
    {"s\0o\0u\0r\0c\0e\0"},
    {"\0s\0o\0u\0r\0c\0e"},
    {"s\0\0\0o\0\0\0u\0\0\0r\0\0\0c\0\0\0e\0\0\0"},
    {"\0\0\0s\0\0\0o\0\0\0u\0\0\0r\0\0\0c\0\0\0e"},
    // Для МПБ
    {"\xEF\xBB\xBFsource"},
    {"\xFE\xFF\0s\0o\0u\0r\0c\0e"},
    {"\xFF\xFEs\0o\0u\0r\0c\0e\0"},
    {"\x00\x00\xFE\xFF\0\0\0s\0\0\0o\0\0\0u\0\0\0r\0\0\0c\0\0\0e"},
    {"\xFF\xFE\x00\x00s\0\0\0o\0\0\0u\0\0\0r\0\0\0c\0\0\0e\0\0\0"},
  ];
  auto конвертер = Преобразователь("", new Диагностика);
  foreach (i, пара; карта)
    assert(конвертер.данныеВУТФ8(пара.данные) == пара.ожидаемое, Формат("провал на элементе {}", i));
}
