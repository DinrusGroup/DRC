module fibonacci;

import win, stdrus, ll.Analysis, ll.Target, ll.Core, ll.Types, ll.ExecutionEngine;
import ll.Transforms, ll.lto;

extern(C) ткст[] дайАргиКС();

бул useMCJIT = {
    // MCJIT does not work on Windows
    version(Windows) { return нет; }
    else {
        // Use MCJIT only if ЛЛДайАдрФункц is available,
        // as ЛЛВыполниФункц does not work reliably with it.
        static if (LLVM_Version >= asVersion(3,6,0)) { return да; }
        else { return нет; }
    }
}();

проц иницДжИТ(ref ЛЛДвижокВыполнения двиг, ЛЛМодуль генМод)
{
    ткст ошибка;
/+
    static if (useMCJIT) {
        LLVMMCJITCompilerOptions опции;
        ЛЛИнициализуйОпцииМЦДжИТКомпилятора(&опции, опции.sizeof);

        ЛЛСоздайМЦДжИТКомпиляторДляМодуля(&двиг, генМод, &опции, опции.sizeof, &ошибка);
    } else {
        +/
        ЛЛСоздайДжИТКомпиляторДляМодуля(&двиг, генМод, 2, cast(char**) ошибка.вТкст0());
   // }

    if (ошибка)
    {
        scope (exit) ЛЛВыместиСообщение(ошибка.вТкст0());
        throw new Исключение(ошибка);
    }
}

цел main(ткст[] арги)
{
    ткст0 ошибка;
    
    win.скажинс(stdrus.вТкст(ll.lto.ЛЛОВК_ДайВерсию()));

    ЛЛИнициализуйНативныйТаргет();
    ЛЛИнициализуйНативныйАсмПринтер();
    ЛЛИнициализуйНативныйАсмПарсер();

    auto генМод = ЛЛМодуль_СоздайСИменем("Фибоначчи".вТкст0());
    auto генФибПарамы = [ ЛЛТипЦел32() ];
    auto генФиб = ЛЛДобавьФункц(
        генМод,
        "фиб",
        ЛЛТипФункция(ЛЛТипЦел32(), генФибПарамы.ptr, 1, cast(ЛЛБул) нет));
    ЛЛУстКонвВызФунции(генФиб, 0);

    auto genN = ЛЛДайПарам(генФиб, 0);

    auto genEntryBlk = ЛЛПриставьБазБлок(генФиб, "ввод".вТкст0());
    auto genAnchor0Blk = ЛЛПриставьБазБлок(генФиб, "якорь0".вТкст0());
    auto genAnchor1Blk = ЛЛПриставьБазБлок(генФиб, "якорь1".вТкст0());
    auto genRecurseBlk = ЛЛПриставьБазБлок(генФиб, "рекурс".вТкст0());
    auto end = ЛЛПриставьБазБлок(генФиб, "конец".вТкст0());

    auto постройщик = ЛЛСоздайПостроитель();

    /+ Entry block +/
    ЛЛПостроительПозицииВКонце(постройщик, genEntryBlk);
    auto fibSwitch = ЛЛСтройЩит(
        постройщик,
        genN,
        genRecurseBlk,
        2);
    ЛЛДобавьРеле(fibSwitch, ЛЛКонстЦел(ЛЛТипЦел32(), 0, cast(ЛЛБул) нет), genAnchor0Blk);
    ЛЛДобавьРеле(fibSwitch, ЛЛКонстЦел(ЛЛТипЦел32(), 1, cast(ЛЛБул) нет), genAnchor1Blk);

    /+ Блок для н = 0: фиб(н) = 0 +/
    ЛЛПостроительПозицииВКонце(постройщик, genAnchor0Blk);
    auto genAnchor0Result = ЛЛКонстЦел(ЛЛТипЦел32(), 0, cast(ЛЛБул) нет);
    ЛЛСтройБр(постройщик, end);

    /+ Блок для  н = 1: фиб(н) = 1 +/
    ЛЛПостроительПозицииВКонце(постройщик, genAnchor1Blk);
    auto genAnchor1Result = ЛЛКонстЦел(ЛЛТипЦел32(), 1, cast(ЛЛБул) нет);
    ЛЛСтройБр(постройщик, end);

    /+ Блок для  н > 1: фиб(н) = фиб(н - 1) + фиб(н - 2) +/
    ЛЛПостроительПозицииВКонце(постройщик, genRecurseBlk);

    auto genNMinus1 = ЛЛСтройОтними(
        постройщик,
        genN,
        ЛЛКонстЦел(ЛЛТипЦел32(), 1, cast(ЛЛБул) нет),
        "н - 1".вТкст0());
    auto genCallFibNMinus1 = ЛЛСтройВызов(постройщик, генФиб, [genNMinus1].ptr, 1, "фиб(н - 1)".вТкст0());

    auto genNMinus2 = ЛЛСтройОтними(
        постройщик,
        genN,
        ЛЛКонстЦел(ЛЛТипЦел32(), 2, cast(ЛЛБул) нет),
        "н - 2".вТкст0());
    auto genCallFibNMinus2 = ЛЛСтройВызов(постройщик, генФиб, [genNMinus2].ptr, 1, "фиб(н - 2)".вТкст0());

    auto genRecurseResult = ЛЛСтройСложи(постройщик, genCallFibNMinus1, genCallFibNMinus2, "фиб(н - 1) + фиб(н - 2)".вТкст0());
    ЛЛСтройБр(постройщик, end);

    /+ Block for collecting the final result +/
    ЛЛПостроительПозицииВКонце(постройщик, end);
    auto genFinalResult = LLBuildPhi(постройщик, ЛЛТипЦел32(), "результат".вТкст0());
    auto phiValues = [ genAnchor0Result, genAnchor1Result, genRecurseResult ];
    auto phiBlocks = [ genAnchor0Blk, genAnchor1Blk, genRecurseBlk ];
    ЛЛДобавьВходящ(genFinalResult, phiValues.ptr, phiBlocks.ptr, 3);
    ЛЛСтройВозвр(постройщик, genFinalResult);

    ЛЛВерифицируйМодуль(генМод, ЛЛДействиеВерификатораПриОшибке.ПрерватьПроцесс, &ошибка);
    ЛЛВыместиСообщение(ошибка);

    ЛЛДвижокВыполнения двиг;
    ошибка = пусто;

    иницДжИТ(двиг, генМод);

    auto pass = ЛЛСоздайМенеджерПроходок();
    ЛЛДобавьПроходкуПропагацияКонстант(pass);
    ЛЛДобавьПроходкуКомбинированияИнструкций(pass);
    ЛЛДобавьПроходкуПамятьВРегистр(pass);
    ЛЛДобавьПроходкуГВН(pass);
    ЛЛДобавьПроходкуКФГУпрощения(pass);
    ЛЛЗапустиМенеджерПроходок(pass, генМод);

    скажинс("Сгенерирован следующий модуль для серии Фиббоначи:");
    ЛЛДампМодуля(генМод);

    нс();

    цел н = 10;
    ткст[] ксарги = дайАргиКС();
    if (ксарги.length > 1)
    {
        скажифнс("Получен из командной строки аргумент равный %s", ксарги[1]);
        н = вЦел(ксарги[1]);
    }
    else
    {
        скажифнс("; Аргумент для фиб отсутствует в командной строке, по умолчанию используется:  \"%d\"", н);
    }

    цел фиб(цел н)
    {
        /+
        static if (useMCJIT) {
            alias extern (C) цел function(цел) Fib;
            auto fib = cast(Fib) ЛЛДайАдрФункц(двиг, "fib".вТкст0());
            return fib(n);
        } else {
            +/
            auto арги = [ ЛЛСоздайГенЗначЦел(ЛЛТипЦел32(), н, cast(ЛЛБул) 0) ];
            return cast(цел) ЛЛГенЗначВЦел(ЛЛВыполниФункц(двиг, генФиб, 1, арги.ptr), 0);
       // }
    }

    скажифнс("; Выполняется (jit-компилированный) фиб(%d)...", н);
    скажифнс("; фиб(%d) = %d", н, фиб(н));

    ЛЛВыместиМенеджерПроходок(pass);
    ЛЛВыместиПостроитель(постройщик);
    ЛЛВыместиДвижВып(двиг);
    пз;
    return 0;
}
