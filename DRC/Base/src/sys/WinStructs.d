/**
Модуль структур WIN API для языка Динрус.
Разработчик Виталий Кулич.
*/
module sys.WinStructs;
import tpl.com, sys.com, stdrus;

//В структурах часто встречаются алиасы базовых типов, которыми
//обозначаются те или иные семантические смыслы. Эти алиасы
//можно поместить отдельно в sys.WinAlias модуле, так как они
//используются далее в функциях и т.п.
//На данный момент они были занесены в файл base,
//что хорошо для Виндовс, но плохо для других систем,
//"хаком" которых пока ещё Динрус не занимался(!!!)

/* Модуль sys.Common задуман в Tango для "переключенческих" целей
* между АБИ разных ОС. Поэтому base следует разгрузить, оставив
* только универсальные, чисто "динрусовские", типы.
*/

alias цел ИДДИСП;
alias ИДДИСП ИДЧЛЕНА;
alias бцел ТИПГССЫЛ;

export extern(D)
{
 struct ГУИД 
	{
	
	export:
	
	  бцел a;
	  бкрат b, c;
	  ббайт d, e, f, g, h, i, j, k;

	  /**
	   * ГУИД, все значения которого являются нулями.
	   */
	  static ГУИД пустой = { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };

	  /**
	   * Инициализует _новый экземпляр, используя заданные целые и байты.
	   * Параметры:
	   *   a = Первые 4 байта.
	   *   b = Следующие 2 байта.
	   *   c = Следующие 2 байта.
	   *   d = Следующий байт.
	   *   e = Следующий байт.
	   *   f = Следующий байт.
	   *   g = Следующий байт.
	   *   h = Следующий байт.
	   *   i = Следующий байт.
	   *   j = Следующий байт.
	   *   k = Следующий байт.
	   * Возвращает: Результирующий ГУИД.
	   */

	 static ГУИД opCall(бцел a, бкрат b, бкрат c, ббайт d, ббайт e, ббайт f, ббайт g, ббайт h, ббайт i, ббайт j, ббайт k) {
		ГУИД сам;
		сам.a = a, сам.b = b, сам.c = c, сам.d = d, сам.e = e, сам.f = f, сам.g = g, сам.h = h, сам.i = i, сам.j = j, сам.k = k;
		return сам;
	  }
	  
	  static ГУИД opCall(бцел a, бкрат b, бкрат c, ббайт[] d) {
		if (d.length != 8)
		  ошибка("Байтовый массив под ГУИД должен иметь размер 8.");

		ГУИД сам;
		сам.a = a, сам.b = b, сам.c = c, сам.d = d[0], сам.e = d[1], сам.f = d[2], сам.g = d[3], сам.h = d[4], сам.i = d[5], сам.j = d[6], сам.k = d[7];
		return сам;
	  }
	  
	  static ГУИД opCall(ткст s) {
		
		бдол разбор(ткст s) {

		  бул гекс8Цел(сим c, out бцел результат) {
			if (c >= '0' && c <= '9') результат = c - '0';
			else if (c >= 'A' && c <= 'F') результат = c - 'A' + 10;
			else if (c >= 'a' && c <= 'f') результат = c - 'a' + 10;
			else результат = -1;
			return (cast(цел)результат >= 0);
		  }

		  бдол результат;
		  бцел значение, индекс;
		  while (индекс < s.length && гекс8Цел(s[индекс], значение)) {
			результат = результат * 16 + значение;
			индекс++;
		  }
		  return результат;
		}
		s = убери(s);

		if (s[0] == '{') {
		  s = s[1 .. $];
		  if (s[$ - 1] == '}')
			s = s[0 .. $ - 1];
		}

		if (s[0] == '[') {
		  s = s[1 .. $];
		  if (s[$ - 1] == ']')
			s = s[0 .. $ - 1];
		}

		if (найди(s, '-') == -1)
		  ошибка("Нераспознанный формат ГУИД.");

		ГУИД сам;
		сам.a = cast(бцел)разбор(s[0 .. 8]);
		сам.b = cast(бкрат)разбор(s[9 .. 13]);
		сам.c = cast(бкрат)разбор(s[14 .. 18]);
		бцел m = cast(бцел)разбор(s[19 .. 23]);
		сам.d = cast(ббайт)(m >> 8);
		сам.e = cast(ббайт)m;
		бдол n = разбор(s[24 .. $]);
		m = cast(бцел)(n >> 32);
		сам.f = cast(ббайт)(m >> 8);
		сам.g = cast(ббайт)m;
		m = cast(бцел)n;
		сам.h = cast(ббайт)(m >> 24);
		сам.i = cast(ббайт)(m >> 16);
		сам.j = cast(ббайт)(m >> 8);
		сам.k = cast(ббайт)m;
		return сам;
	  }

 
	  /**
	   * Инициализует новый экземпляр структуры ГУИД.
	   */
	  static ГУИД создай() {
		ГУИД сам;

		цел хрез = СоздайГуидКо(сам);
		if (НЕУД(хрез))
		  throw исклКомРез(хрез);

		return сам;
	  }

	  /**
	   * Возвращает значение, которое показывает, одинаковы ли значения у двух экземпляров.
	   * Параметры: другой = ГУИД, сравниваемый с данным экземпляром.
	   * Возвращает: да, если другой равен этому экземпляру; otherwise, false.
	   */
	  бул opEquals(ГУИД другой) {
		if(a == другой.a
		  && b == другой.b
		  && c == другой.c
		  && d == другой.d
		  && e == другой.e
		  && f == другой.f
		  && g == другой.g
		  && h == другой.h
		  && i == другой.i
		  && j == другой.j
		  && k == другой.k) return да;
		  return нет;
	  }

	  /**
	   * Сравнивает данный экземпляр с указанным ГУИДом и возвращает указание на их относительные значения.
	   * Параметры: другой = ГУИД, сравниваемый с данным экземпляром.
	   * Возвращает: Число, показывающее относительные значения этого и другого экземпляров.
	   */
	  цел opCmp(ГУИД другой) {
		if (a != другой.a)
		  return (a < другой.a) ? -1 : 1;
		if (b != другой.b)
		  return (b < другой.b) ? -1 : 1;
		if (c != другой.c)
		  return (c < другой.c) ? -1 : 1;
		if (d != другой.d)
		  return (d < другой.d) ? -1 : 1;
		if (e != другой.e)
		  return (e < другой.e) ? -1 : 1;
		if (f != другой.f)
		  return (f < другой.f) ? -1 : 1;
		if (g != другой.g)
		  return (g < другой.g) ? -1 : 1;
		if (h != другой.h)
		  return (h < другой.h) ? -1 : 1;
		if (i != другой.i)
		  return (i < другой.i) ? -1 : 1;
		if (j != другой.j)
		  return (j < другой.j) ? -1 : 1;
		if (k != другой.k)
		  return (k < другой.k) ? -1 : 1;
		return 0;
	  }

	  /**
		* Возвращает текстовое представление значения данного экземпляра в реестровом формате.
		* Возвращает: Текст, форматированный по образцу {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx},
		*где ГУИД представлен серией прописных шестнадцатиричных цифр, сгруппированных по
		* 8, 4, 4, 4 и 12, и разделенных дефисами.
	   */
		  
	  ткст вТкст() {
		return this.вТкст("D");
	  }

	  /// ditto
	  ткст вТкст(ткст формат) {

		проц гекс8Ткст(ref сим[] s, ref бцел индекс, бцел a, бцел b) {

		  сим гекс8сим(бцел a) {
			a = a & 0x0F;
			return cast(сим)((a > 9) ? a - 10 + 0x61 : a + 0x30);
		  }

		  s[индекс++] = гекс8сим(a >> 4);
		  s[индекс++] = гекс8сим(a);
		  s[индекс++] = гекс8сим(b >> 4);
		  s[индекс++] = гекс8сим(b);
		}

		if (формат == пусто)
		  формат = "D";

		сим[] s;
		бцел индекс = 0;
		if (формат == "D" || формат == "d")
		  s = new сим[36];
		else if (формат == "P" || формат == "p") {
		  s = new сим[38];
		  s[индекс++] = '{';
		  s[$ - 1] = '}';
		}

		гекс8Ткст(s, индекс, a >> 24, a >> 16);
		гекс8Ткст(s, индекс, a >> 8, a);
		s[индекс++] = '-';
		гекс8Ткст(s, индекс, b >> 8, b);
		s[индекс++] = '-';
		гекс8Ткст(s, индекс, c >> 8, c);
		s[индекс++] = '-';
		гекс8Ткст(s, индекс, d, e);
		s[индекс++] = '-';
		гекс8Ткст(s, индекс, f, g);
		гекс8Ткст(s, индекс, h, i);
		гекс8Ткст(s, индекс, j, k);

		return cast(ткст)s;
	  }

	  /**
	   * Выводит хеш-код для данного экземпляра.
	   */
	  бцел вХэш()
	  {
		return a ^ ((b >> 16) | c) ^ ((f << 24) | k);
	  }
	  

	}
	alias ГУИД ИИД, КЛСИД;

	struct БЕЗОПМАС
	 {
	 
	 export:

	  бкрат члоИзм;
	  бкрат  фичи;
	  бцел размЭлта;
	  бцел счБлк;
	  ук укНаДан;
	  ГРАНБЕЗОПМАСА[1] рбмгран;
	  
	  static БЕЗОПМАС* opCall(T)(T[] массив) {
		auto предел = ГРАНБЕЗОПМАСА(массив.length);
		auto sa = СоздайБезопмас(ТипВариант!(T), 1, &предел);

		static if (is(T : ткст)) alias шим* Тип;
		else                       alias T Тип;

		Тип* данные;
		
		ДоступКДаннымБезопмаса(sa, возврзнач(данные));
		for (auto i = 0; i < массив.length; i++) {
		  static if (is(T : ткст)) данные[i] = массив[i].вБткст();
		  else                       данные[i] = массив[i];
		}
		ОтступОтДаныхБезопмаса(sa);

		return sa;
	  }

	  
	  T[] вМассив(T)() {
		цел верхГран, нижГран;
		ДайВПределБезопмаса(this, 1, верхГран);
		ДайНПределБезопмаса(this, 1, нижГран);
		цел посчитай = верхГран - нижГран + 1;

		if (посчитай == 0) return пусто;

		T[] результат = new T[посчитай];

		static if (is(T : ткст)) alias шим* Тип;
		else                       alias T Тип;

		Тип* данные;
		ДоступКДаннымБезопмаса(this, возврзнач(данные));
		for (auto i = нижГран; i < верхГран + 1; i++) {
		  static if (is(T : ткст)) результат[i] = бткстВТкст(данные[i]);
		  else                       результат[i] = данные[i];
		}
		ОтступОтДаныхБезопмаса(this);

		return результат;
	  }

	  проц удали() {   УничтожьБезопмас(this);    }   
	  проц блокируй() {    БлокируйБезопмас(this);    } 
	  проц разблокируй() {   РазблокируйБезопмас(this);  }  
	  проц длина(цел значение)
		{
		auto предел = ГРАНБЕЗОПМАСА(значение);
			ИзмениГраницуБезопмаса(this, &предел);
		
		}
	  цел длина()
		{
		цел верхГран, нижГран;
		  ДайВПределБезопмаса(this, 1, верхГран);
		  ДайНПределБезопмаса(this, 1, нижГран);    
		return верхГран - нижГран + 1;
		}

	  
	}

	 /**
	 * Представляет десятичное число в пределах от положительного 79,228,162,514,264,337,593,543,950,335 до отрицательного 79,228,162,514,264,337,593,543,950,335.
	 */
	struct ДЕСЯТОК {
	
	export:

	  бкрат резерв;
	  ббайт шкала;
	  ббайт знак;
	  бцел Старш32;
	  бцел Младш32;
	  бцел Средн32;

	  /// Represents the smallest possible value.
	  static ДЕСЯТОК мин = { 0, 0, ОТРИЦ_ДЕСЯТОК, бцел.max, бцел.max, бцел.max };
	  /// Represents the largest possible value.
	  static ДЕСЯТОК макс = { 0, 0, 0, бцел.max, бцел.max, бцел.max };
	  /// Represents -1.
	  static ДЕСЯТОК минусОдин = { 0, 0, ОТРИЦ_ДЕСЯТОК, 0, 1, 0 };
	  /// Represents 0.
	  static ДЕСЯТОК ноль = { 0, 0, 0, 0, 0, 0 };
	  /// Represents 1.
	  static ДЕСЯТОК один = { 0, 0, 0, 0, 1, 0 };

	  /// Инициализует новый экземпляр.
	  static ДЕСЯТОК opCall(T)(T значение) {
		ДЕСЯТОК сам;

		static if (is(T == бцел))
		  ДесВарИзБцел(значение, сам);
		else static if (is(T == цел))
		  ДесВарИзЦел(значение, сам);
		else static if (is(T == бдол))
		  ДесВарИзБдол(значение, сам);
		else static if (is(T == дол))
		  ДесВарИзДол(значение, сам);
		else static if (is(T == плав))
		  ДесВарИзПлав(значение, сам);
		else static if (is(T == дво))
		  ДесВарИзДво(значение, сам);
		else static assert(нет);

		return сам;
	  }

	  /// ditto
	  static ДЕСЯТОК opCall(T = проц)(бцел lo, бцел mid, бцел hi, бул isNegative, ббайт шкала) {
		ДЕСЯТОК сам;
		сам.Старш32 = hi, сам.Средн32 = mid, сам.Младш32 = lo, сам.шкала = шкала, сам.знак = isNegative ? ОТРИЦ_ДЕСЯТОК : 0;
		return сам;
	  }

	  /// Преобразует строковое представление числа в его ДЕСЯТИЧный эквивалент.
	  static ДЕСЯТОК разбор(ткст s) {
		ДЕСЯТОК d;
		ДесВарИзТкстш0(stdrus.вЮ16н(s),  ДайЛокальНити(), 0, d);
		return d;
	  }

	  static ДЕСЯТОК абс(ДЕСЯТОК d) {
		ДЕСЯТОК результат;
		ДесВарАбс(d, результат);
		return результат;
	  }

	  /// Округляет значение до ближайшего или специфичного числа.
	  static ДЕСЯТОК округли(ДЕСЯТОК d, цел десятки = 0) {
		ДЕСЯТОК результат;
		ДесВарОкругли(d, десятки, результат);
		return результат;
	  }

	  /// Округляет значение до ближайшего к отрицательной бесконечности целого.
	  static ДЕСЯТОК кОтрБеск(ДЕСЯТОК d) {
		ДЕСЯТОК результат;
		ДесВарИнт(d, результат);
		return результат;
	  }

	  /// Возвращает интегральные числа значения.
	  static ДЕСЯТОК сократи(ДЕСЯТОК d) {
		ДЕСЯТОК результат;
	   ДесВарФиксируй(d, результат);
		return результат;
	  }

	  /// Вычисляет остаток после деления двух значений.
	  static ДЕСЯТОК остаток(ДЕСЯТОК d1, ДЕСЯТОК d2) {
		if (абс(d1) < абс(d2))
		  return d1;

		d1 -= d2;

		ДЕСЯТОК dr = сократи(d1 / d2);
		ДЕСЯТОК m = dr * d2;
		ДЕСЯТОК r = d1 - m;

		if (d1.знак != r.знак && r != cast(ДЕСЯТОК)0)
		  r += d2;

		return r;
	  }

	  /// Складывает два значения.
	  static ДЕСЯТОК сложи(ДЕСЯТОК d1, ДЕСЯТОК d2) {
		ДЕСЯТОК результат;
		ДесВарСложи(d1, d2, результат);
		return результат;
	  }

	  /// Отнимает одно значение от другого.
	  static ДЕСЯТОК отними(ДЕСЯТОК d1, ДЕСЯТОК d2) {
		ДЕСЯТОК результат;
		ДесВарОтними(d1, d2, результат);
		return результат;
	  }

	  /// Перемножает два значения.
	  static ДЕСЯТОК умножь(ДЕСЯТОК d1, ДЕСЯТОК d2) {
		ДЕСЯТОК результат;
		ДесВарУмножь(d1, d2, результат);
		return результат;
	  }

	  /// Делит два значения.
	  static ДЕСЯТОК раздели(ДЕСЯТОК d1, ДЕСЯТОК d2) {
		ДЕСЯТОК результат;
		ДесВарДели(d1, d2, результат);
		return результат;
	  }

	  /// Возвращает результат умножения значения на -1.
	  static ДЕСЯТОК вОтриц(ДЕСЯТОК d) {
		ДЕСЯТОК результат;
		ДесВарОтриц(&d, результат);
		return результат;
	  }

	  бцел вХэш() {
		дво d;
		ДвоВарИзДес(this, d);
		if (d == 0)
		  return 0;
		return (cast(цел*)&d)[0] ^ (cast(цел*)&d)[1];
	  }

	  /// Преобразует численное значение данного экземпляра в эквивалентное текстовое представление.
	  ткст вТкст() {
		шим* str;
		if (БткстВарИзДес(this,  ДайЛокальНити(), 0, str) != ПКомРез.Да)
		  return пусто;
		return бткстВТкст(str);
	  }

	  /// Сравнивает два значения.
	  static цел сравни(ДЕСЯТОК d1, ДЕСЯТОК d2) {
		return ДесВарСравни(d1, d2) - 1;
	  }

	  /// Сравнивает данный экземпляр с указанным экземпляром.
	  цел сравни_с(ДЕСЯТОК значение) {
		version(D_Version2) {
		  return сравни(this, значение);
		}
		else {
		  return сравни(*this, значение);
		}
	  }

	  цел opCmp(ДЕСЯТОК d) {      return сравни(*this, d);  }

	  /// Возвращает значение, определяющее являются ли два экземпляра одинаковыми по значению.
	  static бул равны(ДЕСЯТОК d1, ДЕСЯТОК d2) {
		return сравни(d1, d2) == 0;
	  }

	  /// Returns a значение indicating whether this экземпляр and a specified экземпляр represent the same _value.
	  бул равны(ДЕСЯТОК значение) {      return сравни(*this, значение) == 0;    }

	  бул opEquals(ДЕСЯТОК d) {    return сравни(*this, d) == 0;  }

	  ДЕСЯТОК opAdd(ДЕСЯТОК d) {
			ДЕСЯТОК результат; 
			ДесВарСложи(*this, d, результат); 
		  return результат; 
		  } 
		 проц opAddAssign(ДЕСЯТОК d) { 
		   ДесВарСложи(*this, d, *this);
		 }
	  

	 ДЕСЯТОК opSub(ДЕСЯТОК d) {
			ДЕСЯТОК результат; 
			ДесВарОтними(*this, d, результат); 
		  return результат; 
		  } 
		 проц opSubAssign(ДЕСЯТОК d) { 
		   ДесВарОтними(*this, d, *this);
		 }
	  
	  
	   ДЕСЯТОК opMul(ДЕСЯТОК d) {
			ДЕСЯТОК результат; 
			ДесВарУмножь(*this, d, результат); 
		  return результат; 
		  } 
		 проц opMulAssign(ДЕСЯТОК d) { 
		   ДесВарУмножь(*this, d, *this);
		 }
	  
	  
	   ДЕСЯТОК opDiv(ДЕСЯТОК d) {
			ДЕСЯТОК результат; 
			ДесВарДели(*this, d, результат); 
		  return результат; 
		  } 
		 проц opDivAssign(ДЕСЯТОК d) { 
		   ДесВарДели(*this, d, *this);
		 }
	  
	 
	  ДЕСЯТОК opMod(ДЕСЯТОК d) {  return остаток(*this, d);  }

	  ДЕСЯТОК opNeg() 
	  {
		ДЕСЯТОК результат;
		ДесВарОтриц(this, результат);
		return результат;
	  }

	  ДЕСЯТОК opPos() {   return *this;  }

	  ДЕСЯТОК opPostInc() {    return *this = *this + ДЕСЯТОК(1);  }

	  ДЕСЯТОК opPostDec() {     return *this = *this - ДЕСЯТОК(1);  }

	}  

	/**
	 * Контейнер для множества различных типов.
	 * Примеры:
	 * ---
	 * ВАРИАНТ var = 10;     // Экземпляр содержит ПТипВарианта.Ц4.
	 * var = "Hello, World"; // Экземпляр теперь содержит ПТипВарианта.БинТекст.
	 * var = 234.5;          // Экземпляр теперь содержит ПТипВарианта.Р8.
	 * ---
	 */


struct ВАРИАНТ
	 {
	 export:
	
	  union {
		struct {
		  /// Описывает тип данного экземпляра.
		  бкрат вт;
		  бкрат Резерв1;
		  бкрат Резерв2;
		  бкрат Резерв3;
		  union {
			дол долЗнач;
			цел целЗнач;
			ббайт ббайтЗнач;
			крат кратЗнач;
			плав плавЗнач;
			дво двоЗнач;
			БУЛ_ВАРИАНТ булЗнач;
			цел скод;
			дол долЗнач2;
			дво дата;
			шим* бстрЗнач;
			Инкогнито инкЗнач;
			ИДиспетчер депЗнач;
			БЕЗОПМАС* массив;
			ббайт* уббайтЗнач;
			крат* укратЗнач;
			цел* уцелЗнач;
			дол* удолЗнач;
			плав* уплавЗнач;
			дво* удвоЗнач;
			БУЛ_ВАРИАНТ* убулЗнач;
			цел* ускод;
			дол* удолЗнач2;
			дво* удата;
			шим** убстрЗнач;
			Инкогнито* уинкЗнач;
			ИДиспетчер* удепЗнач;
			БЕЗОПМАС** умассив;
			ВАРИАНТ* уварЗнач;
			ук байреф;
			байт байтЗнач;
			бкрат бкратЗнач;
			бцел бцелЗнач;
			бдол бдолЗнач;
			ДЕСЯТОК* удесЗнач;
			байт* убайтЗнач;
			крат* укратЗнач2;
			бцел* убцелЗнач;
			бдол* убдолЗнач;
			struct {
			  ук запись;
			  ИИнфОЗаписи инфОЗап;
			}
		  }
		}
		ДЕСЯТОК десЗнач;
	  }

	  /// Представляет значение _missing.
	  static ВАРИАНТ Отсутствует = { вт: ПТипВарианта.Ошибка, скод: ПОшДисп.ПарамНеНайден };

	  /// Представляет значение _nothing.
	  static ВАРИАНТ Ничто = { вт: ПТипВарианта.Диспетчер, депЗнач: пусто };

	  /// Представляет значение _null.
	  static ВАРИАНТ Пусто = { вт: ПТипВарианта.Пусто };


		/**
		 * Инициализует новый экземпляр с помощью указанных _значения и _типа.
		 * Параметры:
		 *   значение = Значение одного из приемлемых типов.
		 *   тип = бкрат, идентифицирующий тип значения.
		 * Возвращает: Итоговый ВАРИАНТ.
		 */
		static ВАРИАНТ opCall(T)(T значение, бкрат тип = ТипВариант!(T)) 
		{
		  ВАРИАНТ сам;
		  инициализуй(сам, значение, тип);
		  return сам;
		}
	  

	  private static проц инициализуй(T)(ref ВАРИАНТ ret, T значение, бкрат тип = ТипВариант!(T))
	  {
		static if (is(T E == enum))
		{
		  инициализуй(ret, cast(E) значение, тип);
		}
		else
		{
		  ret = cast(ВАРИАНТ) значение;
		  if (тип != ret.вт)
			ИзмениТипВариантаДоп(ret, ret,  ДайЛокальНити(), ПВар.АльфаБул, тип);
		}
	  }

	  проц opAssign(дол значение)
	  {
		if (!пуст_ли) сотри();
		долЗнач = значение;
		вт = ПТипВарианта.Ц8;
	  }

	  проц opAssign(цел значение)
	  {
		if (!пуст_ли) сотри();
		целЗнач = значение;
		вт = ПТипВарианта.Ц4;
	  }

	  проц opAssign(ббайт значение)
	  {
		if (!пуст_ли) сотри();
		ббайтЗнач = значение;
		вт = ПТипВарианта.Бц1;
	  }

	  проц opAssign(крат значение)
	  {
		if (!пуст_ли) сотри();
		кратЗнач = значение;
		вт = ПТипВарианта.Ц2;
	  }

	  проц opAssign(плав значение)
	  {
		if (!пуст_ли) сотри();
		плавЗнач = значение;
		вт = ПТипВарианта.Р4;
	  }

	  проц opAssign(дво значение)
	  {
		if (!пуст_ли) сотри();
		двоЗнач = значение;
		вт = ПТипВарианта.Р8;
	  }

	  проц opAssign(бул значение)
	  {
		if (!пуст_ли) сотри();
		булЗнач = значение ? ДА_ВАРИАНТ :НЕТ_ВАРИАНТ;
		вт = ПТипВарианта.Бул;
	  }

	  проц opAssign(БУЛ_ВАРИАНТ значение)
	  {
		if (!пуст_ли) сотри();
		булЗнач = значение;
		вт = ПТипВарианта.Бул;
	  }

	  проц opAssign(ткст значение)
	  {
		if (!пуст_ли) сотри();
		бстрЗнач = вБткст(значение);
		вт = ПТипВарианта.БинТекст;
	  }

	  проц opAssign(Инкогнито значение)
	  {
		if (!пуст_ли) сотри();
		if (auto disp = com_cast!(ИДиспетчер)(значение)) 
		{
		  депЗнач = disp;
		  вт = ПТипВарианта.Диспетчер;
		}
		else 
		{
		  значение.AddRef();
		  инкЗнач = значение;
		  вт = ПТипВарианта.Инкогнито;
		}
	  }

	  проц opAssign(БЕЗОПМАС* значение)
	  {
		if (!пуст_ли) сотри();
		массив = значение;
		бкрат тип;
		ДайВартипБезопмаса(значение, тип);
		вт = ПТипВарианта.Массив | тип;
	  }

	  проц opAssign(байт значение)
	  {
		if (!пуст_ли) сотри();
		байтЗнач = значение;
		вт = ПТипВарианта.Ц1;
	  }

	  проц opAssign(бкрат значение)
	  {
		if (!пуст_ли) сотри();
		бкратЗнач = значение;
		вт = ПТипВарианта.Бц2;
	  }

	  проц opAssign(бцел значение)
	  {
		if (!пуст_ли) сотри();
		бцелЗнач = значение;
		вт = ПТипВарианта.Бц4;
	  }

	  проц opAssign(бдол значение)
	  {
		if (!пуст_ли) сотри();
		бдолЗнач = значение;
		вт = ПТипВарианта.Бц4;
	  }

	  проц opAssign(ДЕСЯТОК значение)
	  {
		if (!пуст_ли) сотри();
		десЗнач = значение;
		вт = ПТипВарианта.ДЕСЯТОК;
	  }

		/*проц opAssign(ВАРИАНТ* значение) {
		  if (!пуст_ли) сотри();
		  уварЗнач = значение;
		  вт = ПТипВарианта.ПоСсылке | ПТипВарианта.ВАРИАНТ;
		}*/
	  

	  проц opAssign(ббайт[] значение)
	  {
		if (!пуст_ли) сотри();
		массив = БЕЗОПМАС(значение);
		вт = ПТипВарианта.Массив | ПТипВарианта.Бц1;
	  }

	  /**
	   * Стирает значение данного экземпляра и высвобождает связанную с ним память.
	   * See_Also: $(LINK2 http://msdn2.microsoft.com/en-us/library/ms221165.aspx, VariantClear).
	   */
	  проц сотри() 
	  {
		if (КОМАктивен && !(нулл_ли || пуст_ли))
				СотриВариант(*this);
		  
	  }

	  /**
	   * Копирует данный экземпляр в целевое значение.
	   * Параметры: dest = Вариант, в который копируется.
	   */
	  проц копируй_в(out ВАРИАНТ dest) {   КопируйВариант(dest, *this);  }

	  /**
	   * Преобразует вариант из одного типа в другой.
	   * Параметры: новТип = Тип для изменения.
	   */
	  ВАРИАНТ измениТип(бкрат новТип)
	  {
		ВАРИАНТ dest;
		ИзмениТипВариантаДоп(dest, *this,  ДайЛокальНити(), ПВар.АльфаБул, новТип);    
		return dest;
	  }

	  /**
	   * Преобразует содержащееся в данном экземпле значение в текст.
	   * Возвращает: Текстовое представление содержащегося в экземпле значения.
	   */
	  ткст вТкст() 
	  {
		if (нулл_ли || пуст_ли)
		  return пусто;

		if (вт == ПТипВарианта.БинТекст)
		  return бткстВТкст(бстрЗнач);

		цел хрез;
		ВАРИАНТ temp;
		хрез = ИзмениТипВариантаДоп(temp, *this,  ДайЛокальНити(), ПВар.АльфаБул, ПТипВарианта.БинТекст);    
		if (УД(хрез))
		  return бткстВТкст(temp.бстрЗнач);

		return пусто;
	  }
	  
	  /**
	   * Возвращает _value, заключённое в этом экземпляре.
	   */
	  V значение(V)()
	  {
		static if (is(V == дол)) return долЗнач;
		else static if (is(V == цел)) return целЗнач;
		else static if (is(V == ббайт)) return ббайтЗнач;
		else static if (is(V == крат)) return кратЗнач;
		else static if (is(V == плав)) return плавЗнач;
		else static if (is(V == дво)) return двоЗнач;
		else static if (is(V == бул)) return (булЗнач == ДА_ВАРИАНТ) ? да : нет;
		else static if (is(V == БУЛ_ВАРИАНТ)) return булЗнач;
		else static if (is(V : ткст)) return бткстВТкст(бстрЗнач);
		else static if (is(V == шим*)) return бстрЗнач;
		else static if (is(V : ИДиспетчер)) return cast(V)депЗнач;
		else static if (is(V : Инкогнито)) return cast(V)инкЗнач;
		else static if (is(V == БЕЗОПМАС*)) return массив;
		else static if (массив_ли!(V)) return массив.вМассив!(typeof(*V))();
		else static if (is(V == ВАРИАНТ*)) return уварЗнач;
		else static if (is(V : Объект)) return cast(V)байреф;
		else static if (указатель_ли!(V)) return cast(V)байреф;
		else static if (is(V == байт)) return байтЗнач;
		else static if (is(V == бкрат)) return бкратЗнач;
		else static if (is(V == бцел)) return бцелЗнач;
		else static if (is(V == бдол)) return бдолЗнач;
		else static if (is(V == ДЕСЯТОК)) return десЗнач;
		else static assert(нет, stdrus.вЮ8(cast(ткст)"'" ~ V.stringof ~ "' не относится к допустимым типам."));
	  }

	  /**
	   * Определяет, пуст ли данный экземпляр.
	   */
	  бул пуст_ли()
	  {
		return (вт == ПТипВарианта.Пустой);
	  }

	  /**
	   * Определяет, является ли экземпляр _null.
	   */
	  бул нулл_ли()
	  {
		return (вт == ПТипВарианта.Пусто);
	  }

	  /**
	   * Определяет, является ли экземпляр Nothing.
	   */
	  бул ничто_ли() 
	  {
		return (вт == ПТипВарианта.Диспетчер && депЗнач is пусто)
		  || (вт == ПТипВарианта.Инкогнито && инкЗнач is пусто);
	  }

	  цел opCmp(ВАРИАНТ тот) {  return СравниВар(*this, тот,  ДайЛокальНити(), 0) - 1;  }

	  бул opEquals(ВАРИАНТ тот) {    return opCmp(тот) == 0;  }

	  ВАРИАНТ opCat(ВАРИАНТ тот) { 
			ВАРИАНТ результат; 
			СоединиВар(*this, тот, результат); 
			return результат; 
		  } 
	   проц opCatAssign(ВАРИАНТ тот) { 
		   if (!пуст_ли) сотри(); 
			СоединиВар(*this, тот, *this);
		  }

	  ВАРИАНТ opSub(ВАРИАНТ тот) { 
			ВАРИАНТ результат; 
			ОтнимиВар(*this, тот, результат); 
			return результат; 
		  } 
	   проц opSubAssign(ВАРИАНТ тот) { 
		   if (!пуст_ли) сотри(); 
			ОтнимиВар(*this, тот, *this);
		  }  
	   
		ВАРИАНТ opDiv(ВАРИАНТ тот) { 
			ВАРИАНТ результат; 
			ДелиВар(*this, тот, результат); 
			return результат; 
		  } 
	   проц opDivAssign(ВАРИАНТ тот) { 
		   if (!пуст_ли) сотри(); 
			ДелиВар(*this, тот, *this);
		  }
	 
		ВАРИАНТ opMul(ВАРИАНТ тот) { 
			ВАРИАНТ результат; 
			УмножьВар(*this, тот, результат); 
			return результат; 
		  } 
	   проц opMulAssign(ВАРИАНТ тот) { 
		   if (!пуст_ли) сотри(); 
			УмножьВар(*this, тот, *this);
		  }
		ВАРИАНТ opMod(ВАРИАНТ тот) { 
			ВАРИАНТ результат; 
			МодВар(*this, тот, результат); 
			return результат; 
		  } 
	   проц opModAssign(ВАРИАНТ тот) { 
		   if (!пуст_ли) сотри(); 
			МодВар(*this, тот, *this);
		  }
	   
		ВАРИАНТ opAnd(ВАРИАНТ тот) { 
			ВАРИАНТ результат; 
			ИВар(*this, тот, результат); 
			return результат; 
		  } 
	   проц opAndAssign(ВАРИАНТ тот) { 
		   if (!пуст_ли) сотри(); 
			ИВар(*this, тот, *this);
		  }
	  
		ВАРИАНТ opOr(ВАРИАНТ тот) { 
			ВАРИАНТ результат; 
			ИлиВар(*this, тот, результат); 
			return результат; 
		  } 
	   проц opOrAssign(ВАРИАНТ тот) { 
		   if (!пуст_ли) сотри(); 
			ИлиВар(*this, тот, *this);
		  }
	   
		ВАРИАНТ opXor(ВАРИАНТ тот) { 
			ВАРИАНТ результат; 
			ИИлиВар(*this, тот, результат); 
			return результат; 
		  } 
	   проц opXorAssign(ВАРИАНТ тот) { 
		   if (!пуст_ли) сотри(); 
			ИИлиВар(*this, тот, *this);
		  }
	 
	}

}
////////////////////////////////////////////////////////////////

extern (Windows):

struct ОтладИнфОбАдр
 {
    align(1) {
        т_мера  адр;
        ткст0   файл;
        ткст0   функц;
        бкрат  строка;
    }
}

 struct КонтекстСледа
 {
        КОНТЕКСТ контекст;
        ук процесс;
        ук нить;
 }
 
 
////////////////////////////////////////////
struct OVERLAPPED
 {
    DWORD   Internal;
    DWORD   InternalHigh;
    DWORD   Offset;
    DWORD   OffsetHigh;
    HANDLE  hEvent;
}
alias OVERLAPPED* POVERLAPPED, LPOVERLAPPED;

	struct АСИНХРОН // OVERLAPPED 
	{
	бцел внутрен;
	бцел внутренСтарш;
	бцел смещение;
	бцел смещениеСтарш;
	ук событие;
	}
////////////////////////////////////////////////////////////////////	
	struct ЖАНРОВЫЙ_МАППИНГ //GENERIC_MAPPING
	{
	МАСКА_ДОСТУПА ЖанрЗап;
	МАСКА_ДОСТУПА ЖанрЧтен;
	МАСКА_ДОСТУПА ЖанрВып;
	МАСКА_ДОСТУПА ЖанрВсё;
	}	
	alias ЖАНРОВЫЙ_МАППИНГ ЖАНРМАП;
	
///////////////////////////////////////////////////////////////////	
struct SECURITY_ATTRIBUTES 
{
    DWORD nLength;
    void *lpSecurityDescriptor;
    BOOL bInheritHandle;
}

alias SECURITY_ATTRIBUTES* PSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES;

	struct АТРИБУТЫ_БЕЗОПАСНОСТИ //SECURITY_ATTRIBUTES
	{
	бцел длина;
	ук дескрБезоп;
	Бул наследДескр;//BOOL: 1 или 0.
	}
	alias АТРИБУТЫ_БЕЗОПАСНОСТИ БЕЗАТРЫ;	
///////////////////////////////////////////////////////////////	
struct ACL {
	BYTE AclRevision;
	BYTE Sbz1;
	WORD AclSize;
	WORD AceCount;
	WORD Sbz2;
}
alias ACL* PACL;

	struct СКД //ACL (Список Контроля Доступа (СКД))
	{
	  ббайт ревизияСКД;
	  ббайт Sbsz1;
	  бкрат размерСКД;
	  бкрат счётЗкд; //ACE - Запись Контроля Доступа (ЗКД)
	  бкрат Sbsz2;
	}	
////////////////////////////////////////////////////////

struct ACL_REVISION_INFORMATION {
	DWORD AclRevision;
}

	struct ИНФО_РЕВИЗИИ_СКД//ACL_REVISION_INFORMATION
	{
	бцел ревСкд;
	}
////////////////////////

struct ACL_SIZE_INFORMATION {
	DWORD AceCount;
	DWORD AclBytesInUse;
	DWORD AclBytesFree;
}

	struct ИНФО_РАЗМЕРА_СКД//ACL_SIZE_INFORMATION
	{
	бцел счётЗкд;
	бцел испБайтовСкд;
	бцел свобБайтовСкд;
	}
////////////////////////////////////
	struct ACE_HEADER {
	BYTE AceType;
	BYTE AceFlags;
	WORD AceSize;
}
alias ACE_HEADER* PACE_HEADER;

	struct ЗКДЗАГ//ACE_HEADER
	{
	ббайт типЗкд;
	ббайт флагиЗкд;
	бкрат размЗкд;
	}
/////////////////////////

struct ACCESS_ALLOWED_ACE {
	ACE_HEADER  Header;
	ACCESS_MASK Mask;
	DWORD       SidStart;
}
alias ACCESS_ALLOWED_ACE* PACCESS_ALLOWED_ACE;
	
	struct ЗКД_ДОСТУП_ОТКРЫТ//ACCESS_ALLOWED_ACE 
	{
	ЗКДЗАГ заг;
	МАСКА_ДОСТУПА маска;
	бцел начСид;
	}
//////////////////////
struct ACCESS_DENIED_ACE {
	ACE_HEADER  Header;
	ACCESS_MASK Mask;
	DWORD       SidStart;
}
alias ACCESS_DENIED_ACE* PACCESS_DENIED_ACE;

	struct ЗКД_ДОСТУП_ЗАКРЫТ//ACCESS_DENIED_ACE 
	{
	ЗКДЗАГ заг;
	МАСКА_ДОСТУПА маска;
	бцел начСид;
	}
//////////////////

	struct ЗКД_СИСТ_АУДИТ//SYSTEM_AUDIT_ACE
	{
	ЗКДЗАГ заг;
	МАСКА_ДОСТУПА маска;
	бцел начСид;
	}
	
	struct ЗКД_СИСТ_ТРЕВОГА //SYSTEM_ALARM_ACE
	{
	ЗКДЗАГ заг;
	МАСКА_ДОСТУПА маска;
	бцел начСид;
	}
	
	struct ЗКД_ОБЪЕКТ_ОТКРЫТ//ACCESS_ALLOWED_OBJECT_ACE
	{
	ЗКДЗАГ заг;
	МАСКА_ДОСТУПА маска;
	бцел флаги;
	ГУИД   типОбъекта;
	ГУИД унаследованныйТипОбъекта;
	бцел начСид;
	}
	
	struct ЗКД_ОБЪЕКТ_ЗАКРЫТ//ACCESS_DENIED_OBJECT_ACE
	{
	ЗКДЗАГ заг;
	МАСКА_ДОСТУПА маска;
	бцел флаги;
	ГУИД   типОбъекта;
	ГУИД унаследованныйТипОбъекта;
	бцел начСид;
	}
	
	struct ЗКД_ОБЪЕКТ_СИСТ_АУДИТА//SYSTEM_AUDIT_OBJECT_ACE 
	{
	ЗКДЗАГ заг;
	МАСКА_ДОСТУПА маска;
	бцел флаги;
	ГУИД   типОбъекта;
	ГУИД унаследованныйТипОбъекта;
	бцел начСид;
	}
	
	struct ЗКД_ОБЪЕКТ_СИСТ_ТРЕВОГИ//SYSTEM_ALARM_OBJECT_ACE 
	{
	ЗКДЗАГ заг;
	МАСКА_ДОСТУПА маска;
	бцел флаги;
	ГУИД   типОбъекта;
	ГУИД унаследованныйТипОбъекта;
	бцел начСид;
	}
	
	struct ДЕСКРИПТОР_БЕЗОПАСНОСТИ //SECURITY_DESCRIPTOR
	  {
		ббайт ревизия;
		ббайт Sbz1;
		УПР_ДЕСКРИПТОРА_БЕЗОПАСНОСТИ упр;
		УкБИД владелец;
		УкБИД группа;
		СКД* сскд;//SACL
		СКД* дскд;//DACL
	  }
	alias ДЕСКРИПТОР_БЕЗОПАСНОСТИ ДЕСКРБЕЗОП;	
/////////////////////////////////////////////////
struct FILETIME 
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
}
alias FILETIME* PFILETIME, LPFILETIME;

	struct ФВРЕМЯ //FILETIME
	{
	бцел датаВремяМладш;
	бцел датаВремяСтарш;
	}	

/////////////////////////////////////////////	
struct WIN32_FIND_DATA
 {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    char   cFileName[МАКС_ПУТЬ];
    char   cAlternateFileName[ 14 ];
}

	struct ПОИСК_ДАННЫХ_А //WIN32_FIND_DATA
	{
	бцел атрибутыФайла;
	ФВРЕМЯ времяСоздания;
	ФВРЕМЯ времяПоследнегоДоступа;
	ФВРЕМЯ времяПоследнейЗаписи;
	бцел размерФайлаВ;
	бцел размерФайлаН;
	бцел резерв0;
	бцел резерв1;
	сим имяФайла[sys.WinConsts.МАКС_ПУТЬ];
	сим альтИмяФайла[14];
	}
	alias ПОИСК_ДАННЫХ_А ПДАН_А;	

/////////////////////////////////	
struct WIN32_FIND_DATAW 
{
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    wchar  cFileName[МАКС_ПУТЬ];
    wchar  cAlternateFileName[ 14 ];
}
	struct ПОИСК_ДАННЫХ //WIN32_FIND_DATAW
	{
	бцел атрибутыФайла;
	ФВРЕМЯ времяСоздания;
	ФВРЕМЯ времяПоследнегоДоступа;
	ФВРЕМЯ времяПоследнейЗаписи;
	бцел размерФайлаВ;
	бцел размерФайлаН;
	бцел резерв0;
	бцел резерв1;
	шим имяФайла[МАКС_ПУТЬ];
	шим альтИмяФайла[14];
	}
	alias ПОИСК_ДАННЫХ ПДАН;	
/////////////////////////////////////////////

struct MEMORYSTATUS
 {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORD dwTotalPhys;
    DWORD dwAvailPhys;
    DWORD dwTotalPageFile;
    DWORD dwAvailPageFile;
    DWORD dwTotalVirtual;
    DWORD dwAvailVirtual;
}
alias MEMORYSTATUS *LPMEMORYSTATUS;

	struct СТАТУС_ПАМЯТИ //MEMORYSTATUS
	{
	бцел длина;
	бцел загрузкаПамяти;
	бцел всегоФиз;
	бцел всегоДоступнФиз;
	бцел всегоФайлСтр;
	бцел всегоДоступнФайлСтр;
	бцел всегоВиртуал;
	бцел всегоДоступнВиртуал;

	}
	alias СТАТУС_ПАМЯТИ СТАТПАМ;		
/////////////////////////////////////////////////////////
struct MEMORY_BASIC_INFORMATION
 {
    PVOID BaseAddress;
    PVOID AllocationBase;
    DWORD AllocationProtect;
    DWORD RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
}
alias MEMORY_BASIC_INFORMATION* PMEMORY_BASIC_INFORMATION;

	struct БАЗОВАЯ_ИНФ_О_ПАМЯТИ // MEMORY_BASIC_INFORMATION 
	{
		ук АдресБазы;
		ук БазаАллокации;
		бцел ПротектАллокации;
		бцел РазмерОбласти;
		бцел Состояние;
		бцел Протект;
		бцел Тип;
		
	}
	alias БАЗОВАЯ_ИНФ_О_ПАМЯТИ БАЗИОП;
//////////////////////////////////////////////////
struct _LIST_ENTRY
{
    _LIST_ENTRY *Flink;
    _LIST_ENTRY *Blink;
}
alias _LIST_ENTRY LIST_ENTRY;

	struct ЗАПИСЬ_СПИСКА //LIST_ENTRY
	{
		ЗАПИСЬ_СПИСКА *СЗук;//Flink - указание на следующщую запись
		ЗАПИСЬ_СПИСКА *ПЗук;//Blink - указание на предыдущую запись
	}
	alias ЗАПИСЬ_СПИСКА СПИСЗАП;
/////////////////////////////////////////////////////////////
struct _RTL_CRITICAL_SECTION_DEBUG
{
    WORD   Type;
    WORD   CreatorBackTraceIndex;
    _RTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Spare[ 2 ];
}
alias _RTL_CRITICAL_SECTION_DEBUG RTL_CRITICAL_SECTION_DEBUG;

	struct КРИТИЧЕСКАЯ_СЕКЦИЯ_ОТЛАДКА //RTL_CRITICAL_SECTION_DEBUG
	{

	бкрат Тип;
	бкрат ИндексОбратнойТрассировкиСоздателя;
	КРИТИЧЕСКАЯ_СЕКЦИЯ *КритическаяСекция;
	ЗАПИСЬ_СПИСКА СписокБлокировокПроцесса;
	бцел СчётЗаписей;
	бцел СчётРасхождений;
	бцел Свободно[2]; //Spare

	}
	alias КРИТИЧЕСКАЯ_СЕКЦИЯ_ОТЛАДКА КРИТСЕКЦОТЛ;
//////////////////////////////////////////////////////////////////////////////////
struct _RTL_CRITICAL_SECTION
{
    RTL_CRITICAL_SECTION_DEBUG * DebugInfo;

    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;        // from the thread's ClientId->UniqueThread
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;        // force size on 64-bit systems when packed
}
alias _RTL_CRITICAL_SECTION CRITICAL_SECTION;

	struct КРИТИЧЕСКАЯ_СЕКЦИЯ //_RTL_CRITICAL_SECTION,
	{

		КРИТИЧЕСКАЯ_СЕКЦИЯ_ОТЛАДКА *ОтладИнфо;
		цел СчётБлокировок;
		цел СчётРекурсий;
		ук ВладеющаяНить;
		ук СемафорБлокировок;
		бцел СпинСчёт;
		
	}
	alias КРИТИЧЕСКАЯ_СЕКЦИЯ КРИТСЕКЦ;
///////////////////////////////////////////////////////////////////////
struct SYSTEMTIME
{
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
}
	struct СИСТВРЕМЯ // SYSTEMTIME
	{

	бкрат год;
	бкрат месяц;
	бкрат день_недели;
	бкрат день;
	бкрат час;
	бкрат минута;
	бкрат секунда;
	бкрат миллисекунды;

	}
////////////////////////////////////
struct TIME_ZONE_INFORMATION
 {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
}
	struct ИНФ_О_ЧАСОВОМ_ПОЯСЕ
	{
	цел Разница;
	шим СтандартноеНазвание[32];
	СИСТВРЕМЯ СтандартнаяДата;
	цел СтандартнаяРазница;
	шим ИмяДейлайт [32];
	СИСТВРЕМЯ ДатаДейлайт;
	цел РазницаДейлайт;

	}
	alias ИНФ_О_ЧАСОВОМ_ПОЯСЕ ИНФОЧП;
///////////////////////////////////////////////////
struct FLOATING_SAVE_AREA 
{
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[80 ];
    DWORD   Cr0NpxState;
}
	struct ЗОНА_СОХР_ПЛАВ //FLOATING_SAVE_AREA
	{
	бцел СловоУправления;
	бцел СловоСостояния;
	бцел СловоТег;
	бцел СмещениеОшибки;
	бцел СелекторОшибки;
	бцел СмещениеДанных;
	бцел СелекторДанных;
	ббайт ЗонаРегистра[80];
	бцел  СостояниеCr0Npx;
	}
///////////////////////////////////////////////////////
struct CONTEXT
{

    DWORD ContextFlags;

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    FLOATING_SAVE_AREA FloatSave;

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;         
    DWORD   EFlags;    
    DWORD   Esp;
    DWORD   SegSs;
}
alias CONTEXT* PCONTEXT, LPCONTEXT;

	struct КОНТЕКСТ //CONTEXT
	{
	бцел ФлагиКонтекста;
	бцел Рд0;
	бцел Рд1;
	бцел Рд2;
	бцел Рд3;
	бцел Рд6;
	бцел Рд7;
	ЗОНА_СОХР_ПЛАВ ПлавСохр;
	бцел СегГс;
	бцел СегФс;
	бцел СегЕс;
	бцел СегДс;
		бцел   Edi;
		бцел   Esi;
		бцел   Ebx;
		бцел   Edx;
		бцел   Ecx;
		бцел   Eax;
		
		бцел   Ebp;
		бцел   Eip;
		бцел   SegCs;              
		бцел   EFlags;            
		бцел   Esp;
		бцел   SegSs;
		ббайт[512/*ПКонтекст.МаксПоддержРасш*/] РасширенныеРегистры;
	}
//////////////////////////////////////////
alias ПРежим_Адресации ADDRESS_MODE;
struct ADDRESS
{
    DWORD         Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
}
	struct АДРЕС //ADDRESS
	{
	бцел Смещение;
	бкрат Сегмент;
	ПРежим_Адресации  Режим;
	}
///////////////////////////////////////
struct ADDRESS64
{
    DWORD64       Offset;
    WORD          Segment;
    ADDRESS_MODE  Mode;
}	
	struct АДРЕС64 //ADDRESS64
	{
	бдол Смещение;
	бкрат Сегмент;
	ПРежим_Адресации  Режим;
	}
/////////////////////////////////////////////
struct KDHELP
{
    DWORD       Thread;
    DWORD       ThCallbackStack;
    DWORD       NextCallback;
    DWORD       FramePointer;
    DWORD       KiCallUserMode;
    DWORD       KeUserCallbackDispatcher;
    DWORD       SystemRangeStart;
    DWORD       ThCallbackBStore;
    DWORD       KiUserExceptionDispatcher;
    DWORD       StackBase;
    DWORD       StackLimit;
    DWORD[5]    Reserved;
}
	struct ПОМОЩЬОЯ //KDHELP
	// вспомогательная структура для отладчика уровня ядра
	{
    бцел       Нить;
	//Адрес объекта нити ядра, предоставленный в пакете WAIT_STATE_CHANGE.
    бцел       СтэкОбрВызова;
    бцел       СледщОбрВызов;
    бцел       УкНаКадр;
    бцел       АдрФцииЯдраВызПользРеж;
    бцел      АдрФцииДиспетчераПользРеж;
    бцел       МладшАдрУрЯдра;
    бцел       СмещКУкВозврХр;
    бцел       АдрФцииДиспетчераИсклПользРеж;
    бцел       ОваСтэка;
    бцел       ЛимитСтэка;
    бцел[5]    Резерв;
	}
//////////////////////////////////////////////////
struct KDHELP64
{
    DWORD64     Thread;
    DWORD       ThCallbackStack;
    DWORD       ThCallbackBStore;
    DWORD       NextCallback;
    DWORD       FramePointer;
    DWORD64     KiCallUserMode;
    DWORD64     KeUserCallbackDispatcher;
    DWORD64     SystemRangeStart;
    DWORD64     KiUserExceptionDispatcher;
    DWORD64     StackBase;
    DWORD64     StackLimit;
    DWORD64[5]  Reserved;
}
	struct ПОМОЩЬОЯ64 //KDHELP64
	{
    бдол     Нить;
    бцел       СтэкОбрВызова;
    бцел       СмещКУкВозврХр;
    бцел       СледщОбрВызов;
    бцел       УкНаКадр;
    бдол     АдрФцииЯдраВызПользРеж;
    бдол    АдрФцииДиспетчераПользРеж;
    бдол     МладшАдрУрЯдра;
    бдол     АдрФцииДиспетчераИсклПользРеж;
    бдол     ОваСтэка;
    бдол     ЛимитСтэка;
    бдол[5]  Резерв;
	}
///////////////////////////////////
struct STACKFRAME
{
    ADDRESS     AddrPC;
    ADDRESS     AddrReturn;
    ADDRESS     AddrFrame;
    ADDRESS     AddrStack;
    PVOID       FuncTableEntry;
    DWORD[4]    Params;
    BOOL        Far;
    BOOL        Virtual;
    DWORD[3]    Reserved;
    KDHELP      KdHelp;
    ADDRESS     AddrBStore;
}
	struct КАДР_СТЕКА //STACKFRAME
	{
    АДРЕС     АдрСчётчикаПрограммы; //x86:EIP, x64:RIP
    АДРЕС     АдрВозврата;
    АДРЕС     АдрКадра;//x86:EBP, x64:RBP
    АДРЕС     АдрСтэка;//x86:ESP, x64:RSP
    ук       ЗаписьТабФций;//_FPO_DATA struct
    бцел[4]    АргиФции;
    бул        Фар;//Far;
    бул        Вирт;//Virtual;
    бцел[3]    Резерв;//для ф-ции StackWalk64

    ПОМОЩЬОЯ      помОЯ;
    АДРЕС     АдрВозврХр;
	}
///////////////////////////
struct STACKFRAME64
{
    ADDRESS64   AddrPC;
    ADDRESS64   AddrReturn;
    ADDRESS64   AddrFrame;
    ADDRESS64   AddrStack;
    ADDRESS64   AddrBStore;
    PVOID       FuncTableEntry;
    DWORD64[4]  Params;
    BOOL        Far;
    BOOL        Virtual;
    DWORD64[3]  Reserved;
    KDHELP64    KdHelp;
}

	struct КАДР_СТЕКА64 //STACKFRAME64
	{
    АДРЕС64   АдрСчётчикаПрограммы;
    АДРЕС64   АдрВозврата;
    АДРЕС64   АдрКадра;
    АДРЕС64   АдрСтэка;
    АДРЕС64   АдрВозврХр;
    ук       ЗаписьТабФций;
    бдол[4]  АргиФции;
    бул        Фар;//Far;
    бул        Вирт;//Virtual;
    бдол[3]  Резерв;
    ПОМОЩЬОЯ64    помОЯ;
	}
////////////////////////////////
struct POINT
{
    LONG  x;
    LONG  y;
}
alias POINT* PPOINT, NPPOINT, LPPOINT;

	struct ТОЧКА //POINT
	{
	  цел x;//ш - координата ширины
	  цел y;//в - коордиата высоты
	  alias x ш;
	  alias y в;
	}
/////////////////////////////////////////////////////////
struct SIZE {
	LONG cx;
	LONG cy;
}
alias SIZE SIZEL;
alias SIZE* PSIZE, LPSIZE, PSIZEL, LPSIZEL;

	struct РАЗМЕР //SIZE
	{
	  цел cx;//дш - дельта координат ширины
	  цел cy;//дв - дельта координат высоты
	  alias cx дш;
	  alias cy дв;
	}
//////////////////////////////
struct RECT
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
}
alias RECT* PRECT, NPRECT, LPRECT;

	struct ПРЯМ  //RECT
	{
		цел    лево;
		цел    верх;
		цел    право;
		цел    низ;
	}
/////////////////////////////////////////////////
struct PAINTSTRUCT
 {
    HDC         hdc;
    BOOL        fErase;
    RECT        rcPaint;
    BOOL        fRestore;
    BOOL        fIncUpdate;
    BYTE        rgbReserved[32];
}
alias PAINTSTRUCT* PPAINTSTRUCT, NPPAINTSTRUCT, LPPAINTSTRUCT;

	struct РИССТРУКТ //PAINTSTRUCT
	{
		ук ку;
		бул cтереть;
		ПРЯМ        пкРис;
		бул восстановить;
		бул инкОбнов;
		ббайт        кзсРезерв[32];
	}	
////////////////////////////////////////////////
struct EXCEPTION_RECORD {
	DWORD ExceptionCode;
	DWORD ExceptionFlags;
	EXCEPTION_RECORD* ExceptionRecord;
	PVOID ExceptionAddress;
	DWORD NumberParameters;
	DWORD[МАКС_ИСКЛ_ПАРАМЫ] ExceptionInformation;
}
alias EXCEPTION_RECORD* PEXCEPTION_RECORD, LPEXCEPTION_RECORD;

	struct ЗАПОБИСКЛ //EXCEPTION_RECORD 
	{
	бцел кодИскл;
	бцел флагиИскл;
	ЗАПОБИСКЛ* запОбИскл;
	ук адрИскл;
	бцел парамыНомера;
	бцел[МАКС_ИСКЛ_ПАРАМЫ] исклИнфо;
	}
	alias ЗАПОБИСКЛ ЗАПИСЬ_ОБ_ИСКЛЮЧЕНИИ;
	
	/////////////////////////////////////
	struct EXCEPTION_POINTERS {
	PEXCEPTION_RECORD ExceptionRecord;
	PCONTEXT          ContextRecord;
}
alias EXCEPTION_POINTERS* PEXCEPTION_POINTERS, LPEXCEPTION_POINTERS;
	
	struct ИСКЛУКАЗАТЕЛИ//EXCEPTION_POINTERS
	{
	ЗАПОБИСКЛ* исклЗап;
	КОНТЕКСТ* контЗап;
	}
	alias ИСКЛУКАЗАТЕЛИ ИСКЛУКАЗЫ, УКАЗАТЕЛИ_НА_ИСКЛ;
	//////////////////////////////////////////
	struct protoent
{
	char* p_name;
	char** p_aliases;
	SHORT p_proto;
}
	struct протзап //protoent
	{
	ткст0 имя;
	ткст0* алиасы;
	крат прот;
	}
/////////////////////////
	struct servent
	{
	char* s_name;
	char** s_aliases;
	SHORT s_port;
	char* s_proto;
	}
	
	struct служзап //servent
	{
	ткст0 имя;
	ткст0* алиасы;
	крат порт;
	ткст0 прот;
	}
//////////////////////////
	struct hostent
	{
		char* h_name;
		char** h_aliases;
		int16_t h_addrtype;
		int16_t h_length;
		char** h_addr_list;
		
		
		char* h_addr()
		{
			return h_addr_list[0];
		}
	}
	  
struct хостзап //hostent
{
        сим* имя;
        сим** алиасы;
        version(Win32)
        {
                крат типадр;
                крат длина;
        }
        else version(BsdSockets)
        {
                цел типадр;
                цел длина;
        }
        сим** списадр;


        сим* адр()
        {
                return списадр[0];
        }
}
////////////////////////
	struct sockaddr
	{
	int16_t sa_family;               
	ubyte[14] sa_data;             
	}
	
	struct адрессок //sockaddr
	{
	крат семейство;
	ббайт[14] данные;
	}
///////////////////////
	struct sockaddr_in
	{
	int16_t sin_family = 2;//cast(int16_t) ПCемействоАдресов.ИНЕТ;
	uint16_t sin_port;
	in_addr sin_addr;
	ubyte[8] sin_zero;
	}
	
	struct адрессок_ин //sockaddr_in
	{
	крат семейство =cast(крат) ПСемействоАдресов.ИНЕТ;
	крат порт;
	адрес_ин адр;
	ббайт[8] иас_ноль;
	}
////////////////////////////
	struct sockaddr_in6
	{
	int16_t sin6_family = 23;//cast(int16_t) ПСемействоАдресов.ИНЕТ6;
	uint16_t sin6_port;
	uint32_t sin6_flowinfo;
	in6_addr sin6_addr;
	uint32_t sin6_scope_id;
	}
	
	struct адрессок_ин6 //sockaddr_in6
	{
		крат семейство = cast(крат) ПСемействоАдресов.ИНЕТ6;
		крат порт;
		бцел инфПоток;
		адрес_ин6 адр;
		бцел скопид;
	}
////////////////////////////
	union in_addr
{
	private union _S_un_t
	{
		private struct _S_un_b_t
		{
			uint8_t s_b1, s_b2, s_b3, s_b4;
		}
		_S_un_b_t S_un_b;
		
		private struct _S_un_w_t
		{
			uint16_t s_w1, s_w2;
		}
		_S_un_w_t S_un_w;
		
		uint32_t S_addr;
	}
	_S_un_t S_un;
	
	uint32_t s_addr;
	
	struct
	{
		uint8_t s_net, s_host;
		
		union
		{
			uint16_t s_imp;
			
			struct
			{
				uint8_t s_lh, s_impno;
			}
		}
	}
}
	
	union адрес_ин //in_addr
	{
		private union _С_ун_т
		{
			private struct _С_ун_б_т
			{
				ббайт с_б1, с_б2, с_б3, с_б4;
			}
			_С_ун_в_т С_ун_б;
			
			private struct _С_ун_в_т
			{
				бкрат с_в1, с_в2;
			}
			_С_ун_в_т С_ун_в;
			
			бцел С_адр;
		}
		_С_ун_т S_ун;
		
		бцел с_адр;
		
		struct
		{
			ббайт с_сеть, с_хост;
			
			union
			{
				бкрат с_имп;
				
				struct
				{
					ббайт с_лх, с_импнет;
				}
			}
		}
	}
/////////////////////////////
	union in6_addr
	{
	private union _in6_u_t
	{
		uint8_t[16] u6_addr8;
		uint16_t[8] u6_addr16;
		uint32_t[4] u6_addr32;
	}
	_in6_u_t in6_u;
	
	uint8_t[16] s6_addr8;
	uint16_t[8] s6_addr16;
	uint32_t[4] s6_addr32;
	
	alias s6_addr8 s6_addr;
	}

	union адрес_ин6 //in6_addr
	{
		private union _ин6_у_т
		{
			ббайт[16] у6_адр8;
			бкрат[8] у6_адр16;
			бцел[4] у6_адр32;
		}
		_ин6_у_т ин6_у;
		ббайт[16] с6_адр8;
		
		бкрат[8] с6_адр16;
		бцел[4] с6_адр32;
		
		alias с6_адр8 с6_адр;
	}
//////////////////////////
	struct timeval
{
	int32_t tv_sec;
	int32_t tv_usec;
}
	
	struct значврем //timeval
	{
	цел сек;//-унды;
	цел микросек;//-унды;
	alias сек секунды;
	alias микросек микросекунды;
	}
////////////////////////////
	struct fd_set
	{
	UINT fd_count;
	SOCKET[РАЗМНАБ_УД] fd_array;
	}
	
	struct набор_уд //fd_set
	{
		бцел счёт_уд;
		СОКЕТ[РАЗМНАБ_УД] массив_уд;
	}
	alias набор_уд уднаб;
//////////////////////////////
	struct linger
	{
	USHORT l_onoff;
	USHORT l_linger;
	}
	
	struct заминка //linger
	{
		бкрат вкл;
		бкрат время;
	}
/////////////////////////////
	struct addrinfo
	{
	int32_t ai_flags; 
	int32_t ai_family;
	int32_t ai_socktype;
	int32_t ai_protocol;
	size_t ai_addrlen;
	char* ai_canonname;
	sockaddr* ai_addr;
	addrinfo* ai_next;
	}

	struct адринфо //addrinfo
	{
		цел флаги; 
		цел семейство;
		цел типсок;
		цел протокол;
		т_мера длинадр;
		ткст0 канонимя;
		адрессок* адр;
		адринфо* следщ;
	}
/////////////////////////////////////
struct RGBQUAD
 {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
}
alias RGBQUAD* LPRGBQUAD;

	struct КВАДКЗС //RGBQUAD
	 {
			ббайт    кзсСиний;
			ббайт    кзсЗелёный;
			ббайт    кзсКрасный;
			ббайт    кзсРезерв;
	}
//////////////////////////////////////////////////
struct BITMAPINFOHEADER
{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
}
alias BITMAPINFOHEADER* LPBITMAPINFOHEADER, PBITMAPINFOHEADER;

	struct ИНФОБИТМАПЗАГ //BITMAPINFOHEADER
	{
			бцел      размер;
			цел       ширина;
			цел       высота;
			бкрат       плоскости;
			бкрат       счётБит;
			бцел      сжатие;
			бцел      размОбр;
			цел       горизПиксНаМетр;
			цел       вертПиксНаМетр;
			бцел      использУпр;
			бцел      важнЦвета;//biClrImportant;
	}
////////////////////////////////////////////
struct BITMAPINFO 
{
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[1];
}
alias BITMAPINFO* LPBITMAPINFO, PBITMAPINFO;

	struct ИНФОБИТМАП //BITMAPINFO
	 {
		ИНФОБИТМАПЗАГ    заголовок;//bmiHeader;
		КВАДКЗС             цвета[1];
	}
//////////////////////////////////////////////////////////
struct PALETTEENTRY 
{
    BYTE        peRed;
    BYTE        peGreen;
    BYTE        peBlue;
    BYTE        peFlags;
}
alias PALETTEENTRY* PPALETTEENTRY, LPPALETTEENTRY;

	struct ЗАПИСЬ_ПАЛИТРЫ //PALETTEENTRY
	 {
		ббайт        крас;
		ббайт        зел;
		ббайт        син;
		ббайт        флаги;
	}
	alias ЗАПИСЬ_ПАЛИТРЫ ПАЛИТЗАП;
////////////////////////////////////////////////////
struct LOGPALETTE
 {
    WORD        palVersion;
    WORD        palNumEntries;
    PALETTEENTRY        palPalEntry[1];
}
alias LOGPALETTE* PLOGPALETTE, NPLOGPALETTE, LPLOGPALETTE;

	struct ЛОГ_ПАЛИТРЫ //LOGPALETTE
	 {
		бкрат        версия;
		бкрат        члоЗап;
		ПАЛИТЗАП        палЗап[1];
	}
	alias ЛОГ_ПАЛИТРЫ ПАЛИТЛОГ;
/////////////////////////////////////////////
	/* Pixel format descriptor */
struct PIXELFORMATDESCRIPTOR
{
    WORD  nSize;
    WORD  nVersion;
    DWORD dwFlags;
    BYTE  iPixelType;
    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAccumBits;
    BYTE  cAccumRedBits;
    BYTE  cAccumGreenBits;
    BYTE  cAccumBlueBits;
    BYTE  cAccumAlphaBits;
    BYTE  cDepthBits;
    BYTE  cStencilBits;
    BYTE  cAuxBuffers;
    BYTE  iLayerType;
    BYTE  bReserved;
    DWORD dwLayerMask;
    DWORD dwVisibleMask;
    DWORD dwDamageMask;
}
alias PIXELFORMATDESCRIPTOR* PPIXELFORMATDESCRIPTOR, LPPIXELFORMATDESCRIPTOR;

	struct ДЕСКРФОРМАТАПИКСЕЛЯ //PIXELFORMATDESCRIPTOR
	{
		бкрат  размер;
		бкрат  версия;
		бцел   флаги;
		ббайт  типПикселя;
		ббайт  битыЦвета;
		ббайт  кБиты;//к - красный
		ббайт  кСдвиг;
		ббайт  зБиты;//з -зелёный
		ббайт  зСдвиг;
		ббайт  сБиты;//с - синий
		ббайт  сСдвиг;
		ббайт  аБиты;//а - альфа (прозрачность)
		ббайт  аСдвиг;
		ббайт  аккумБиты;
		ббайт  аккумКБиты;
		ббайт  аккумЗБиты;
		ббайт  аккумСБиты;
		ббайт  аккумАБиты;
		ббайт  битыДали; //даль = depth = "глубина" пикселей на экране
		ббайт  битыШаблона;//шаблон = stencil
		ббайт  допБуферы;
		ббайт  типСлоя;
		ббайт  резерв;
		бцел   маскаСлоя;
		бцел   маскаВидимого;
		бцел   маскаПовреждения;
	}
///////////////////////////////////////////////
alias LRESULT function (HWND, UINT, WPARAM, LPARAM) WNDPROC;
struct WNDCLASSEXA 
{
    UINT        cbSize;
    /* Win 3.x */
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
    /* Win 4.0 */
    HICON       hIconSm;
}
alias WNDCLASSEXA* PWNDCLASSEXA, NPWNDCLASSEXA, LPWNDCLASSEXA;

	struct КЛАССОКДОП_А //WNDCLASSEXA
	 {
		бцел     размер;
		/* Win 3.x */
		бцел    стиль;
		ОКОНПРОЦ  оконПроц;
		цел     упрэлтыЭкстра;
		цел     окнаЭкстра;
		экз  	экземпляр;
		ук      пиктограмма;
		ук    	курсор;
		ук      фон;
		ткст0   имяМеню;
		ткст0   имяКласса;
		/* Win 4.0 */
		ук      пиктограммаМал;
	}
	alias КЛАССОКДОП_А КЛАССОКДОП;
//////////////////////////////////////////
struct WNDCLASSA 
{
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
}
alias WNDCLASSA* PWNDCLASSA, NPWNDCLASSA, LPWNDCLASSA;
alias WNDCLASSA WNDCLASS;

	struct КЛАССОК_А //WNDCLASSA
	 {
		бцел        стиль;
		ОКОНПРОЦ    оконПроц;
		цел         упрэлтыЭкстра;
		цел         окЭкстра;
		экз  		экземпляр;
		ук      	пиктограмма;
		ук    		курсор;
		ук      	фон;
		ткст0       имяМеню;
		ткст0       имяКласса;
	}
	alias КЛАССОК_А КЛАССОК;
////////////////////////////////////////////
struct MSG 
{
    HWND        hwnd;
    UINT        message;
    WPARAM      wParam;
    LPARAM      lParam;
    DWORD       time;
    POINT       pt;
}
alias MSG* PMSG, NPMSG, LPMSG;

	struct СООБ //MSG
	{
		ук      окноПолучатель;
		бцел    сообщение;
		бцел    вПарам;
		цел     лПарам;
		бцел    время;
		ТОЧКА   тчк;
	}
/////////////////////////////////////////////////
struct TEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
}
	struct МЕТРИКА_ТЕКСТА //TEXTMETRICA
	{
		цел        высота;
		цел        подъём;
		цел        спуск;
		цел        внутрВступ;
		цел        внешнийВступ;
		цел        среднШирСим;
		цел        максШирСим;
		цел        вес;
		цел        перевес;
		цел        оцифрАспектШ;
		цел        оцифрАспектВ;
		ббайт        первСим;
		ббайт        последнСим;
		ббайт        дефолтнСим;
		ббайт        брейкСим;
		ббайт        курсив;
		ббайт        подчерк;
		ббайт        струкАут;
		ббайт        питчИСемейство;
		ббайт        гарнитура;
	}
	alias МЕТРИКА_ТЕКСТА ТЕКСТМЕТР;
////////////////////////////////////////////////////////
alias UINT function (HWND, UINT, WPARAM, LPARAM) LPOFNHOOKPROC;

struct OPENFILENAMEA 
{
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCSTR       lpstrFilter;
   LPSTR        lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPSTR        lpstrFile;
   DWORD        nMaxFile;
   LPSTR        lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCSTR       lpstrInitialDir;
   LPCSTR       lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCSTR       lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCSTR       lpTemplateName;
}
alias OPENFILENAMEA *LPOPENFILENAMEA;

	struct ОТКРФАЙЛ_А
	 {
	   бцел        размерСтрукт;
	   ук         окХозяин;
	   экз    		экземпляр;
	   ткст0       фильтр;
	   ткст0        фильтрАдапт;
	   бцел        максЧлоАдаптФильтров;
	   бцел        индексФильтра;
	   ткст0        файл;
	   бцел        максЧлоФайлов;
	   ткст0        титулФ;
	   бцел        максЧлоФТитулов;
	   ткст0       исхПапка;
	   ткст0       титул;
	   бцел        Флаги;
	   бкрат         фСмещен;
	   бкрат         члоФРасш;
	   ткст0       дефРасш;
	   цел       допДанные;
	   ОТКРФЛХУКПРОЦ офХук;
	   ткст0       имяШаблона;
	}
//////////////////////////////////////////////////
struct OPENFILENAMEW
 {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCWSTR      lpstrFilter;
   LPWSTR       lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPWSTR       lpstrFile;
   DWORD        nMaxFile;
   LPWSTR       lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCWSTR      lpstrInitialDir;
   LPCWSTR      lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCWSTR      lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCWSTR      lpTemplateName;
}
alias OPENFILENAMEW *LPOPENFILENAMEW;

	struct ОТКРФАЙЛ
	 {
	   бцел        размерСтрукт;
	   ук         окХозяин;
	   экз    экземпляр;
	   шим*      фильтр;
	   шим*       фильтрАдапт;
	   бцел        максЧлоАдаптФильтров;
	   бцел        индексФильтра;
	   шим*       файл;
	   бцел        максЧлоФайлов;
	   шим*       титулФ;
	   бцел        максЧлоФТитулов;
	   шим*      исхПапка;
	   шим*      титул;
	   бцел        Флаги;
	   бкрат         фСмещен;
	   бкрат         члоФРасш;
	   шим*      дефРасш;
	   цел       допДанные;
	   ОТКРФЛХУКПРОЦ офХук;
	   шим*      имяШаблона;
	}
////////////////////////////////////////
/* Bitmap Header Definition */
struct BITMAP
{
    LONG        bmType;
    LONG        bmWidth;
    LONG        bmHeight;
    LONG        bmWidthBytes;
    WORD        bmPlanes;
    WORD        bmBitsPixel;
    LPVOID      bmBits;
}
alias BITMAP* PBITMAP, NPBITMAP, LPBITMAP;

	struct БИТМАП //BITMAP
	{
		цел        тип;
		цел        ширина;
		цел        высота;
		цел        байтыШирины;
		бкрат      плоскости;
		бкрат      пиксельБит;
		ук         биты;
	}
///////////////////////////////////////////////////////
struct LOGFONTA
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    CHAR      lfFaceName[32 ];
}
alias LOGFONTA* PLOGFONTA, NPLOGFONTA, LPLOGFONTA;

	struct ЛОГ_ШРИФТА //LOGFONTA
	{
		цел      высота;
		цел      ширина;
		цел      lfEscapement;
		цел      ориентация;
		цел      вес;
		ббайт      курсив;
		ббайт      подчерк;
		ббайт      перечерк;
		ббайт      гарнитура;
		ббайт      выхТочность;
		ббайт      обрезТочность;
		ббайт      качество;
		ббайт      питчИСемейство;
		сим      имяКегля[32 ];
	}
	alias ЛОГ_ШРИФТА ШРИФТЛОГ;
////////////////////////////////////////////////////////
align (2) struct DLGTEMPLATE 
{
    DWORD style;
    DWORD dwExtendedStyle;
    WORD cdit;
    short x;
    short y;
    short cx;
    short cy;
}
alias DLGTEMPLATE *LPDLGTEMPLATEA;
alias DLGTEMPLATE *LPDLGTEMPLATEW;
alias LPDLGTEMPLATEA LPDLGTEMPLATE;
alias  DLGTEMPLATE *LPCDLGTEMPLATEA;
alias  DLGTEMPLATE *LPCDLGTEMPLATEW;
alias LPCDLGTEMPLATEA LPCDLGTEMPLATE;

	align (2) struct ШАБЛОНДЛГ//DLGTEMPLATE
	 {
		бцел стиль;
		бцел расширеннСтиль;
		бкрат cdit;
		крат x; alias x ш;
		крат y; alias y в;
		крат cx; alias cx дш;
		крат cy; alias cy дв;
	}
////////////////////////////////////////////////////////
struct LOGPEN
  {
    UINT        lopnStyle;
    POINT       lopnWidth;
    COLORREF    lopnColor;
}
alias LOGPEN* PLOGPEN, NPLOGPEN, LPLOGPEN;

	struct ЛОГ_ПЕРА //LOGPEN
	  {
		бцел        Стиль;
		ТОЧКА       Ширина;
		ЦВЕТ       Цвет;
	}
	alias ЛОГ_ПЕРА ПЕРЛОГ;
//////////////////////////////////////////////////
struct COORD 
{
    SHORT X;
    SHORT Y;
}
alias COORD *PCOORD;

	struct КООРД //COORD
	 {
		крат X; alias X Ш;
		крат Y; alias Y В;
	}
/////////////////////////////////////////////////////
struct SMALL_RECT
 {
    SHORT Left;
    SHORT Top;
    SHORT Right;
    SHORT Bottom;
}
alias SMALL_RECT *PSMALL_RECT;

	struct МПРЯМ //SMALL_RECT
	 {
		крат лево;
		крат верх;
		крат право;
		крат низ;
	}
/////////////////////////////////////////////
struct KEY_EVENT_RECORD
 {
    BOOL bKeyDown;
    WORD wRepeatCount;
    WORD wVirtualKeyCode;
    WORD wVirtualScanCode;
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    }
    DWORD dwControlKeyState;
}
alias KEY_EVENT_RECORD *PKEY_EVENT_RECORD;

	struct ЗАПИСЬ_СОБЫТИЯ_КЛАВИШИ
	 {
		Бул 	клВнизу;
		бкрат 	счётПовторов;
		бкрат 	кодВиртКл;
		бкрат 	кодВиртСкан;
		union {
			шим симЮникода;
			сим   симАски;
		}
		бцел состКлУпр;
	}
	alias ЗАПИСЬ_СОБЫТИЯ_КЛАВИШИ ЗАПСОБКЛ;
///////////////////////////////////////////////
struct MOUSE_EVENT_RECORD
 {
    COORD dwMousePosition;
    DWORD dwButtonState;
    DWORD dwControlKeyState;
    DWORD dwEventFlags;
}
alias MOUSE_EVENT_RECORD *PMOUSE_EVENT_RECORD;

	struct ЗАПИСЬ_СОБЫТИЯ_МЫШИ 
	{
		КООРД позМыши;
		ПСостКнопкиМыши состКнопки;
		ПСостКлУпр состКлУпр;
		ПТипСобМыши флагиСобытия;
	}
	alias ЗАПИСЬ_СОБЫТИЯ_МЫШИ ЗАПСОБМЫШ;
//////////////////////////////////////////////////////////
struct WINDOW_BUFFER_SIZE_RECORD 
{
    COORD dwSize;
}
alias WINDOW_BUFFER_SIZE_RECORD *PWINDOW_BUFFER_SIZE_RECORD;

	struct ЗАПИСЬ_РАЗМЕРА_БУФЕРА_ОКНА
	 {
		КООРД размер;
	 }
	alias ЗАПИСЬ_РАЗМЕРА_БУФЕРА_ОКНА ЗАПРАЗМБУФОК;
////////////////////////////////////////////////
struct MENU_EVENT_RECORD 
{
    UINT dwCommandId;
}
alias MENU_EVENT_RECORD *PMENU_EVENT_RECORD;

	struct ЗАПИСЬ_СОБЫТИЯ_МЕНЮ
	 {
		бцел идКоманды;
	 }
	alias ЗАПИСЬ_СОБЫТИЯ_МЕНЮ ЗАПСОБМЕНЮ;
/////////////////////////////////////////////////
struct FOCUS_EVENT_RECORD 
{
    BOOL bSetFocus;
}
alias FOCUS_EVENT_RECORD *PFOCUS_EVENT_RECORD;

	struct ЗАПИСЬ_СОБЫТИЯ_ФОКУСА
	 {
		Бул установитьФокус;
	}
	alias ЗАПИСЬ_СОБЫТИЯ_ФОКУСА ЗАПСОБФОК;
//////////////////////////////////////////////////
struct INPUT_RECORD
 {
    WORD EventType;
    union {
        KEY_EVENT_RECORD KeyEvent;
        MOUSE_EVENT_RECORD MouseEvent;
        WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
        MENU_EVENT_RECORD MenuEvent;
        FOCUS_EVENT_RECORD FocusEvent;
    }
}
alias INPUT_RECORD *PINPUT_RECORD;

	struct ЗАПИСЬ_ВВОДА
	 {
		бкрат типСобытия;
		union {
			ЗАПИСЬ_СОБЫТИЯ_КЛАВИШИ собКлав;
			ЗАПИСЬ_СОБЫТИЯ_МЫШИ 	собМыши;
			ЗАПИСЬ_РАЗМЕРА_БУФЕРА_ОКНА собРазмБуфОк;
			ЗАПИСЬ_СОБЫТИЯ_МЕНЮ собМеню;
			ЗАПИСЬ_СОБЫТИЯ_ФОКУСА собФок;
		}
	}
	alias ЗАПИСЬ_ВВОДА ЗАПВВОДА;
///////////////////////////////////
struct CHAR_INFO
 {
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    }
    WORD Attributes;
}
alias CHAR_INFO *PCHAR_INFO;

	struct ИНФОСИМ//CHAR_INFO
	 {
		union
		{
			шим симЮникода;
			сим   симАски;
		}
		ПАтрыИнфосим атрибуты;
	}
/////////////////////////////
struct CONSOLE_SCREEN_BUFFER_INFO
 {
    COORD dwSize;
    COORD dwCursorPosition;
    WORD  wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
}
alias CONSOLE_SCREEN_BUFFER_INFO *PCONSOLE_SCREEN_BUFFER_INFO;

	struct ИНФ_О_БУФ_ЭКРАНА_КОНСОЛИ //CONSOLE_SCREEN_BUFFER_INFO
	{
		КООРД размер;
		КООРД позКурсора;
		ПТекстКонсоли  атрибуты;
		МПРЯМ окно;
		КООРД максРазмОкна;
	}
	alias ИНФ_О_БУФ_ЭКРАНА_КОНСОЛИ ИНФОКОНСЭКРБУФ;
////////////////////////////////////////////////////////////////
struct CONSOLE_CURSOR_INFO
 {
    DWORD  dwSize;
    BOOL   bVisible;
}
alias CONSOLE_CURSOR_INFO *PCONSOLE_CURSOR_INFO;
	struct ИНФ_О_КУРСОРЕ_КОНСОЛИ //CONSOLE_CURSOR_INFO
	{
		бцел  размер;
		Бул   видимый;
	}
	alias ИНФ_О_КУРСОРЕ_КОНСОЛИ ИНФОКОНСКУРСОР;
////////////////////////////////////////////////////
struct WSADATA
{
	WORD wVersion;
	WORD wHighVersion;
	char szDescription[cast(цел) ДЛИНА_ВСАОПИСАНИЯ + 1];
	char szSystemStatus[cast(цел) ДЛИНА_ВСАСИС_СТАТУСА + 1];
	USHORT iMaxSockets;
	USHORT iMaxUdpDg;
	char* lpVendorInfo;
}
alias WSADATA* LPWSADATA;

	struct ВИНСОКДАН //WSADATA
	{
		бкрат версия;
		бкрат хВерсия;
		сим описание[cast(цел) ДЛИНА_ВСАОПИСАНИЯ + 1];
		сим сисСтатус[cast(цел) ДЛИНА_ВСАСИС_СТАТУСА + 1];
		бкрат максЧлоСок;
		бкрат максДгПпд;//iMaxUdpDg;
		ткст0 инфОПроизв;//lpVendorInfo;
	}
/////////////////////////////////////////////////////
	struct ВавЗаг
	{
		сим рифф[4] = "RIFF";
		бцел размер;
		сим фмт[4] = "WAVE";
		
		сим идЦилиндраФмт[4]= "fmt ";
		бцел размерЦилиндраФмт;
		бкрат аудиоФормат;
		бкрат члоКаналов;
		бцел семплРейт;
		бцел байтРейт;
		бкрат раскладкаБлока;
		бкрат битНаСемпл;
		
		сим идЦилиндраДанных[4]= "data";
		бцел размерЦилиндраДанных;
		// data follows
	}
////////////////////////////////////////////////
struct STARTUPINFO
{
 DWORD cb;
 LPTSTR lpReserved;
 LPTSTR lpDesktop;
 LPTSTR lpTitle;
 DWORD dwX;
 DWORD dwY;
 DWORD dwXSize;
 DWORD dwYSize;
 DWORD dwXCountChars;
 DWORD dwYCountChars;
 DWORD dwFillAttribute;
 DWORD dwFlags;
 WORD wShowWindow;
 WORD cbReserved2;
 LPBYTE lpReserved2;
 HANDLE hStdInput;
 HANDLE hStdOutput;
 HANDLE hStdError;
}

alias STARTUPINFO* LPSTARTUPINFO;
alias STARTUPINFO _STARTUPINFO;

	struct ИНФОСТАРТА //STARTUPINFO
	{
	 бцел размер;
	 шим *резерв;
	 шим *рабСтол;
	 шим *титул;
	 бцел ш;
	 бцел в;
	 бцел шразм;
	 бцел вразм;
	 бцел школвосим;
	 бцел вколвосим;
	 бцел запатр;
	 бцел флаги;
	 бкрат показОкна;
	 бкрат резерв2;
	 ббайт *резерв2Ук;
	 ук стдвво;
	 ук стдвыв;
	 ук стдош;
	}
///////////////////////////////////////////////////////
struct PROCESS_INFORMATION
{
 HANDLE hProcess;
 HANDLE hThread;
 DWORD dwProcessId;
 DWORD dwThreadId;
}

alias PROCESS_INFORMATION* LPPROCESS_INFORMATION;
alias PROCESS_INFORMATION _PROCESS_INFORMATION;
alias PROCESS_INFORMATION TPROCESSINFORMATION;
alias PROCESS_INFORMATION* PPROCESSINFORMATION;

	struct ИНФОПРОЦ //PROCESS_INFO
	{
	 ук процесс;
	 ук нить;
	 бцел идПроцесса;
	 бцел идНити;
	}
/////////////////////////////////////////////////////////

	struct ГРАНБЕЗОПМАСА 
	{
	  бцел члоЭлтов;
	  цел нижГран;
	}

	struct КОСЕРВЕРИНФО //COSERVERINFO
	 {
	  бцел резерв1;
		  шим* имяОбъ;  
	  КОАУТИНФО* аутИнф;
	  бцел резерв2;
	}

	struct КОАУТИДЕНТИЧНОСТЬ //COAUTHIDENTITY
	{
	  шим* Пользователь;
	  бцел ПользовательДлина;
	  шим* Домен;
	  бцел ДоменДлина;
	  шим* Пароль;
	  бцел ПарольДлина;
	  бцел Флаги;
	}

	struct КОАУТИНФО //COAUTHINFO
	{
	  бцел службаАутн;
	  бцел службаАутз;
	  шим* имяПринкСервера;
	  бцел уровеньАутн;
	  бцел уровеньИмперсонации;
	  КОАУТИДЕНТИЧНОСТЬ* данныеАутИдент;
	  бцел способности;
	}

	struct ОТКРПМБ //STATSTG
	 {
	  шим* укНаШ0Имя;
	  бцел тип;
	  бдол бРазм;
	  ФВРЕМЯ ивремя;
	  ФВРЕМЯ свремя;
	  ФВРЕМЯ двремя;
	  бцел послРежДост;
	  бцел поддержТипыБлокРгна;
	  ГУИД клсид;
	  бцел битыТекСостХр;
	  бцел резерв;
	}

	struct ОПЦИИХР //STGOPTIONS
	 {
	  бкрат испВерсия;
	  бкрат резерв;
	  бцел бдРазмСектора;
	  шим* укНаШ0ФайлШаблона;
	}

	struct СВЯЗОПЦИИ //
	 {
	  бцел бСтрукт = СВЯЗОПЦИИ.sizeof;
	  бцел мсоФлаги;
	  бцел послРежДост;
	  бцел бцПредельнСрокТик;
	}

	struct СВЯЗОПЦИИ2 
	{
	  бцел бСтрукт = СВЯЗОПЦИИ2.sizeof;
	  бцел мсоФлаги;
	  бцел послРежДост;
	  бцел бцПредельнСрокТик;
	  бцел бцТрэкФлаги;
	  бцел бцКонтекстКласса;
	  бцел локаль;
	  КОСЕРВЕРИНФО* укНаСерверИнфо;
	}

	struct МУЛЬТИ_ОИ //MULTI_QI
	 {
	  ГУИД* укНаИИд;  
	  Инкогнито укНаИз;
	  цел хрез;
	}

	struct ЦУСТРОЙСТВО //DVTARGETDEVICE
	 {
	  бцел цуРазм;
	  бкрат цуСмещКИмениДрайвера;
	  бкрат цуСмещКИмениУстрва;
	  бкрат цуСмещКИмениПорта;
	  бкрат цуСмещКДопУстрреж;
	  ббайт* цуДанные;
	}

	struct ФОРМАТИТД //FORMATETC
	 {
	  бкрат формат;
	  ЦУСТРОЙСТВО* укнад;
	  бцел аспект;
	  цел индекс;
	  бцел тимед;
	}

	struct НОСИТЕЛЬПАМ //STGMEDIUM
	{
	  бцел тимед;
	  union {
		ук битмап;
		ук метаФайлПикт;
		ук усМетаФайл;
		ук глоб;
		шим* имяф;
		ИПоток птк;
		ИХранилище хран;
	  }
	  Инкогнито инкДляВысвобожд;
	}

	struct ОЛЕВЕРБ //OLEVERB
	 {
	  цел верб;
	  шим* имяВерба;
	  бцел флаги;
	  бцел грфАтры;
	}

	struct СТАТДАННЫЕ //STATDATA
	{
	  ФОРМАТИТД форматетц;
	  бцел адвф;
	  IAdviseSink адвСинк;
	  бцел соединение;
	}

	struct ДИСППАРАМЫ //DISPPARAMS
	 {
	  ВАРИАНТ* ргварг;
	  цел* ргдиспидИменованыеАрги;
	  бцел арги;
	  бцел именованыеАрги;
	}

	struct ИСКЛИНФО //EXCEPINFO
	 {
	  бкрат код;
	  бкрат резерв1;
	  шим* исток;
	  шим* описание;
	  шим* файлСправки;
	  бцел контекстСправки;
	  ук   резерв2;
	  цел function(ИСКЛИНФО*) измененЗаполнение;
	  цел скод;
	}

	struct ТИПДЕСКР //TYPEDESC
	 {
	  union {
		ТИПДЕСКР* деск;
		МАССДЕСКР* адеск;
		бцел ссылтип;
	  }
	  бкрат вт;
	}

	struct МАССДЕСКР//ARRAYDESC
	 {
	  ТИПДЕСКР элемДеск;
	  бкрат меры;
	  ГРАНБЕЗОПМАСА[1] ргграни;
	}

	struct ПАРАМДЕСКРДОП //PARAMDESCEX
	{
	  бцел байты;
	  ВАРИАНТ дефЗнач;
	}

	struct ПАРАМДЕСКР //PARAMDESC
	 {
	  ПАРАМДЕСКРДОП* ппарамдесцекс;
	  бкрат флагиПарам;
	}

	struct ИДЛДЕСКР //IDLDESC
	 {
	  бцел резерв;
	  бкрат флпгиИДЛ;
	}

	struct ЭЛЕМДЕСКР //ELEMDESC
	{
	  ТИПДЕСКР дескт;
	  union {
		ИДЛДЕСКР дескИДЛ;
		ПАРАМДЕСКР дескпарам;
	  }
	}

	struct ТИПАТР//TYPEATTR
	 {
	  ГУИД гуид;
	  бцел лкид;
	  бцел резерв;
	  цел конструкторЧленИД;
	  цел деструкторЧленИД;
	  шим* схема;
	  бцел размерЭкземпляра;
	  ПВидТипа типвид;
	  бкрат функи;
	  бкрат пермы;
	  бкрат имплТипы;//cImplTypes
	  бкрат размерВфт;
	  бкрат раскладка;
	  бкрат флагиТипов;
	  бкрат номСтаршВерс;
	  бкрат номМладшВерс;
	  ТИПДЕСКР алиасДеск;
	  ИДЛДЕСКР типДескИДЛ;
	}

	struct ФУНКЦДЕСКР//FUNCDESC
	{
	  ИДЧЛЕНА идЧлена;//memid
	  цел* ргскод;
	  ЭЛЕМДЕСКР* парамРгэлемдеск;
	  ПВидФунк видфунк;
	  ПВидВызова типвыз;
	  ПКонвВызова конввыз;
	  крат парамы;
	  крат опцПарамов;
	  крат ВфтО;
	  крат скоды;
	  ЭЛЕМДЕСКР функЭлемдеск;
	  бкрат флагиФунк;
	}

	struct ПЕРЕМДЕСКР //VARDESC
	{
	  цел идпам;
	  шим* схема;
	  union {
		бцел экзО;
		ВАРИАНТ* значПерем;
	  }
	  ЭЛЕМДЕСКР перемДескЭлем;
	  бкрат флагиПерем;
	  ПВидПерем типперем;
	}

	struct УКПРИВЯЗ//BINDPTR
	 {
	  ФУНКЦДЕСКР* функдескр;
	  ПЕРЕМДЕСКР* вардескр;
	  ITypeComp ткомп;
	}

	struct ОСОБЭЛДАН//CUSTDATAITEM 
	{
	  ГУИД гуид;
	  ВАРИАНТ значВар;
	}

	struct ОСОБДАН //CUSTDATA
	 {
	  бцел особДанные;
	  ОСОБЭЛДАН* осДан;
	}
	
	struct ИНФ_О_КАТЕГОРИИ//CATEGORYINFO
	 {
	  ГУИД идКат;
	  бцел лкид;
	  шим[128] описание;
	}
	alias ИНФ_О_КАТЕГОРИИ ИНФОКАТ;

	struct АТРТБИБ //TLIBATTR
	 {
	  ГУИД гуид;
	  бцел лкид;
	  ПВидСистемы видсис;
	  бкрат старшНомВер;
	  бкрат младНомВер;
	  бкрат флагиБиб;
	}

	struct РИСДЕСКР//PICTDESC
	 {
	  бцел размер = РИСДЕСКР.sizeof;
	  бцел типРис;
	  ук укз;
	}

	struct СОЕДДАН //CONNECTDATA
	 {
	  Инкогнито инк;
	  бцел куки;
	}

	struct ИНФОЛИЦ //LICINFO
	 {
	  цел инфолиц = ИНФОЛИЦ.sizeof;
	  цел доступнРантаймКлюч;
	  цел лицВерифицирована;
	}

	struct МЕТРИКА_ОЛЕ_ТЕКСТА //TEXTMETRICOLE
	 {
	  цел высота;
	  цел подъём;
	  цел спуск;
	  цел внутреннийВвод;
	  цел внешнийВвод;
	  цел средШирСим;
	  цел максШирСим;
	  цел вес;
	  цел свис;
	  цел оцифрАспектШ;
	  цел оцифрАспектВ;
	  шим первСим;
	  шим последнСим;
	  шим дефСим;
	  шим брейкСим;
	  ббайт курсив;
	  ббайт подчерк;
	  ббайт tmStruckOut;
	  ббайт tmPitchAndFamily;
	  ббайт гарнитура;
	}
	alias МЕТРИКА_ОЛЕ_ТЕКСТА ОЛЕТЕКСТМЕТР;

	struct ЗАПИСЬ_КУЧИ_ПРОЦЕССА //PROCESS_HEAPENTRY
	{
	 ук данук;
	 бцел данные;
	 ббайт излишек;
	 ббайт индексРегиона;
	 бкрат флаги;
	 union 
	 { 
		 struct Блок
		 {
		 ук пам;
		 бцел резерв[3];
		 }
		 
		 struct Регион
		 {
		 бцел переданныйРазм;
		 бцел непереданныйРазм;
		 ук первБлок;
		 ук последнБлок;
		 } 
	 }
	}
	alias ЗАПИСЬ_КУЧИ_ПРОЦЕССА ЗАППРОЦКУЧ;
	
////////////////////////
union LARGE_INTEGER {
	struct {
		uint LowPart;
		int  HighPart;
	}
	long QuadPart;
}
alias LARGE_INTEGER* PLARGE_INTEGER;
alias LARGE_INTEGER LUID;
alias LUID* PLUID;

	union БОЛЬШЕЦЕЛ //LARGE_INTEGER
	 {
		struct {
			бцел младшЧасть;
			цел старшЧасть;
		}
		дол квадрЧасть;
	}
alias БОЛЬШЕЦЕЛ ЛУИД;
///////////////////////////
union ULARGE_INTEGER {
	struct {
		uint LowPart;
		uint HighPart;
	}
	ulong QuadPart;
}
alias ULARGE_INTEGER* PULARGE_INTEGER;

	union ББОЛЬШЕЦЕЛ //ULARGE_INTEGER
	 {
		struct {
			бцел младшЧасть;
			бцел старшЧасть;
		}
		бдол квадрЧасть;
	}
//////////////////////////////
align(4) struct LUID_AND_ATTRIBUTES {
	LUID  Luid;
	DWORD Attributes;
}
alias LUID_AND_ATTRIBUTES* PLUID_AND_ATTRIBUTES;

	align(4) struct ЛУИД_И_АТРЫ//LUID_AND_ATTRIBUTES
	{
	ЛУИД луид;
	бцел атры;
	}
/////////////////////////////////
	struct PRIVILEGE_SET {
	DWORD PrivilegeCount;
	DWORD Control;
	LUID_AND_ATTRIBUTES _Privilege;

	LUID_AND_ATTRIBUTES* Privilege() { return &_Privilege; }
}
alias PRIVILEGE_SET* PPRIVILEGE_SET;

	struct УСТПРИВ//PRIVILEGE_SET 
	{
	бцел члоПрив;
	бцел упр;
	ЛУИД_И_АТРЫ _Привилегия;

	ЛУИД_И_АТРЫ* Привилегия() { return &_Привилегия; }
	}
///////////////////////////////////////////
enum SECURITY_IMPERSONATION_LEVEL {
	SecurityAnonymous,
	SecurityIdentification,
	SecurityImpersonation,
	SecurityDelegation
}

alias BOOLEAN SECURITY_CONTEXT_TRACKING_MODE;
alias BOOLEAN* PSECURITY_CONTEXT_TRACKING_MODE;

struct SECURITY_QUALITY_OF_SERVICE {
	DWORD   Length;
	SECURITY_IMPERSONATION_LEVEL   ImpersonationLevel;
	SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
	BOOLEAN EffectiveOnly;
}
alias SECURITY_QUALITY_OF_SERVICE* PSECURITY_QUALITY_OF_SERVICE;

	struct КАЧЕСТВО_БЕЗОПАСНОСТИ_СЛУЖБЫ//SECURITY_QUALITY_OF_SERVICE 
	{
	бцел длина;
	ПУровеньИмперсонацииБезопасности   уровеньИмп;
	РЕЖИМ_ОТСЛЕЖИВАНИЯ_КОНТЕКСТА_БЕЗОПАСНОСТИ режимОтслежКонтекста;
	бул толькоДейств;
	}
	alias КАЧЕСТВО_БЕЗОПАСНОСТИ_СЛУЖБЫ КАЧБЕЗОПСЛУЖБ;
//////////////////////////////////////////////////////////////	
alias PVOID PACCESS_TOKEN;

struct SE_IMPERSONATION_STATE {
	PACCESS_TOKEN Token;
	BOOLEAN       CopyOnOpen;
	BOOLEAN       EffectiveOnly;
	SECURITY_IMPERSONATION_LEVEL Level;
}
alias SE_IMPERSONATION_STATE* PSE_IMPERSONATION_STATE;

	struct БЕЗОПИМПЕРССОСТ//SE_IMPERSONATION_STATE
	{
	УкТОКЕН_ДОСТУПА 				 токен;
	бул 							 копироватьПриОткр;
	бул								 толькоДейств;
	ПУровеньИмперсонацииБезопасности уровень;
	}
////////////////////////////////////////////////////////
struct SID_IDENTIFIER_AUTHORITY {
	BYTE[6] Value;
}
alias SID_IDENTIFIER_AUTHORITY* PSID_IDENTIFIER_AUTHORITY, LPSID_IDENTIFIER_AUTHORITY;

	struct БИДИДЕНТАВТОРИТ//SID_IDENTIFIER_AUTHORITY
	{
	ббайт[6] знач;
	}
///////////////////////////////////
alias PVOID PSID;

struct SID {
	BYTE  Revision;
	BYTE  SubAuthorityCount;
	SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
	DWORD _SubAuthority;

	DWORD* SubAuthority() { return &_SubAuthority; }
}
alias SID* PISID;

	struct БИД//SID
	{
	ббайт			ревизия;
	ббайт 			члоСубАвторитов;
	БИДИДЕНТАВТОРИТ идентАвторит;
	бцел 			_ПодАвторит;

	бцел* ПодАвторит() { return &_ПодАвторит; }
	}
///////////////////////////////////////////////
	struct SID_AND_ATTRIBUTES {
	PSID  Sid;
	DWORD Attributes;
}
alias SID_AND_ATTRIBUTES* PSID_AND_ATTRIBUTES;

	struct БИД_И_АТРЫ//SID_AND_ATTRIBUTES
	{
	УкБИД бид;
	бцел атры;
	}
/////////////////////////////////////////
const size_t TOKEN_SOURCE_LENGTH = 8;

struct TOKEN_SOURCE {
	CHAR[TOKEN_SOURCE_LENGTH] SourceName;
	LUID SourceIdentifier;
}
alias TOKEN_SOURCE* PTOKEN_SOURCE;

	struct ИСТОК_ТОКЕНА 
	{
	сим[ДЛИНА_ИСТОКА_ТОКЕНА] имяИстока;
	ЛУИД идИстока;
	}
	alias ИСТОК_ТОКЕНА ТОКИСТ;
//////////////////////////////////////////////
struct TOKEN_CONTROL {
	LUID         TokenId;
	LUID         AuthenticationId;
	LUID         ModifiedId;
	TOKEN_SOURCE TokenSource;
}
alias TOKEN_CONTROL* PTOKEN_CONTROL;

	struct ТОКЕНУПР//TOKEN_CONTROL 
	{
	ЛУИД         идТокена;
	ЛУИД         идАутентик;
	ЛУИД         идИзмененный;
	ТОКИСТ		 токИст;
	}
////////////////////////////////////////////////////
struct TOKEN_DEFAULT_DACL {
	PACL DefaultDacl;
}
alias TOKEN_DEFAULT_DACL* PTOKEN_DEFAULT_DACL;

	struct ДЕФОЛТ_ДСКД_ТОКЕН//TOKEN_DEFAULT_DACL 
	{
	СКД* дефолтДскд;
	}
	alias ДЕФОЛТ_ДСКД_ТОКЕН ДЕФДСКДТОК;
////////////////////////////////////////////
	struct TOKEN_GROUPS {
	DWORD GroupCount;
	SID_AND_ATTRIBUTES _Groups;

	SID_AND_ATTRIBUTES* Groups() { return &_Groups; }
}
alias TOKEN_GROUPS* PTOKEN_GROUPS, LPTOKEN_GROUPS;

	struct ГРУППЫ_ТОКЕНОВ//TOKEN_GROUPS
	{
	бцел 		члоГрупп;
	БИД_И_АТРЫ	 _Группы;

	БИД_И_АТРЫ* Группы() { return &_Группы; }
	}
	alias ГРУППЫ_ТОКЕНОВ ТОКЕНГРУП;
/////////////////////////////////////////////
	struct TOKEN_OWNER {
	PSID Owner;
}
alias TOKEN_OWNER* PTOKEN_OWNER;

	struct ВЛАДЕЛЕЦ_ТОКЕНА //TOKEN_OWNER 
	{
	УкБИД владелец;
	}
////////////////////////////////////////////////////////
	struct TOKEN_PRIMARY_GROUP {
	PSID PrimaryGroup;
}
alias TOKEN_PRIMARY_GROUP* PTOKEN_PRIMARY_GROUP;

	struct ПЕРВИЧН_ГРУППА_ТОКЕНОВ//TOKEN_PRIMARY_GROUP 
	{
	УкБИД первичнГруппа;
	}
/////////////////////////////////////////////////////	
struct TOKEN_PRIVILEGES {
	DWORD PrivilegeCount;
	LUID_AND_ATTRIBUTES _Privileges;

	LUID_AND_ATTRIBUTES* Privileges() { return &_Privileges; }
}
alias TOKEN_PRIVILEGES* PTOKEN_PRIVILEGES, LPTOKEN_PRIVILEGES;

	struct ПРИВИЛЕГИИ_ТОКЕНОВ//TOKEN_PRIVILEGES
	{
	бцел 		члоПривилегий;
	ЛУИД_И_АТРЫ _Привилегии;

	ЛУИД_И_АТРЫ* Привилегии() { return &_Привилегии; }
	}
////////////////////////////////////////
enum TOKEN_TYPE {
	TokenPrimary = 1,
	TokenImpersonation
}
alias TOKEN_TYPE* PTOKEN_TYPE;

	struct TOKEN_STATISTICS {
	LUID          TokenId;
	LUID          AuthenticationId;
	LARGE_INTEGER ExpirationTime;
	TOKEN_TYPE    TokenType;
	SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
	DWORD         DynamicCharged;
	DWORD         DynamicAvailable;
	DWORD         GroupCount;
	DWORD         PrivilegeCount;
	LUID          ModifiedId;
}
alias TOKEN_STATISTICS* PTOKEN_STATISTICS;

	struct ТОКЕНСТАТ //TOKEN_STATISTICS
	{
	ЛУИД         					 идТокена;
	ЛУИД         					 идАутентификации;
	БОЛЬШЕЦЕЛ 						 времяУстаревания;
	ПТипТокена  					 типТокена;
	ПУровеньИмперсонацииБезопасности уровеньИмп;
	бцел        					 динамичПрисв;
	бцел       						 динамичДоступ;
	бцел      						 члоГрупп;
	бцел     						 члоПривилегий;
	ЛУИД      						 идИзменённый;
	}
//////////////////////////////////////////////////////
	struct TOKEN_USER {
	SID_AND_ATTRIBUTES User;
}
alias TOKEN_USER* PTOKEN_USER;

	struct ПОЛЬЗОВАТЕЛЬ_ТОКЕНА//TOKEN_USER 
	{
	БИД_И_АТРЫ пользователь;
	}
/////////////////////////////////////////////
	
struct ПРЕДЕЛЫ_КВОТ//QUOTA_LIMITS 
{
	т_мера пределПулаСтр;
	т_мера пределПулаБезСтр;
	т_мера минРазмРабНабора;
	т_мера максРазмРабНабора;
	т_мера пределПейджфайла;
	БОЛЬШЕЦЕЛ пределВремени;
}
/+
struct IO_COUNTERS {
	ULONGLONG ReadOperationCount;
	ULONGLONG WriteOperationCount;
	ULONGLONG OtherOperationCount;
	ULONGLONG ReadTransferCount;
	ULONGLONG WriteTransferCount;
	ULONGLONG OtherTransferCount;
}
alias IO_COUNTERS* PIO_COUNTERS;

struct FILE_NOTIFY_INFORMATION {
	бцел NextEntryOffset;
	бцел Action;
	бцел FileNameLength;
	шим _FileName;

	шим* FileName() { return &_FileName; }
}
alias FILE_NOTIFY_INFORMATION* PFILE_NOTIFY_INFORMATION;

struct TAPE_ERASE {
	бцел   Type;
	бул Immediate;
}
alias TAPE_ERASE* PTAPE_ERASE;

struct TAPE_GET_DRIVE_PARAMETERS {
	бул ECC;
	бул Compression;
	бул DataPadding;
	бул ReportSetmarks;
	бцел   DefaultBlockSize;
	бцел   MaximumBlockSize;
	бцел   MinimumBlockSize;
	бцел   MaximumPartitionCount;
	бцел   FeaturesLow;
	бцел   FeaturesHigh;
	бцел   EOTWarningZoneSize;
}
alias TAPE_GET_DRIVE_PARAMETERS* PTAPE_GET_DRIVE_PARAMETERS;

struct TAPE_GET_MEDIA_PARAMETERS {
	БОЛЬШЕЦЕЛ Capacity;
	БОЛЬШЕЦЕЛ Remaining;
	бцел         BlockSize;
	бцел         PartitionCount;
	бул       WriteProtected;
}
alias TAPE_GET_MEDIA_PARAMETERS* PTAPE_GET_MEDIA_PARAMETERS;

struct TAPE_GET_POSITION {
	ULONG Type;
	ULONG Partition;
	ULONG OffsetLow;
	ULONG OffsetHigh;
}
alias TAPE_GET_POSITION* PTAPE_GET_POSITION;

struct TAPE_PREPARE {
	бцел   Operation;
	бул Immediate;
}
alias TAPE_PREPARE* PTAPE_PREPARE;

struct TAPE_SET_DRIVE_PARAMETERS {
	бул ECC;
	бул Compression;
	бул DataPadding;
	бул ReportSetmarks;
	ULONG   EOTWarningZoneSize;
}
alias TAPE_SET_DRIVE_PARAMETERS* PTAPE_SET_DRIVE_PARAMETERS;

struct TAPE_SET_MEDIA_PARAMETERS {
	ULONG BlockSize;
}
alias TAPE_SET_MEDIA_PARAMETERS* PTAPE_SET_MEDIA_PARAMETERS;

struct TAPE_SET_POSITION {
	бцел         Method;
	бцел         Partition;
	БОЛЬШЕЦЕЛ Offset;
	бул       Immediate;
}
alias TAPE_SET_POSITION* PTAPE_SET_POSITION;

struct TAPE_WRITE_MARKS {
	бцел   Type;
	бцел   Count;
	бул Immediate;
}
alias TAPE_WRITE_MARKS* PTAPE_WRITE_MARKS;

struct TAPE_CREATE_PARTITION {
	бцел Method;
	бцел Count;
	бцел Size;
}
alias TAPE_CREATE_PARTITION* PTAPE_CREATE_PARTITION;

struct MEMORY_BASIC_INFORMATION {
	PVOID BaseAddress;
	PVOID AllocationBase;
	бцел AllocationProtect;
	бцел RegionSize;
	бцел State;
	бцел Protect;
	бцел Type;
}
alias MEMORY_BASIC_INFORMATION* PMEMORY_BASIC_INFORMATION;

struct MESSAGE_RESOURCE_ENTRY {
	бкрат Length;
	бкрат Flags;
	ббайт _Text;

	ббайт* Text() { return &_Text; }
}
alias MESSAGE_RESOURCE_ENTRY* PMESSAGE_RESOURCE_ENTRY;

struct MESSAGE_RESOURCE_BLOCK {
	бцел LowId;
	бцел HighId;
	бцел OffsetToEntries;
}
alias MESSAGE_RESOURCE_BLOCK* PMESSAGE_RESOURCE_BLOCK;

struct MESSAGE_RESOURCE_DATA {
	бцел NumberOfBlocks;
	MESSAGE_RESOURCE_BLOCK _Blocks;

	MESSAGE_RESOURCE_BLOCK* Blocks() { return &_Blocks; }
}
alias MESSAGE_RESOURCE_DATA* PMESSAGE_RESOURCE_DATA;

struct LIST_ENTRY {
	LIST_ENTRY* Flink;
	LIST_ENTRY* Blink;
}
alias LIST_ENTRY* PLIST_ENTRY;

struct SINGLE_LIST_ENTRY {
	SINGLE_LIST_ENTRY* Next;
}
alias SINGLE_LIST_ENTRY SLIST_ENTRY;
alias SINGLE_LIST_ENTRY* PSINGLE_LIST_ENTRY, PSLIST_ENTRY;

union SLIST_HEADER {
	ULONGLONG       Alignment;
	struct {
		SLIST_ENTRY Next;
		бкрат        Depth;
		бкрат        Sequence;
	}
}
alias SLIST_HEADER* PSLIST_HEADER;

struct RTL_CRITICAL_SECTION_DEBUG {
	бкрат       Type;
	бкрат       CreatorBackTraceIndex;
	RTL_CRITICAL_SECTION* CriticalSection;
	LIST_ENTRY ProcessLocksList;
	бцел      EntryCount;
	бцел      ContentionCount;
	бцел[2]   Spare;
}
alias RTL_CRITICAL_SECTION_DEBUG* PRTL_CRITICAL_SECTION_DEBUG;

struct RTL_CRITICAL_SECTION {
	PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
	LONG   LockCount;
	LONG   RecursionCount;
	HANDLE OwningThread;
	HANDLE LockSemaphore;
	бцел  Reserved;
}
alias RTL_CRITICAL_SECTION* PRTL_CRITICAL_SECTION;

struct EVENTLOGRECORD {
	бцел Length;
	бцел Reserved;
	бцел RecordNumber;
	бцел TimeGenerated;
	бцел TimeWritten;
	бцел EventID;
	бкрат  EventType;
	бкрат  NumStrings;
	бкрат  EventCategory;
	бкрат  ReservedFlags;
	бцел ClosingRecordNumber;
	бцел StringOffset;
	бцел UserSidLength;
	бцел UserSidOffset;
	бцел DataLength;
	бцел DataOffset;
}
alias EVENTLOGRECORD* PEVENTLOGRECORD;

struct OSVERSIONINFOA {
	бцел     dwOSVersionInfoSize;
	бцел     dwMajorVersion;
	бцел     dwMinorVersion;
	бцел     dwBuildNumber;
	бцел     dwPlatformId;
	сим[128] szCSDVersion;
}
alias OSVERSIONINFOA* POSVERSIONINFOA, LPOSVERSIONINFOA;

struct OSVERSIONINFOW {
	бцел      dwOSVersionInfoSize;
	бцел      dwMajorVersion;
	бцел      dwMinorVersion;
	бцел      dwBuildNumber;
	бцел      dwPlatformId;
	шим[128] szCSDVersion;
}
alias OSVERSIONINFOW* POSVERSIONINFOW, LPOSVERSIONINFOW;

struct OSVERSIONINFOEXA {
	бцел     dwOSVersionInfoSize;
	бцел     dwMajorVersion;
	бцел     dwMinorVersion;
	бцел     dwBuildNumber;
	бцел     dwPlatformId;
	сим[128] szCSDVersion;
	бкрат      wServicePackMajor;
	бкрат      wServicePackMinor;
	бкрат      wSuiteMask;
	ббайт      wProductType;
	ббайт      wReserved;
}
alias OSVERSIONINFOEXA* POSVERSIONINFOEXA, LPOSVERSIONINFOEXA;

struct OSVERSIONINFOEXW {
	бцел      dwOSVersionInfoSize;
	бцел      dwMajorVersion;
	бцел      dwMinorVersion;
	бцел      dwBuildNumber;
	бцел      dwPlatformId;
	шим[128] szCSDVersion;
	бкрат       wServicePackMajor;
	бкрат       wServicePackMinor;
	бкрат       wSuiteMask;
	ббайт       wProductType;
	ббайт       wReserved;
}
alias OSVERSIONINFOEXW* POSVERSIONINFOEXW, LPOSVERSIONINFOEXW;

align(2) struct IMAGE_VXD_HEADER {
	бкрат     e32_magic;
	ббайт     e32_border;
	ббайт     e32_worder;
	бцел    e32_level;
	бкрат     e32_cpu;
	бкрат     e32_os;
	бцел    e32_ver;
	бцел    e32_mflags;
	бцел    e32_mpages;
	бцел    e32_startobj;
	бцел    e32_eip;
	бцел    e32_stackobj;
	бцел    e32_esp;
	бцел    e32_pagesize;
	бцел    e32_lastpagesize;
	бцел    e32_fixupsize;
	бцел    e32_fixupsum;
	бцел    e32_ldrsize;
	бцел    e32_ldrsum;
	бцел    e32_objtab;
	бцел    e32_objcnt;
	бцел    e32_objmap;
	бцел    e32_itermap;
	бцел    e32_rsrctab;
	бцел    e32_rsrccnt;
	бцел    e32_restab;
	бцел    e32_enttab;
	бцел    e32_dirtab;
	бцел    e32_dircnt;
	бцел    e32_fpagetab;
	бцел    e32_frectab;
	бцел    e32_impmod;
	бцел    e32_impmodcnt;
	бцел    e32_impproc;
	бцел    e32_pagesum;
	бцел    e32_datapage;
	бцел    e32_preload;
	бцел    e32_nrestab;
	бцел    e32_cbnrestab;
	бцел    e32_nressum;
	бцел    e32_autodata;
	бцел    e32_debuginfo;
	бцел    e32_debuglen;
	бцел    e32_instpreload;
	бцел    e32_instdemand;
	бцел    e32_heapsize;
	ббайт[12] e32_res3;
	бцел    e32_winresoff;
	бцел    e32_winreslen;
	бкрат     e32_devid;
	бкрат     e32_ddkver;
}
alias IMAGE_VXD_HEADER* PIMAGE_VXD_HEADER;
+/
///////////////////////////////////
align(4):
struct IMAGE_FILE_HEADER {
	бкрат  Machine;
	бкрат  NumberOfSections;
	бцел TimeDateStamp;
	бцел PointerToSymbolTable;
	бцел NumberOfSymbols;
	бкрат  SizeOfOptionalHeader;
	бкрат  Characteristics;
}
alias IMAGE_FILE_HEADER* PIMAGE_FILE_HEADER;
// const IMAGE_SIZEOF_FILE_HEADER = IMAGE_FILE_HEADER.sizeof;

align(4):
struct ФАЙЛЗАГ_ОБРАЗА {
    бкрат    Машина;
    бкрат    ЧлоСекций;
    бцел      ШтампВремени;
    бцел      УкНаСимТаб;
    бцел      ЧлоСим;
    бкрат    РазмОпцЗаг;
    бкрат    Характеристики;
}
alias ФАЙЛЗАГ_ОБРАЗА ФЗАГОБР;
////////////////////////////////////



struct IMAGE_DATA_DIRECTORY {
	бцел VirtualAddress;
	бцел Size;
}
alias IMAGE_DATA_DIRECTORY* PIMAGE_DATA_DIRECTORY;

struct ПАПКА_ДАННЫХ_ОБРАЗА //IMAGE_DATA_DIRECTORY
 {
	бцел ВиртАдрес;
	бцел Размер;
}
alias ПАПКА_ДАННЫХ_ОБРАЗА ПАПДАНОБР;
/////////////////////////////////////////////////////

struct IMAGE_OPTIONAL_HEADER32 {
	бкрат  Magic;
	ббайт  MajorLinkerVersion;
	ббайт  MinorLinkerVersion;
	бцел SizeOfCode;
	бцел SizeOfInitializedData;
	бцел SizeOfUninitializedData;
	бцел AddressOfEntryPoint;
	бцел BaseOfCode;
	бцел BaseOfData;
	бцел ImageBase;
	бцел SectionAlignment;
	бцел FileAlignment;
	бкрат  MajorOperatingSystemVersion;
	бкрат  MinorOperatingSystemVersion;
	бкрат  MajorImageVersion;
	бкрат  MinorImageVersion;
	бкрат  MajorSubsystemVersion;
	бкрат  MinorSubsystemVersion;
	бцел Win32VersionValue;
	бцел SizeOfImage;
	бцел SizeOfHeaders;
	бцел CheckSum;
	бкрат  Subsystem;
	бкрат  DllCharacteristics;
	бцел SizeOfStackReserve;
	бцел SizeOfStackCommit;
	бцел SizeOfHeapReserve;
	бцел SizeOfHeapCommit;
	бцел LoaderFlags;
	бцел NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY[16] DataDirectory;//ПРазмОбраза.ЧлоПапЗап
}
alias IMAGE_OPTIONAL_HEADER32* PIMAGE_OPTIONAL_HEADER32;

struct IMAGE_OPTIONAL_HEADER64 {
	бкрат      Magic;
	ббайт      MajorLinkerVersion;
	ббайт      MinorLinkerVersion;
	бцел     SizeOfCode;
	бцел     SizeOfInitializedData;
	бцел     SizeOfUninitializedData;
	бцел     AddressOfEntryPoint;
	бцел     BaseOfCode;
	ULONGLONG ImageBase;
	бцел     SectionAlignment;
	бцел     FileAlignment;
	бкрат      MajorOperatingSystemVersion;
	бкрат      MinorOperatingSystemVersion;
	бкрат      MajorImageVersion;
	бкрат      MinorImageVersion;
	бкрат      MajorSubsystemVersion;
	бкрат      MinorSubsystemVersion;
	бцел     Win32VersionValue;
	бцел     SizeOfImage;
	бцел     SizeOfHeaders;
	бцел     CheckSum;
	бкрат      Subsystem;
	бкрат      DllCharacteristics;
	ULONGLONG SizeOfStackReserve;
	ULONGLONG SizeOfStackCommit;
	ULONGLONG SizeOfHeapReserve;
	ULONGLONG SizeOfHeapCommit;
	бцел     LoaderFlags;
	бцел     NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY[16] DataDirectory;
}
alias IMAGE_OPTIONAL_HEADER64* PIMAGE_OPTIONAL_HEADER64;

struct ОПЦЗАГ_ОБРАЗА //IMAGE_OPTIONAL_HEADER32
 {
    //
    // Стандартные поля.
    //
    бкрат  Маг;
    ббайт  СтаршВерсКомпоновщика;
    ббайт   МладшВерсКомпоновщика;
    бцел   РазмерКода;
    бцел   РазмерИнициализДанных;
    бцел   РазмерНеинициализДанных;
    бцел   АдресТочкиВхода;
    бцел   ОваКода;
    бцел   ОваДанных;
    //
    // дополнительные поля НТ.
    //
    бцел   ОваОбраза;
    бцел   РаскладСекц;
    бцел   РаскладФайла;
    бкрат  СтаршВерсОС;
    бкрат  МладшВерсОС;
    бкрат  СтаршВерсОбр;
    бкрат  МладшВерсОбр;
    бкрат  СтаршВерсПодсист;
    бкрат  МладшВерсПодсист;
    бцел   ЗначВерсВин32;
    бцел   РазмерОбраза;
    бцел   РазмерЗагов;
    бцел   КСумма;
    бкрат  Подсистема;
    бкрат  ХарактеристикиДЛЛ;
    бцел   РазмерСтэкРезерва;
    бцел   РазмерСтэкКоммит;
    бцел   РазмерРезерваКучи;
    бцел   РазмерКоммитКучи;
    бцел   ФлагиЗагрузчика;
    бцел   ЧлоОВАиРазмеры;

    ПАПДАНОБР ПапкаДанных[16];
}
alias ОПЦЗАГ_ОБРАЗА ОПЦЗАГОБР;
////////////////////////////////////////////////

struct IMAGE_ROM_OPTIONAL_HEADER {
	бкрат     Magic;
	ббайт     MajorLinkerVersion;
	ббайт     MinorLinkerVersion;
	бцел    SizeOfCode;
	бцел    SizeOfInitializedData;
	бцел    SizeOfUninitializedData;
	бцел    AddressOfEntryPoint;
	бцел    BaseOfCode;
	бцел    BaseOfData;
	бцел    BaseOfBss;
	бцел    GprMask;
	бцел[4] CprMask;
	бцел    GpValue;
}
alias IMAGE_ROM_OPTIONAL_HEADER* PIMAGE_ROM_OPTIONAL_HEADER;

struct ОПЦЗАГ_ОБРАЗА_РОМ {
	бкрат     Маг;
	ббайт     СтаршВерсКомпоновщика;
	ббайт     МладшВерсКомпоновщика;
	бцел    РазмерКода;
	бцел    РазмерИнициализДанных;
	бцел    РазмерНеинициализДанных;
	бцел    АдресТочкиВхода;
	бцел    ОваКода;
	бцел    ОваДанных;
	бцел    ОваБсс;
	бцел    МаскаГпр;
	бцел[4] МаскаЦпр;
	бцел    ЗначениеГп;
}
alias ОПЦЗАГ_ОБРАЗА_РОМ ОПЦЗАГОБРРОМ;
///////////////////////////////////////////////////////////////////
align(2):
struct IMAGE_DOS_HEADER {      // ДОС .EXE header
    бкрат   e_magic;                     // Magic number
    бкрат   e_cblp;                      // Bytes on last page of файл
    бкрат   e_cp;                        // Pages in файл
    бкрат   e_crlc;                      // Relocations
    бкрат   e_cparhdr;                   // Size of header in paragraphs
    бкрат   e_minalloc;                  // Minimum extra paragraphs needed
    бкрат   e_maxalloc;                  // Maximum extra paragraphs needed
    бкрат   e_ss;                        // Initial (relative) SS value
    бкрат   e_sp;                        // Initial SP value
    бкрат   e_csum;                      // Checksum
    бкрат   e_ip;                        // Initial IP value
    бкрат   e_cs;                        // Initial (relative) CS value
    бкрат   e_lfarlc;                    // File адрес of relocation table
    бкрат   e_ovno;                      // Overlay number
    бкрат   e_res[4];                    // Reserved words
    бкрат   e_oemid;                     // OEM identifier (for e_oeminfo)
    бкрат   e_oeminfo;                   // OEM information; e_oemid specific
    бкрат   e_res2[10];                  // Reserved words
    цел      e_lfanew;                    // File адрес of new exe header
}

align(2):
struct ЗАГОЛОВОК_ОБРАЗА_ДОС //IMAGE_DOS_HEADER
 {
	бкрат     маг;
	бкрат     члобайтпослстр;//число байтов последней страницы
	бкрат     члопар; //число страниц в файле
	бкрат     релок;//релокации
	бкрат     члопарвзаг;//число параграфов в заголовке
	бкрат     минтребдоппараг;//минимальное необходимое число дополнительных параграфов
	бкрат     макстребдоппараг;//максимальное число необходимых доп. параграфов
	бкрат     сс;//Начальное (относительное) значение SS
	бкрат     сп;//Начальное значение SP
	бкрат     кс;//контрольная сумма
	бкрат     ип;//Начальное значение IP
	бкрат     цс;//Начальное значение CS
	бкрат     фадртабрелок;//Файловый адрес таблицы релокаций
	бкрат     номовер;//Номер оверлея
	бкрат[4]  резерв;//Резервированные слова
	бкрат     оемид;//Идентификатор OEM
	бкрат     оеминфо;//Информация OEM
	бкрат[10]  резерв2;//Резервированные слова
	LONG      фадрновэкезаг;//Файловый адрес нового заголовка экзэ
}

alias ЗАГОЛОВОК_ОБРАЗА_ДОС ЗАГОБРДОС;
///////////////////////////////////////////////////

/+
struct IMAGE_OS2_HEADER {
	бкрат ne_magic;
	сим ne_ver;
	сим ne_rev;
	бкрат ne_enttab;
	бкрат ne_cbenttab;
	LONG ne_crc;
	бкрат ne_flags;
	бкрат ne_autodata;
	бкрат ne_heap;
	бкрат ne_stack;
	LONG ne_csip;
	LONG ne_sssp;
	бкрат ne_cseg;
	бкрат ne_cmod;
	бкрат ne_cbnrestab;
	бкрат ne_segtab;
	бкрат ne_rsrctab;
	бкрат ne_restab;
	бкрат ne_modtab;
	бкрат ne_imptab;
	LONG ne_nrestab;
	бкрат ne_cmovent;
	бкрат ne_align;
	бкрат ne_cres;
	ббайт ne_exetyp;
	ббайт ne_flagsothers;
	бкрат ne_pretthunks;
	бкрат ne_psegrefbytes;
	бкрат ne_swaparea;
	бкрат ne_expver;
}
alias IMAGE_OS2_HEADER* PIMAGE_OS2_HEADER;

align(4) struct IMAGE_NT_HEADERS32 {
	бцел                 Signature;
	IMAGE_FILE_HEADER     FileHeader;
	IMAGE_OPTIONAL_HEADER OptionalHeader;
}
alias IMAGE_NT_HEADERS32* PIMAGE_NT_HEADERS32;

align(4) struct IMAGE_NT_HEADERS64 {
	бцел                 Signature;
	IMAGE_FILE_HEADER     FileHeader;
	IMAGE_OPTIONAL_HEADER OptionalHeader;
}
alias IMAGE_NT_HEADERS64* PIMAGE_NT_HEADERS64;

struct IMAGE_ROM_HEADERS {
	IMAGE_FILE_HEADER         FileHeader;
	IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
}
alias IMAGE_ROM_HEADERS* PIMAGE_ROM_HEADERS;
+/

////////////////////////////////////////
struct IMAGE_SECTION_HEADER {
	ббайт[8] Name;//ПРазмОбраза.РазмКратИмени
	union _Misc {
		бцел PhysicalAddress;
		бцел VirtualSize;
	}
	_Misc Misc;
	бцел VirtualAddress;
	бцел SizeOfRawData;
	бцел PointerToRawData;
	бцел PointerToRelocations;
	бцел PointerToLinenumbers;
	бкрат  NumberOfRelocations;
	бкрат  NumberOfLinenumbers;
	бцел Characteristics;
}
alias IMAGE_SECTION_HEADER* PIMAGE_SECTION_HEADER;

struct ЗАГОЛОВОК_СЕКЦИИ_ОБРАЗА //IMAGE_SECTION_HEADER
 {
	ббайт[8] Имя;//ПРазмОбраза.РазмКратИмени
	union _Разное {
		бцел ФизичАдрес;
		бцел ВиртРазмер;
	}
	_Разное Разное;
	бцел ВиртАдрес;
	бцел РазмерНеобрДанных;
	бцел УкНаНеобрДанные;
	бцел УкНаРелокации;
	бцел УкНаНомераСтрок;
	бкрат  ЧлоРелокаций;
	бкрат  ЧлоНОмеровСтрок;
	бцел Характеристики;
}
alias ЗАГОЛОВОК_СЕКЦИИ_ОБРАЗА ЗАГСЕКЦОБР;

//////////////////////////////////////

/+
struct IMAGE_SYMBOL {
	union _N {
		ббайт[8]   ShortName;
		struct Name {
			бцел Short;
			бцел Long;
		}
		PBYTE[2]  LongName;
	}
	_N    N;
	бцел Value;
	SHORT SectionNumber;
	бкрат  Type;
	ббайт  StorageClass;
	ббайт  NumberOfAuxSymbols;
}
alias IMAGE_SYMBOL* PIMAGE_SYMBOL;

union IMAGE_AUX_SYMBOL {
	struct _Sym {
		бцел           TagIndex;
		union _Misc {
			struct _LnSz {
				бкрат    Linenumber;
				бкрат    Size;
			}
			_LnSz       LnSz;
			бцел       TotalSize;
		}
		_Misc Misc;
		union _FcnAry {
			struct _Function {
				бцел   PointerToLinenumber;
				бцел   PointerToNextFunction;
			}
			_Function   Function;
			struct _Array {
				бкрат[4] Dimension;
			}
			_Array      Array;
		}
		_FcnAry         FcnAry;
		бкрат            TvIndex;
	}
	_Sym                Sym;
	struct _File {
		ббайт[IMAGE_SIZEOF_SYMBOL] Name;
	}
	_File               File;
	struct _Section {
		бцел           Length;
		бкрат            NumberOfRelocations;
		бкрат            NumberOfLinenumbers;
		бцел           CheckSum;
		SHORT           Number;
		ббайт            Selection;
	}
	_Section            Section;
}
alias IMAGE_AUX_SYMBOL* PIMAGE_AUX_SYMBOL;

struct IMAGE_COFF_SYMBOLS_HEADER {
	бцел NumberOfSymbols;
	бцел LvaToFirstSymbol;
	бцел NumberOfLinenumbers;
	бцел LvaToFirstLinenumber;
	бцел RvaToFirstByteOfCode;
	бцел RvaToLastByteOfCode;
	бцел RvaToFirstByteOfData;
	бцел RvaToLastByteOfData;
}
alias IMAGE_COFF_SYMBOLS_HEADER* PIMAGE_COFF_SYMBOLS_HEADER;

struct IMAGE_RELOCATION {
	union {
		бцел VirtualAddress;
		бцел RelocCount;
	}
	бцел     SymbolTableIndex;
	бкрат      Type;
}
alias IMAGE_RELOCATION* PIMAGE_RELOCATION;

align(4) struct IMAGE_BASE_RELOCATION {
	бцел VirtualAddress;
	бцел SizeOfBlock;
}
alias IMAGE_BASE_RELOCATION* PIMAGE_BASE_RELOCATION;

align(2) struct IMAGE_LINENUMBER {
	union _Type {
		бцел SymbolTableIndex;
		бцел VirtualAddress;
	}
	_Type Type;
	бкрат  Linenumber;
}
alias IMAGE_LINENUMBER* PIMAGE_LINENUMBER;

align(4):
struct IMAGE_ARCHIVE_MEMBER_HEADER {
	ббайт[16] Name;
	ббайт[12] Date;
	ббайт[6]  UserID;
	ббайт[6]  GroupID;
	ббайт[8]  Mode;
	ббайт[10] Size;
	ббайт[2]  EndHeader;
}
alias IMAGE_ARCHIVE_MEMBER_HEADER* PIMAGE_ARCHIVE_MEMBER_HEADER;

struct IMAGE_EXPORT_DIRECTORY {
	бцел Characteristics;
	бцел TimeDateStamp;
	бкрат  MajorVersion;
	бкрат  MinorVersion;
	бцел Name;
	бцел Основа;
	бцел NumberOfFunctions;
	бцел NumberOfNames;
	бцел AddressOfFunctions;
	бцел AddressOfNames;
	бцел AddressOfNameOrdinals;
}
alias IMAGE_EXPORT_DIRECTORY* PIMAGE_EXPORT_DIRECTORY;

struct IMAGE_IMPORT_BY_NAME {
	бкрат Hint;
	ббайт _Name;

	ббайт* Name() {
		return &_Name;
	}
}
alias IMAGE_IMPORT_BY_NAME* PIMAGE_IMPORT_BY_NAME;

struct IMAGE_THUNK_DATA32 {
	union _u1 {
		бцел ForwarderString;
		бцел Function;
		бцел Ordinal;
		бцел AddressOfData;
	}
	_u1 u1;
}
alias IMAGE_THUNK_DATA32* PIMAGE_THUNK_DATA32;

struct IMAGE_THUNK_DATA64 {
	union _u1 {
		ULONGLONG ForwarderString;
		ULONGLONG Function;
		ULONGLONG Ordinal;
		ULONGLONG AddressOfData;
	}
	_u1 u1;
}
alias IMAGE_THUNK_DATA64* PIMAGE_THUNK_DATA64;

struct IMAGE_IMPORT_DESCRIPTOR {
	union {
		бцел Characteristics;
		бцел OriginalFirstThunk;
	}
	бцел TimeDateStamp;
	бцел ForwarderChain;
	бцел Name;
	бцел FirstThunk;
}
alias IMAGE_IMPORT_DESCRIPTOR* PIMAGE_IMPORT_DESCRIPTOR;

struct IMAGE_BOUND_IMPORT_DESCRIPTOR {
	бцел TimeDateStamp;
	бкрат  OffsetModuleName;
	бкрат  NumberOfModuleForwarderRefs;
}
alias IMAGE_BOUND_IMPORT_DESCRIPTOR* PIMAGE_BOUND_IMPORT_DESCRIPTOR;

struct IMAGE_BOUND_FORWARDER_REF {
	бцел TimeDateStamp;
	бкрат  OffsetModuleName;
	бкрат  Reserved;
}
alias IMAGE_BOUND_FORWARDER_REF* PIMAGE_BOUND_FORWARDER_REF;

struct IMAGE_TLS_DIRECTORY32 {
	бцел StartAddressOfRawData;
	бцел EndAddressOfRawData;
	бцел AddressOfIndex;
	бцел AddressOfCallBacks;
	бцел SizeOfZeroFill;
	бцел Characteristics;
}
alias IMAGE_TLS_DIRECTORY32* PIMAGE_TLS_DIRECTORY32;

struct IMAGE_TLS_DIRECTORY64 {
	ULONGLONG StartAddressOfRawData;
	ULONGLONG EndAddressOfRawData;
	ULONGLONG AddressOfIndex;
	ULONGLONG AddressOfCallBacks;
	бцел     SizeOfZeroFill;
	бцел     Characteristics;
}
alias IMAGE_TLS_DIRECTORY64* PIMAGE_TLS_DIRECTORY64;

struct IMAGE_RESOURCE_DIRECTORY {
	бцел Characteristics;
	бцел TimeDateStamp;
	бкрат  MajorVersion;
	бкрат  MinorVersion;
	бкрат  NumberOfNamedEntries;
	бкрат  NumberOfIdEntries;
}
alias IMAGE_RESOURCE_DIRECTORY* PIMAGE_RESOURCE_DIRECTORY;

struct IMAGE_RESOURCE_DIRECTORY_ENTRY {
	union {
		/+struct {
			бцел NameOffset:31;
			бцел NameIsString:1;
		}+/
		бцел Name;
		бкрат Id;
	}
	бцел OffsetToData;
		/+struct {
			бцел OffsetToDirectory:31;
			бцел DataIsDirectory:1;
		}+/

	uint NameOffset()        { return Name & 0x7FFFFFFF; }
	бул NameIsString()      { return cast(бул)(Name & 0x80000000); }
	uint OffsetToDirectory() { return OffsetToData & 0x7FFFFFFF; }
	бул DataIsDirectory()   { return cast(бул)(OffsetToData & 0x80000000); }

	uint NameOffset(uint n) {
		Name = (Name & 0x80000000) | (n & 0x7FFFFFFF);
		return n & 0x7FFFFFFF;
	}

	бул NameIsString(бул n) {
		Name = (Name & 0x7FFFFFFF) | (n << 31); return n;
	}

	uint OffsetToDirectory(uint o) {
		OffsetToData = (OffsetToData & 0x80000000) | (o & 0x7FFFFFFF);
		return o & 0x7FFFFFFF;
	}

	бул DataIsDirectory(бул d) {
		OffsetToData = (OffsetToData & 0x7FFFFFFF) | (d << 31); return d;
	}
}
alias IMAGE_RESOURCE_DIRECTORY_ENTRY* PIMAGE_RESOURCE_DIRECTORY_ENTRY;

struct IMAGE_RESOURCE_DIRECTORY_STRING {
	бкрат Length;
	сим _NameString;

	сим* NameString() { return &_NameString; }
}
alias IMAGE_RESOURCE_DIRECTORY_STRING* PIMAGE_RESOURCE_DIRECTORY_STRING;

struct IMAGE_RESOURCE_DIR_STRING_U {
	бкрат  Length;
	шим _NameString;

	шим* NameString() { return &_NameString; }
}
alias IMAGE_RESOURCE_DIR_STRING_U* PIMAGE_RESOURCE_DIR_STRING_U;

struct IMAGE_RESOURCE_DATA_ENTRY {
	бцел OffsetToData;
	бцел Size;
	бцел CodePage;
	бцел Reserved;
}
alias IMAGE_RESOURCE_DATA_ENTRY* PIMAGE_RESOURCE_DATA_ENTRY;

struct IMAGE_LOAD_CONFIG_DIRECTORY {
	бцел    Characteristics;
	бцел    TimeDateStamp;
	бкрат     MajorVersion;
	бкрат     MinorVersion;
	бцел    GlobalFlagsClear;
	бцел    GlobalFlagsSet;
	бцел    CriticalSectionDefaultTimeout;
	бцел    DeCommitFreeBlockThreshold;
	бцел    DeCommitTotalFreeThreshold;
	PVOID    LockPrefixTable;
	бцел    MaximumAllocationSize;
	бцел    VirtualMemoryThreshold;
	бцел    ProcessHeapFlags;
	бцел[4] Reserved;
}
alias IMAGE_LOAD_CONFIG_DIRECTORY* PIMAGE_LOAD_CONFIG_DIRECTORY;

struct IMAGE_LOAD_CONFIG_DIRECTORY64 {
	бцел     Characteristics;
	бцел     TimeDateStamp;
	бкрат      MajorVersion;
	бкрат      MinorVersion;
	бцел     GlobalFlagsClear;
	бцел     GlobalFlagsSet;
	бцел     CriticalSectionDefaultTimeout;
	ULONGLONG DeCommitFreeBlockThreshold;
	ULONGLONG DeCommitTotalFreeThreshold;
	ULONGLONG LockPrefixTable;
	ULONGLONG MaximumAllocationSize;
	ULONGLONG VirtualMemoryThreshold;
	ULONGLONG ProcessAffinityMask;
	бцел     ProcessHeapFlags;
	бкрат      CSDFlags;
	бкрат      Reserved1;
	ULONGLONG EditList;
	бцел[2]  Reserved;
}
alias IMAGE_LOAD_CONFIG_DIRECTORY64* PIMAGE_LOAD_CONFIG_DIRECTORY64;

struct IMAGE_RUNTIME_FUNCTION_ENTRY {
	бцел BeginAddress;
	бцел EndAddress;
	PVOID ExceptionHandler;
	PVOID HandlerData;
	бцел PrologEndAddress;
}
alias IMAGE_RUNTIME_FUNCTION_ENTRY* PIMAGE_RUNTIME_FUNCTION_ENTRY;

struct IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
	uint      FuncStart;
	union {
		ubyte PrologLen;
		uint  _bf;
	}
/+
	unsigned int FuncLen:22;
	unsigned int ThirtyTwoBit:1;
	unsigned int ExceptionFlag:1;
+/
	uint FuncLen()       { return (_bf >> 8) & 0x3FFFFF; }
	бул ThirtyTwoBit()  { return cast(бул)(_bf & 0x40000000); }
	бул ExceptionFlag() { return cast(бул)(_bf & 0x80000000); }

	uint FuncLen(uint f) {
		_bf = (_bf & ~0x3FFFFF00) | ((f & 0x3FFFFF) << 8); return f & 0x3FFFFF;
	}

	бул ThirtyTwoBit(бул t) {
		_bf = (_bf & ~0x40000000) | (t << 30); return t;
	}

	бул ExceptionFlag(бул e) {
		_bf = (_bf & ~0x80000000) | (e << 31); return e;
	}
}
alias IMAGE_CE_RUNTIME_FUNCTION_ENTRY* PIMAGE_CE_RUNTIME_FUNCTION_ENTRY;

struct IMAGE_DEBUG_DIRECTORY {
	бцел Characteristics;
	бцел TimeDateStamp;
	бкрат  MajorVersion;
	бкрат  MinorVersion;
	бцел Type;
	бцел SizeOfData;
	бцел AddressOfRawData;
	бцел PointerToRawData;
}
alias IMAGE_DEBUG_DIRECTORY* PIMAGE_DEBUG_DIRECTORY;

struct FPO_DATA {
	бцел  ulOffStart;
	бцел  cbProcSize;
	бцел  cdwLocals;
	бкрат   cdwParams;
	ubyte  cbProlog;
	ubyte  _bf;
/+
	бкрат cbRegs:3;
	бкрат fHasSEH:1;
	бкрат fUseBP:1;
	бкрат reserved:1;
	бкрат cbFrame:2;
+/
	ubyte cbRegs()  { return cast(ubyte)(_bf & 0x07); }
	бул fHasSEH()  { return cast(бул)(_bf & 0x08); }
	бул fUseBP()   { return cast(бул)(_bf & 0x10); }
	бул reserved() { return cast(бул)(_bf & 0x20); }
	ubyte cbFrame() { return cast(ubyte)(_bf >> 6); }

	ubyte cbRegs(ubyte c) {
		_bf = cast(ubyte) ((_bf & ~0x07) | (c & 0x07));
		return cast(ubyte)(c & 0x07);
	}

	бул fHasSEH(бул f)  { _bf = cast(ubyte)((_bf & ~0x08) | (f << 3)); return f; }
	бул fUseBP(бул f)   { _bf = cast(ubyte)((_bf & ~0x10) | (f << 4)); return f; }
	бул reserved(бул r) { _bf = cast(ubyte)((_bf & ~0x20) | (r << 5)); return r; }

	ubyte cbFrame(ubyte c) {
		_bf = cast(ubyte) ((_bf & ~0xC0) | ((c & 0x03) << 6));
		return cast(ubyte)(c & 0x03);
	}
}
alias FPO_DATA* PFPO_DATA;

struct IMAGE_DEBUG_MISC {
	бцел   DataType;
	бцел   Length;
	бул Unicode;
	ббайт[3] Reserved;
	ббайт    _Data;

	ббайт*   Data() { return &_Data; }
}
alias IMAGE_DEBUG_MISC* PIMAGE_DEBUG_MISC;

struct IMAGE_FUNCTION_ENTRY {
	бцел StartingAddress;
	бцел EndingAddress;
	бцел EndOfPrologue;
}
alias IMAGE_FUNCTION_ENTRY* PIMAGE_FUNCTION_ENTRY;

struct IMAGE_FUNCTION_ENTRY64 {
	ULONGLONG     StartingAddress;
	ULONGLONG     EndingAddress;
	union {
		ULONGLONG EndOfPrologue;
		ULONGLONG UnwindInfoAddress;
	}
}
alias IMAGE_FUNCTION_ENTRY64* PIMAGE_FUNCTION_ENTRY64;
+/

////////////////////////////////////////////
struct IMAGE_SEPARATE_DEBUG_HEADER {
	бкрат     Signature;
	бкрат     Flags;
	бкрат     Machine;
	бкрат     Characteristics;
	бцел    TimeDateStamp;
	бцел    CheckSum;
	бцел    ImageBase;
	бцел    SizeOfImage;
	бцел    NumberOfSections;
	бцел    ExportedNamesSize;
	бцел    DebugDirectorySize;
	бцел    SectionAlignment;
	бцел[2] Reserved;
}
alias IMAGE_SEPARATE_DEBUG_HEADER* PIMAGE_SEPARATE_DEBUG_HEADER;

struct ОТДЕЛЬНЫЙ_ОТЛАДОЧНЫЙ_ЗАГОЛОВОК_ОБРАЗА //IMAGE_SEPARATE_DEBUG_HEADER
 {
    бкрат        Сигнатура;
    бкрат        Флаги;
    бкрат        Машина;
    бкрат        Characteristics;
    бцел       ШтампВремени;
    бцел       КСумма;
    бцел       ОваОбраза;
    бцел       РазмерОбраза;
    бцел       ЧлоСекций;
    бцел       РазмЭкпортИмён;
    бцел       РазмПапкиОтлад;
    бцел       РаскладСекц;
    бцел       Резерв[2];
}
alias ОТДЕЛЬНЫЙ_ОТЛАДОЧНЫЙ_ЗАГОЛОВОК_ОБРАЗА ОТДЕЛЬНОТЛАДЗАГОБР;
///////////////////////////////////////
struct IMAGE_NT_HEADERS {
    бцел Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER OptionalHeader;
}


struct ЗАГОЛОВКИ_ОБРАЗА_НТ //IMAGE_NT_HEADERS
 {
    бцел Сигнатура;
    ФЗАГОБР ФайлЗаг;
    ОПЦЗАГОБР ОпцЗаг;
}
alias ЗАГОЛОВКИ_ОБРАЗА_НТ НТОБРЗАГИ;
////////////////////////////////////////

/+
enum SERVICE_NODE_TYPE {
	DriverType               = SERVICE_KERNEL_DRIVER,
	FileSystemType           = SERVICE_FILE_SYSTEM_DRIVER,
	Win32ServiceOwnProcess   = SERVICE_WIN32_OWN_PROCESS,
	Win32ServiceShareProcess = SERVICE_WIN32_SHARE_PROCESS,
	AdapterType              = SERVICE_ADAPTER,
	RecognizerType           = SERVICE_RECOGNIZER_DRIVER
}

enum SERVICE_LOAD_TYPE {
	BootLoad    = SERVICE_BOOT_START,
	SystemLoad  = SERVICE_SYSTEM_START,
	AutoLoad    = SERVICE_AUTO_START,
	DemandLoad  = SERVICE_DEMAND_START,
	DisableLoad = SERVICE_DISABLED
}

enum SERVICE_ERROR_TYPE {
	IgnoreError   = SERVICE_ERROR_IGNORE,
	NormalError   = SERVICE_ERROR_NORMAL,
	SevereError   = SERVICE_ERROR_SEVERE,
	CriticalError = SERVICE_ERROR_CRITICAL
}
alias SERVICE_ERROR_TYPE _CM_ERROR_CONTROL_TYPE;

//DAC: According to MSJ, 'UnderTheHood', May 1996, this
// structure is not documented in any official Microsoft header file.
alias void EXCEPTION_REGISTRATION_RECORD;

align:
struct NT_TIB {
	EXCEPTION_REGISTRATION_RECORD *ExceptionList;
	PVOID StackBase;
	PVOID StackLimit;
	PVOID SubSystemTib;
	union {
		PVOID FiberData;
		бцел Version;
	}
	PVOID ArbitraryUserPointer;
	NT_TIB *Self;
}
alias NT_TIB* PNT_TIB;

struct REPARSE_DATA_BUFFER {
	бцел  ReparseTag;
	бкрат   ReparseDataLength;
	бкрат   Reserved;
	union {
		struct _GenericReparseBuffer {
			ббайт  _DataBuffer;

			ббайт* DataBuffer() { return &_DataBuffer; }
		}
		_GenericReparseBuffer GenericReparseBuffer;
		struct _SymbolicLinkReparseBuffer {
			бкрат  SubstituteNameOffset;
			бкрат  SubstituteNameLength;
			бкрат  PrintNameOffset;
			бкрат  PrintNameLength;
			// ??? This is in MinGW, but absent in MSDN docs
			ULONG Flags;
			шим _PathBuffer;

			шим* PathBuffer() { return &_PathBuffer; }
		}
		_SymbolicLinkReparseBuffer SymbolicLinkReparseBuffer;
		struct _MountPointReparseBuffer {
			бкрат  SubstituteNameOffset;
			бкрат  SubstituteNameLength;
			бкрат  PrintNameOffset;
			бкрат  PrintNameLength;
			шим _PathBuffer;

			шим* PathBuffer() { return &_PathBuffer; }
		}
		_MountPointReparseBuffer MountPointReparseBuffer;
	}
}
alias REPARSE_DATA_BUFFER *PREPARSE_DATA_BUFFER;

struct REPARSE_GUID_DATA_BUFFER {
	бцел    ReparseTag;
	бкрат     ReparseDataLength;
	бкрат     Reserved;
	GUID     ReparseGuid;
	struct _GenericReparseBuffer {
		ббайт _DataBuffer;

		ббайт* DataBuffer() { return &_DataBuffer; }
	}
	_GenericReparseBuffer GenericReparseBuffer;
}
alias REPARSE_GUID_DATA_BUFFER* PREPARSE_GUID_DATA_BUFFER;

const size_t
	REPARSE_DATA_BUFFER_HEADER_SIZE = REPARSE_DATA_BUFFER.GenericReparseBuffer.offsetof,
	REPARSE_GUID_DATA_BUFFER_HEADER_SIZE = REPARSE_GUID_DATA_BUFFER.GenericReparseBuffer.offsetof,
	MAXIMUM_REPARSE_DATA_BUFFER_SIZE = 16384;


struct REPARSE_POINT_INFORMATION {
	бкрат ReparseDataLength;
	бкрат UnparsedNameLength;
}
alias REPARSE_POINT_INFORMATION* PREPARSE_POINT_INFORMATION;

union FILE_SEGMENT_ELEMENT {
	PVOID64   Buffer;
	ULONGLONG Alignment;
}
alias FILE_SEGMENT_ELEMENT* PFILE_SEGMENT_ELEMENT;

// JOBOBJECT_BASIC_LIMIT_INFORMATION.LimitFlags constants
const бцел
	JOB_OBJECT_LIMIT_WORKINGSET                 = 0x0001,
	JOB_OBJECT_LIMIT_PROCESS_TIME               = 0x0002,
	JOB_OBJECT_LIMIT_JOB_TIME                   = 0x0004,
	JOB_OBJECT_LIMIT_ACTIVE_PROCESS             = 0x0008,
	JOB_OBJECT_LIMIT_AFFINITY                   = 0x0010,
	JOB_OBJECT_LIMIT_PRIORITY_CLASS             = 0x0020,
	JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME          = 0x0040,
	JOB_OBJECT_LIMIT_SCHEDULING_CLASS           = 0x0080,
	JOB_OBJECT_LIMIT_PROCESS_MEMORY             = 0x0100,
	JOB_OBJECT_LIMIT_JOB_MEMORY                 = 0x0200,
	JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 0x0400,
	JOB_OBJECT_BREAKAWAY_OK                     = 0x0800,
	JOB_OBJECT_SILENT_BREAKAWAY                 = 0x1000;

// JOBOBJECT_BASIC_UI_RESTRICTIONS.UIRestrictionsClass constants
const бцел
	JOB_OBJECT_UILIMIT_HANDLES          = 0x0001,
	JOB_OBJECT_UILIMIT_READCLIPBOARD    = 0x0002,
	JOB_OBJECT_UILIMIT_WRITECLIPBOARD   = 0x0004,
	JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 0x0008,
	JOB_OBJECT_UILIMIT_DISPLAYSETTINGS  = 0x0010,
	JOB_OBJECT_UILIMIT_GLOBALATOMS      = 0x0020,
	JOB_OBJECT_UILIMIT_DESKTOP          = 0x0040,
	JOB_OBJECT_UILIMIT_EXITWINDOWS      = 0x0080;

// JOBOBJECT_SECURITY_LIMIT_INFORMATION.SecurityLimitFlags constants
const бцел
	JOB_OBJECT_SECURITY_NO_ADMIN         = 0x0001,
	JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = 0x0002,
	JOB_OBJECT_SECURITY_ONLY_TOKEN       = 0x0004,
	JOB_OBJECT_SECURITY_FILTER_TOKENS    = 0x0008;

// JOBOBJECT_END_OF_JOB_TIME_INFORMATION.EndOfJobTimeAction constants
enum : бцел {
	JOB_OBJECT_TERMINATE_AT_END_OF_JOB,
	JOB_OBJECT_POST_AT_END_OF_JOB
}

enum : бцел {
	JOB_OBJECT_MSG_END_OF_JOB_TIME = 1,
	JOB_OBJECT_MSG_END_OF_PROCESS_TIME,
	JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT,
	JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO,
	JOB_OBJECT_MSG_NEW_PROCESS,
	JOB_OBJECT_MSG_EXIT_PROCESS,
	JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS,
	JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT,
	JOB_OBJECT_MSG_JOB_MEMORY_LIMIT
}

enum JOBOBJECTINFOCLASS {
	JobObjectBasicAccountingInformation = 1,
	JobObjectBasicLimitInformation,
	JobObjectBasicProcessIdList,
	JobObjectBasicUIRestrictions,
	JobObjectSecurityLimitInformation,
	JobObjectEndOfJobTimeInformation,
	JobObjectAssociateCompletionPortInformation,
	JobObjectBasicAndIoAccountingInformation,
	JobObjectExtendedLimitInformation,
	JobObjectJobSetInformation,
	MaxJobObjectInfoClass
}

struct JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
	БОЛЬШЕЦЕЛ TotalUserTime;
	БОЛЬШЕЦЕЛ TotalKernelTime;
	БОЛЬШЕЦЕЛ ThisPeriodTotalUserTime;
	БОЛЬШЕЦЕЛ ThisPeriodTotalKernelTime;
	бцел         TotalPageFaultCount;
	бцел         TotalProcesses;
	бцел         ActiveProcesses;
	бцел         TotalTerminatedProcesses;
}
alias JOBOBJECT_BASIC_ACCOUNTING_INFORMATION* PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;

struct JOBOBJECT_BASIC_LIMIT_INFORMATION {
	БОЛЬШЕЦЕЛ PerProcessUserTimeLimit;
	БОЛЬШЕЦЕЛ PerJobUserTimeLimit;
	бцел         LimitFlags;
	т_мера        MinimumWorkingSetSize;
	т_мера        MaximumWorkingSetSize;
	бцел         ActiveProcessLimit;
	ULONG_PTR     Affinity;
	бцел         PriorityClass;
	бцел         SchedulingClass;
}
alias JOBOBJECT_BASIC_LIMIT_INFORMATION* PJOBOBJECT_BASIC_LIMIT_INFORMATION;

struct JOBOBJECT_BASIC_PROCESS_ID_LIST {
	бцел     NumberOfAssignedProcesses;
	бцел     NumberOfProcessIdsInList;
	ULONG_PTR _ProcessIdList;

	ULONG_PTR* ProcessIdList() { return &_ProcessIdList; }
}
alias JOBOBJECT_BASIC_PROCESS_ID_LIST* PJOBOBJECT_BASIC_PROCESS_ID_LIST;

struct JOBOBJECT_BASIC_UI_RESTRICTIONS {
	бцел UIRestrictionsClass;
}
alias JOBOBJECT_BASIC_UI_RESTRICTIONS* PJOBOBJECT_BASIC_UI_RESTRICTIONS;

struct JOBOBJECT_SECURITY_LIMIT_INFORMATION {
	бцел             SecurityLimitFlags;
	HANDLE            JobToken;
	PTOKEN_GROUPS     SidsToDisable;
	PTOKEN_PRIVILEGES PrivilegesToDelete;
	PTOKEN_GROUPS     RestrictedSids;
}
alias JOBOBJECT_SECURITY_LIMIT_INFORMATION* PJOBOBJECT_SECURITY_LIMIT_INFORMATION;

struct JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
	бцел EndOfJobTimeAction;
}
alias JOBOBJECT_END_OF_JOB_TIME_INFORMATION* PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;

struct JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
	PVOID  CompletionKey;
	HANDLE CompletionPort;
}
alias JOBOBJECT_ASSOCIATE_COMPLETION_PORT* PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;

struct JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
	JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
	IO_COUNTERS IoInfo;
}
alias JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;

struct JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
	JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
	IO_COUNTERS IoInfo;
	т_мера      ProcessMemoryLimit;
	т_мера      JobMemoryLimit;
	т_мера      PeakProcessMemoryUsed;
	т_мера      PeakJobMemoryUsed;
}
alias JOBOBJECT_EXTENDED_LIMIT_INFORMATION* PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;

struct JOBOBJECT_JOBSET_INFORMATION {
	бцел MemberLevel;
}
alias JOBOBJECT_JOBSET_INFORMATION* PJOBOBJECT_JOBSET_INFORMATION;

// MinGW: Making these defines conditional on WINVER will break ddk includes
//static if (WINVER >= 0x0500) {

const бцел
	ES_SYSTEM_REQUIRED  = 0x00000001,
	ES_DISPLAY_REQUIRED = 0x00000002,
	ES_USER_PRESENT     = 0x00000004,
	ES_CONTINUOUS       = 0x80000000;

enum LATENCY_TIME {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
}
alias LATENCY_TIME* PLATENCY_TIME;

enum SYSTEM_POWER_STATE {
	PowerSystemUnspecified,
	PowerSystemWorking,
	PowerSystemSleeping1,
	PowerSystemSleeping2,
	PowerSystemSleeping3,
	PowerSystemHibernate,
	PowerSystemShutdown,
	PowerSystemMaximum
}
alias SYSTEM_POWER_STATE* PSYSTEM_POWER_STATE;

const POWER_SYSTEM_MAXIMUM = SYSTEM_POWER_STATE.PowerSystemMaximum;

enum POWER_ACTION {
	PowerActionNone,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
}
alias POWER_ACTION* PPOWER_ACTION;

static if (WINVER >= 0x600) {
	enum SYSTEM_POWER_CONDITION {
		PoAc,
		PoDc,
		PoHot,
		PoConditionMaximum
	}
	alias SYSTEM_POWER_CONDITION* PSYSTEM_POWER_CONDITION;
}

enum DEVICE_POWER_STATE {
	PowerDeviceUnspecified,
	PowerDeviceD0,
	PowerDeviceD1,
	PowerDeviceD2,
	PowerDeviceD3,
	PowerDeviceMaximum
}
alias DEVICE_POWER_STATE* PDEVICE_POWER_STATE;

align(4):
struct BATTERY_REPORTING_SCALE {
	бцел Granularity;
	бцел Capacity;
}
alias BATTERY_REPORTING_SCALE* PBATTERY_REPORTING_SCALE;

struct POWER_ACTION_POLICY {
	POWER_ACTION Action;
	ULONG        Flags;
	ULONG        EventCode;
}
alias POWER_ACTION_POLICY* PPOWER_ACTION_POLICY;

// POWER_ACTION_POLICY.Flags constants
const ULONG
	POWER_ACTION_QUERY_ALLOWED  = 0x00000001,
	POWER_ACTION_UI_ALLOWED     = 0x00000002,
	POWER_ACTION_OVERRIDE_APPS  = 0x00000004,
	POWER_ACTION_LIGHTEST_FIRST = 0x10000000,
	POWER_ACTION_LOCK_CONSOLE   = 0x20000000,
	POWER_ACTION_DISABLE_WAKES  = 0x40000000,
	POWER_ACTION_CRITICAL       = 0x80000000;

// POWER_ACTION_POLICY.EventCode constants
const ULONG
	POWER_LEVEL_USER_NOTIFY_TEXT  = 0x00000001,
	POWER_LEVEL_USER_NOTIFY_SOUND = 0x00000002,
	POWER_LEVEL_USER_NOTIFY_EXEC  = 0x00000004,
	POWER_USER_NOTIFY_BUTTON      = 0x00000008,
	POWER_USER_NOTIFY_SHUTDOWN    = 0x00000010,
	POWER_FORCE_TRIGGER_RESET     = 0x80000000;

const size_t
	DISCHARGE_POLICY_CRITICAL = 0,
	DISCHARGE_POLICY_LOW      = 1,
	NUM_DISCHARGE_POLICIES    = 4;

enum : ббайт {
	PO_THROTTLE_NONE,
	PO_THROTTLE_CONSTANT,
	PO_THROTTLE_DEGRADE,
	PO_THROTTLE_ADAPTIVE,
	PO_THROTTLE_MAXIMUM
}

struct SYSTEM_POWER_LEVEL {
	бул             Enable;
	UCHAR[3]            Spare;
	ULONG               BatteryLevel;
	POWER_ACTION_POLICY PowerPolicy;
	SYSTEM_POWER_STATE  MinSystemState;
}
alias SYSTEM_POWER_LEVEL* PSYSTEM_POWER_LEVEL;

struct SYSTEM_POWER_POLICY {
	ULONG               Revision;
	POWER_ACTION_POLICY PowerButton;
	POWER_ACTION_POLICY SleepButton;
	POWER_ACTION_POLICY LidClose;
	SYSTEM_POWER_STATE  LidOpenWake;
	ULONG               Reserved;
	POWER_ACTION_POLICY Idle;
	ULONG               IdleTimeout;
	UCHAR               IdleSensitivity;
	UCHAR               DynamicThrottle;
	UCHAR[2]            Spare2;
	SYSTEM_POWER_STATE  MinSleep;
	SYSTEM_POWER_STATE  MaxSleep;
	SYSTEM_POWER_STATE  ReducedLatencySleep;
	ULONG               WinLogonFlags;
	ULONG               Spare3;
	ULONG               DozeS4Timeout;
	ULONG               BroadcastCapacityResolution;
	SYSTEM_POWER_LEVEL[NUM_DISCHARGE_POLICIES] DischargePolicy;
	ULONG               VideoTimeout;
	бул             VideoDimDisplay;
	ULONG[3]            VideoReserved;
	ULONG               SpindownTimeout;
	бул             OptimizeForPower;
	UCHAR               FanThrottleTolerance;
	UCHAR               ForcedThrottle;
	UCHAR               MinThrottle;
	POWER_ACTION_POLICY OverThrottled;
}
alias SYSTEM_POWER_POLICY* PSYSTEM_POWER_POLICY;

struct SYSTEM_POWER_CAPABILITIES {
	бул                    PowerButtonPresent;
	бул                    SleepButtonPresent;
	бул                    LidPresent;
	бул                    SystemS1;
	бул                    SystemS2;
	бул                    SystemS3;
	бул                    SystemS4;
	бул                    SystemS5;
	бул                    HiberFilePresent;
	бул                    FullWake;
	бул                    VideoDimPresent;
	бул                    ApmPresent;
	бул                    UpsPresent;
	бул                    ThermalControl;
	бул                    ProcessorThrottle;
	UCHAR                      ProcessorMinThrottle;
	UCHAR                      ProcessorMaxThrottle;
	UCHAR[4]                   spare2;
	бул                    DiskSpinDown;
	UCHAR[8]                   spare3;
	бул                    SystemBatteriesPresent;
	бул                    BatteriesAreShortTerm;
	BATTERY_REPORTING_SCALE[3] BatteryScale;
	SYSTEM_POWER_STATE         AcOnLineWake;
	SYSTEM_POWER_STATE         SoftLidWake;
	SYSTEM_POWER_STATE         RtcWake;
	SYSTEM_POWER_STATE         MinDeviceWakeState;
	SYSTEM_POWER_STATE         DefaultLowLatencyWake;
}
alias SYSTEM_POWER_CAPABILITIES* PSYSTEM_POWER_CAPABILITIES;

struct SYSTEM_BATTERY_STATE {
	бул    AcOnLine;
	бул    BatteryPresent;
	бул    Charging;
	бул    Discharging;
	бул[4] Spare1;
	ULONG      MaxCapacity;
	ULONG      RemainingCapacity;
	ULONG      Rate;
	ULONG      EstimatedTime;
	ULONG      DefaultAlert1;
	ULONG      DefaultAlert2;
}
alias SYSTEM_BATTERY_STATE* PSYSTEM_BATTERY_STATE;

enum POWER_INFORMATION_LEVEL {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation,
	ProcessorStateHandler2,
	LastWakeTime,
	LastSleepTime,
	SystemExecutionState,
	SystemPowerStateNotifyHandler,
	ProcessorPowerPolicyAc,
	ProcessorPowerPolicyDc,
	VerifyProcessorPowerPolicyAc,
	VerifyProcessorPowerPolicyDc,
	ProcessorPowerPolicyCurrent
}

//#if 1 /* (WIN32_WINNT >= 0x0500) */
struct SYSTEM_POWER_INFORMATION {
	ULONG MaxIdlenessAllowed;
	ULONG Idleness;
	ULONG TimeRemaining;
	UCHAR CoolingMode;
}
alias SYSTEM_POWER_INFORMATION* PSYSTEM_POWER_INFORMATION;
//#endif

struct PROCESSOR_POWER_POLICY_INFO {
	ULONG    TimeCheck;
	ULONG    DemoteLimit;
	ULONG    PromoteLimit;
	UCHAR    DemotePercent;
	UCHAR    PromotePercent;
	UCHAR[2] Spare;
	uint     _bf;

	бул AllowDemotion()  { return cast(бул)(_bf & 1); }
	бул AllowPromotion() { return cast(бул)(_bf & 2); }

	бул AllowDemotion(бул a)  { _bf = (_bf & ~1) | a; return a; }
	бул AllowPromotion(бул a) { _bf = (_bf & ~2) | (a << 1); return a; }
/+
	ULONG  AllowDemotion : 1;
	ULONG  AllowPromotion : 1;
	ULONG  Reserved : 30;
+/
}
alias PROCESSOR_POWER_POLICY_INFO* PPROCESSOR_POWER_POLICY_INFO;

struct PROCESSOR_POWER_POLICY {
	ULONG    Revision;
	UCHAR    DynamicThrottle;
	UCHAR[3] Spare;
	ULONG    Reserved;
	ULONG    PolicyCount;
	PROCESSOR_POWER_POLICY_INFO[3] Policy;
}
alias PROCESSOR_POWER_POLICY* PPROCESSOR_POWER_POLICY;

struct ADMINISTRATOR_POWER_POLICY {
	SYSTEM_POWER_STATE MinSleep;
	SYSTEM_POWER_STATE MaxSleep;
	ULONG              MinVideoTimeout;
	ULONG              MaxVideoTimeout;
	ULONG              MinSpindownTimeout;
	ULONG              MaxSpindownTimeout;
}
alias ADMINISTRATOR_POWER_POLICY* PADMINISTRATOR_POWER_POLICY;

//}//#endif /* WINVER >= 0x0500 */

extern (Windows) {
	alias void function(PVOID, бцел, PVOID) PIMAGE_TLS_CALLBACK;

	static if (_WIN32_WINNT_ONLY && _WIN32_WINNT >= 0x500) {
		alias LONG function(PEXCEPTION_POINTERS) PVECTORED_EXCEPTION_HANDLER;
		alias void function(PVOID, бул) WAITORTIMERCALLBACKFUNC;
	}
}

static if (WINVER >= 0x501) {
	enum HEAP_INFORMATION_CLASS {
		HeapCompatibilityInformation
	}

	enum ACTIVATION_CONTEXT_INFO_CLASS {
		ActivationContextBasicInformation = 1,
		ActivationContextDetailedInformation,
		AssemblyDetailedInformationInActivationContext,
		FileInformationInAssemblyOfAssemblyInActivationContext
	}

	struct ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
		бцел         ulFlags;
		бцел         ulEncodedAssemblyIdentityLength;
		бцел         ulManifestPathType;
		бцел         ulManifestPathLength;
		БОЛЬШЕЦЕЛ liManifestLastWriteTime;
		бцел         ulPolicyPathType;
		бцел         ulPolicyPathLength;
		БОЛЬШЕЦЕЛ liPolicyLastWriteTime;
		бцел         ulMetadataSatelliteRosterIndex;
		бцел         ulManifestVersionMajor;
		бцел         ulManifestVersionMinor;
		бцел         ulPolicyVersionMajor;
		бцел         ulPolicyVersionMinor;
		бцел         ulAssemblyDirectoryNameLength;
		PCWSTR        lpAssemblyEncodedAssemblyIdentity;
		PCWSTR        lpAssemblyManifestPath;
		PCWSTR        lpAssemblyPolicyPath;
		PCWSTR        lpAssemblyDirectoryName;
	}
	alias ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION*
	  PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
	alias CPtr!(ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION)
	  PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;

	struct ACTIVATION_CONTEXT_DETAILED_INFORMATION {
		бцел  dwFlags;
		бцел  ulFormatVersion;
		бцел  ulAssemblyCount;
		бцел  ulRootManifestPathType;
		бцел  ulRootManifestPathChars;
		бцел  ulRootConfigurationPathType;
		бцел  ulRootConfigurationPathChars;
		бцел  ulAppDirPathType;
		бцел  ulAppDirPathChars;
		PCWSTR lpRootManifestPath;
		PCWSTR lpRootConfigurationPath;
		PCWSTR lpAppDirPath;
	}
	alias ACTIVATION_CONTEXT_DETAILED_INFORMATION*
	  PACTIVATION_CONTEXT_DETAILED_INFORMATION;
	alias CPtr!(ACTIVATION_CONTEXT_DETAILED_INFORMATION)
	  PCACTIVATION_CONTEXT_DETAILED_INFORMATION;

	struct ACTIVATION_CONTEXT_QUERY_INDEX {
		ULONG ulAssemblyIndex;
		ULONG ulFileIndexInAssembly;
	}
	alias ACTIVATION_CONTEXT_QUERY_INDEX*       PACTIVATION_CONTEXT_QUERY_INDEX;
	alias CPtr!(ACTIVATION_CONTEXT_QUERY_INDEX) PCACTIVATION_CONTEXT_QUERY_INDEX;

	struct ASSEMBLY_FILE_DETAILED_INFORMATION {
		бцел  ulFlags;
		бцел  ulFilenameLength;
		бцел  ulPathLength;
		PCWSTR lpFileName;
		PCWSTR lpFilePath;
	}
	alias ASSEMBLY_FILE_DETAILED_INFORMATION*
	  PASSEMBLY_FILE_DETAILED_INFORMATION;
	alias CPtr!(ASSEMBLY_FILE_DETAILED_INFORMATION)
	  PCASSEMBLY_FILE_DETAILED_INFORMATION;
}

version (Unicode) {
	alias OSVERSIONINFOW OSVERSIONINFO;
	alias OSVERSIONINFOEXW OSVERSIONINFOEX;
} else {
	alias OSVERSIONINFOA OSVERSIONINFO;
	alias OSVERSIONINFOEXA OSVERSIONINFOEX;
}

alias OSVERSIONINFO*   POSVERSIONINFO,   LPOSVERSIONINFO;
alias OSVERSIONINFOEX* POSVERSIONINFOEX, LPOSVERSIONINFOEX;


static if (_WIN32_WINNT_ONLY && _WIN32_WINNT >= 0x500) {
	extern (Windows) ULONGLONG VerSetConditionMask(ULONGLONG, бцел, ббайт);
}
+/
version (Win64) {
	//const бкрат IMAGE_NT_OPTIONAL_HDR_MAGIC = IMAGE_NT_OPTIONAL_HDR64_MAGIC;

	//alias IMAGE_ORDINAL_FLAG64 IMAGE_ORDINAL_FLAG;
	//alias IMAGE_SNAP_BY_ORDINAL64 IMAGE_SNAP_BY_ORDINAL;
	//alias IMAGE_ORDINAL64 IMAGE_ORDINAL;
	alias IMAGE_OPTIONAL_HEADER64 IMAGE_OPTIONAL_HEADER;
	//alias IMAGE_NT_HEADERS64 IMAGE_NT_HEADERS;
	//alias IMAGE_THUNK_DATA64 IMAGE_THUNK_DATA;
	//alias IMAGE_TLS_DIRECTORY64 IMAGE_TLS_DIRECTORY;
} else {
	//const бкрат IMAGE_NT_OPTIONAL_HDR_MAGIC = IMAGE_NT_OPTIONAL_HDR32_MAGIC;

	//alias IMAGE_ORDINAL_FLAG32 IMAGE_ORDINAL_FLAG;
	//alias IMAGE_ORDINAL32 IMAGE_ORDINAL;
	//alias IMAGE_SNAP_BY_ORDINAL32 IMAGE_SNAP_BY_ORDINAL;
	alias IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER;
	//alias IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS;
	//alias IMAGE_THUNK_DATA32 IMAGE_THUNK_DATA;
	//alias IMAGE_TLS_DIRECTORY32 IMAGE_TLS_DIRECTORY;
}

alias IMAGE_OPTIONAL_HEADER* PIMAGE_OPTIONAL_HEADER;
//alias IMAGE_NT_HEADERS* PIMAGE_NT_HEADERS;
//alias IMAGE_THUNK_DATA* PIMAGE_THUNK_DATA;
//alias IMAGE_TLS_DIRECTORY* PIMAGE_TLS_DIRECTORY;
///STRUCTS

//OVERLAPPED,SECURITY_ATTRIBUTES,FILETIME,WIN32_FIND_DATA, WIN32_FIND_DATAW, _LIST_ENTRY,_RTL_CRITICAL_SECTION_DEBUG,_RTL_CRITICAL_SECTION,MEMORYSTATUS,MEMORY_BASIC_INFORMATION,SYSTEMTIME,TIME_ZONE_INFORMATION;

///////////////////
struct _PROCESS_HEAP_ENTRY
 { 
 PVOID lpData; 
 DWORD cbData;
 BYTE cbOverhead;
 BYTE iRegionIndex;
 WORD wFlags; 
 union 
 { 
	 struct Block
	 { 
	 HANDLE hMem;
	 DWORD dwReserved[3]; 
	 } 
	 struct Region
	 {   
	 DWORD dwCommittedSize; 
	 DWORD dwUnCommittedSize; 
	 LPVOID lpFirstBlock;  
	 LPVOID lpLastBlock; 
	 } 
 }
 
} 
alias _PROCESS_HEAP_ENTRY PROCESS_HEAP_ENTRY;
alias PROCESS_HEAP_ENTRY *LPPROCESS_HEAP_ENTRY;

///////////////////////////////////
struct ИНФ_О_СИМВОЛЕ
	{
        бцел РазмерСтруктуры;
        бцел ИндексТипа;
        бдол Резерв[2];
        бцел Индекс;
        бцел Размер;
        бдол ОваМод;
        бцел Флаги;
        бдол Значение;
        бдол Адрес;
        бцел Регистр;
        бцел Масштаб;
        бцел Тэг;
        бцел ДлинаИм;
        бцел МаксДлинаИм;
        сим Имя[1];
    }
	
////////////////////////////
struct DCB {
	DWORD DCBlength = DCB.sizeof;
	DWORD BaudRate;
/+
	DWORD fBinary:1;              // Binary Mode (skip EOF check)
	DWORD fParity:1;              // Enable parity checking
	DWORD fOutxCtsFlow:1;         // CTS handshaking on output
	DWORD fOutxDsrFlow:1;         // DSR handshaking on output
	DWORD fDtrControl:2;          // DTR Flow control
	DWORD fDsrSensitivity:1;      // DSR Sensitivity
	DWORD fTXContinueOnXoff:1;    // Continue TX when Xoff sent
	DWORD fOutX:1;                // Enable output X-ON/X-OFF
	DWORD fInX:1;                 // Enable input X-ON/X-OFF
	DWORD fErrorChar:1;           // Enable Err Replacement
	DWORD fNull:1;                // Enable Null stripping
	DWORD fRtsControl:2;          // Rts Flow control
	DWORD fAbortOnError:1;        // Abort all reads and writes on Error
	DWORD fDummy2:17;             // Reserved
+/
	uint _bf;
	бул fBinary(бул f)           { _bf = (_bf & ~0x0001) | f; return f; }
	бул fParity(бул f)           { _bf = (_bf & ~0x0002) | (f<<1); return f; }
	бул fOutxCtsFlow(бул f)      { _bf = (_bf & ~0x0004) | (f<<2); return f; }
	бул fOutxDsrFlow(бул f)      { _bf = (_bf & ~0x0008) | (f<<3); return f; }
	byte fDtrControl(byte x)       { _bf = (_bf & ~0x0030) | (x<<4); return cast(byte)(x & 3); }
	бул fDsrSensitivity(бул f)   { _bf = (_bf & ~0x0040) | (f<<6); return f; }
	бул fTXContinueOnXoff(бул f) { _bf = (_bf & ~0x0080) | (f<<7); return f; }
	бул fOutX(бул f)             { _bf = (_bf & ~0x0100) | (f<<8); return f; }
	бул fInX(бул f)              { _bf = (_bf & ~0x0200) | (f<<9); return f; }
	бул fErrorChar(бул f)        { _bf = (_bf & ~0x0400) | (f<<10); return f; }
	бул fNull(бул f)             { _bf = (_bf & ~0x0800) | (f<<11); return f; }
	byte fRtsControl(byte x)       { _bf = (_bf & ~0x3000) | (x<<12); return cast(byte)(x & 3); }
	бул fAbortOnError(бул f)     { _bf = (_bf & ~0x4000) | (f<<14); return f; }

	бул fBinary()           { return cast(бул) (_bf & 1); }
	бул fParity()           { return cast(бул) (_bf & 2); }
	бул fOutxCtsFlow()      { return cast(бул) (_bf & 4); }
	бул fOutxDsrFlow()      { return cast(бул) (_bf & 8); }
	byte fDtrControl()       { return cast(byte) ((_bf & (32+16))>>4); }
	бул fDsrSensitivity()   { return cast(бул) (_bf & 64); }
	бул fTXContinueOnXoff() { return cast(бул) (_bf & 128); }
	бул fOutX()             { return cast(бул) (_bf & 256); }
	бул fInX()              { return cast(бул) (_bf & 512); }
	бул fErrorChar()        { return cast(бул) (_bf & 1024); }
	бул fNull()             { return cast(бул) (_bf & 2048); }
	byte fRtsControl()       { return cast(byte) ((_bf & (4096+8192))>>12); }
	бул fAbortOnError()     { return cast(бул) (_bf & 16384); }

	WORD wReserved;
	WORD XonLim;
	WORD XoffLim;
	BYTE ByteSize;
	BYTE Parity;
	BYTE StopBits;
	char XonChar;
	char XoffChar;
	char ErrorChar;
	char EofChar;
	char EvtChar;
	WORD wReserved1;
}
alias DCB* LPDCB;

struct СКУ {
	бцел СКУразм = СКУ.sizeof;
	бцел бодрейт;
/+
	бцел fBinary:1;              // Binary Mode (skip EOF check)
	бцел fParity:1;              // Enable parity checking
	бцел fOutxCtsFlow:1;         // CTS handshaking on output
	бцел fOutxDsrFlow:1;         // DSR handshaking on output
	бцел fDtrControl:2;          // DTR Flow control
	бцел fDsrSensitivity:1;      // DSR Sensitivity
	бцел fTXContinueOnXoff:1;    // Continue TX when Xoff sent
	бцел fOutX:1;                // Enable output X-ON/X-OFF
	бцел fInX:1;                 // Enable input X-ON/X-OFF
	бцел fErrorChar:1;           // Enable Err Replacement
	бцел fNull:1;                // Enable Null stripping
	бцел fRtsControl:2;          // Rts Flow control
	бцел fAbortOnError:1;        // Abort all reads and writes on Error
	бцел fDummy2:17;             // Reserved
+/
	бцел _бф;
	бул фБинар(бул ф)           { _бф = (_бф & ~0x0001) | ф; return ф; }
	бул фПаритет(бул ф)           { _бф = (_бф & ~0x0002) | (ф<<1); return ф; }
	бул фСиТиЭс(бул ф)      { _бф = (_бф & ~0x0004) | (ф<<2); return ф; }
	бул фДиЭсАр(бул ф)      { _бф = (_бф & ~0x0008) | (ф<<3); return ф; }
	байт фДиТиАр(байт x)       { _бф = (_бф & ~0x0030) | (x<<4); return cast(байт)(x & 3); }
	бул фЧувствительностьДиЭсАр(бул ф)   { _бф = (_бф & ~0x0040) | (ф<<6); return ф; }
	бул фПродолжитьТиЭксПриЭксвыкл(бул ф) { _бф = (_бф & ~0x0080) | (ф<<7); return ф; }
	бул фВыхЭкс(бул ф)             { _бф = (_бф & ~0x0100) | (ф<<8); return ф; }
	бул фВхЭкс(бул ф)              { _бф = (_бф & ~0x0200) | (ф<<9); return ф; }
	бул фОшСим(бул ф)        { _бф = (_бф & ~0x0400) | (ф<<10); return ф; }
	бул фНулл(бул ф)             { _бф = (_бф & ~0x0800) | (ф<<11); return ф; }
	байт фАрТиЭс(байт x)       { _бф = (_бф & ~0x3000) | (x<<12); return cast(байт)(x & 3); }
	бул фАбортПриОш(бул ф)     { _бф = (_бф & ~0x4000) | (ф<<14); return ф; }

	бул фБинар()           { return cast(бул) (_бф & 1); }
	бул фПаритет()           { return cast(бул) (_бф & 2); }
	бул фСиТиЭс()      { return cast(бул) (_бф & 4); }
	бул фДиЭсАр()      { return cast(бул) (_бф & 8); }
	байт фДиТиАр()       { return cast(байт) ((_бф & (32+16))>>4); }
	бул фЧувствительностьДиЭсАр()   { return cast(бул) (_бф & 64); }
	бул фПродолжитьТиЭксПриЭквыкл() { return cast(бул) (_бф & 128); }
	бул фВыхЭкс()             { return cast(бул) (_бф & 256); }
	бул фВхЭкс()              { return cast(бул) (_бф & 512); }
	бул фОшСим()        { return cast(бул) (_бф & 1024); }
	бул фНулл()             { return cast(бул) (_бф & 2048); }
	байт фАрТиЭс()       { return cast(байт) ((_бф & (4096+8192))>>12); }
	бул фАбортПриОш()     { return cast(бул) (_бф & 16384); }

	бкрат резерв;
	бкрат эксвклЛим;
	бкрат эксвыклЛим;
	ббайт байтРазм;
	ббайт паритет;
	ббайт стопБиты;
	сим эксвклСим;
	сим эксвыклСим;
	сим ошСим;
	сим кфСим;
	сим собСим;
	бкрат резерв1;
}
alias СКУ СЕРИЙНЫЕ_КОММУНИКАЦИОННЫЕ_УСТРОЙСТВА;
/////////////////////////////////////////////////////
struct COMMTIMEOUTS {
	DWORD ReadIntervalTimeout;
	DWORD ReadTotalTimeoutMultiplier;
	DWORD ReadTotalTimeoutConstant;
	DWORD WriteTotalTimeoutMultiplier;
	DWORD WriteTotalTimeoutConstant;
}
alias COMMTIMEOUTS* LPCOMMTIMEOUTS;

struct КОММТАЙМАУТЫ {
	бцел ТаймаутИнтервалаЧтения;
	бцел МультипликаторТаймаутаОбщегоЧтения;
	бцел КонстантаТаймаутаОбщегоЧтения;
	бцел МультипликаторТаймаутаОбщейЗаписи;
	бцел КонстантаТаймаутаОбщейЗаписи;
}

////////////////////////////////////////////////

struct COMSTAT {
/+
	DWORD fCtsHold:1;
	DWORD fDsrHold:1;
	DWORD fRlsdHold:1;
	DWORD fXoffHold:1;
	DWORD fXoffSent:1;
	DWORD fEof:1;
	DWORD fTxim:1;
	DWORD fReserved:25;
+/
	DWORD _bf;
    бул fCtsHold(бул f)  { _bf = (_bf & ~1) | f; return f; }
	бул fDsrHold(бул f)  { _bf = (_bf & ~2) | (f<<1); return f; }
	бул fRlsdHold(бул f) { _bf = (_bf & ~4) | (f<<2); return f; }
	бул fXoffHold(бул f) { _bf = (_bf & ~8) | (f<<3); return f; }
	бул fXoffSent(бул f) { _bf = (_bf & ~16) | (f<<4); return f; }
	бул fEof(бул f)      { _bf = (_bf & ~32) | (f<<5); return f; }
	бул fTxim(бул f)     { _bf = (_bf & ~64) | (f<<6); return f; }

    бул fCtsHold()  { return cast(бул) (_bf & 1); }
	бул fDsrHold()  { return cast(бул) (_bf & 2); }
	бул fRlsdHold() { return cast(бул) (_bf & 4); }
	бул fXoffHold() { return cast(бул) (_bf & 8); }
	бул fXoffSent() { return cast(бул) (_bf & 16); }
	бул fEof()      { return cast(бул) (_bf & 32); }
	бул fTxim()     { return cast(бул) (_bf & 64); }

	DWORD cbInQue;
	DWORD cbOutQue;
}
alias COMSTAT* LPCOMSTAT;

struct КОММСТАТ {
/+
	DWORD fCtsHold:1;
	DWORD fDsrHold:1;
	DWORD fRlsdHold:1;
	DWORD fXoffHold:1;
	DWORD fXoffSent:1;
	DWORD fEof:1;
	DWORD fTxim:1;
	DWORD fReserved:25;
+/
	бцел _бф;
    бул фОжиданиеСиТиЭс(бул ф)  { _бф = (_бф & ~1) | ф; return ф; }
	бул фОжиданиеДиЭсАр(бул ф)  { _бф = (_бф & ~2) | (ф<<1); return ф; }
	бул фОжиданиеАрЭлЭсДи(бул ф) { _бф = (_бф & ~4) | (ф<<2); return ф; }
	бул фОжиданиеЭксвыкл(бул ф) { _бф = (_бф & ~8) | (ф<<3); return ф; }
	бул фОтправленЭксвыкл(бул ф) { _бф = (_бф & ~16) | (ф<<4); return ф; }
	бул фКф(бул ф)      { _бф = (_бф & ~32) | (ф<<5); return ф; }
	бул фТиэксим(бул ф)     { _бф = (_бф & ~64) | (ф<<6); return ф; }

    бул фОжиданиеСиТиЭс()  { return cast(бул) (_бф & 1); }
	бул фОжиданиеДиЭсАр()  { return cast(бул) (_бф & 2); }
	бул фОжиданиеАрЭлЭсДи() { return cast(бул) (_бф & 4); }
	бул фОжиданиеЭксвыкл() { return cast(бул) (_бф & 8); }
	бул фОтправленЭксвыкл() { return cast(бул) (_бф & 16); }
	бул фКф()      { return cast(бул) (_бф & 32); }
	бул фТиэксим()     { return cast(бул) (_бф & 64); }

	бцел вхОч;
	бцел выхОч;
}
alias КОММСТАТ СТАТИСТИКА_КОММУНИКАЦИИ;
//////////////////////////////////////////////
struct COMMCONFIG {
	DWORD dwSize = COMMCONFIG.sizeof;
	WORD  wVersion;
	WORD  wReserved;
	DCB   dcb;
	DWORD dwProviderSubType;
	DWORD dwProviderOffset;
	DWORD dwProviderSize;
	WCHAR _wcProviderData;

	WCHAR* wcProviderData() { return &_wcProviderData; }
}
alias COMMCONFIG* LPCOMMCONFIG;

struct КОММКОНФИГ {
	бцел размер = КОММКОНФИГ.sizeof;
	бкрат  версия;
	бкрат  резерв;
	СКУ   ску;
	бцел подтипПровайдера;
	бцел СмещениеПровайдера;
	бцел размерПровайдера;
	шим _данныеОПровайдере;

	шим* данныеОПровайдере() { return &_данныеОПровайдере; }
}
alias КОММКОНФИГ КОНФИГУРАЦИЯ_КОММУНИКАЦИИ;
/////////////////////////////
	struct ACTCTXA {
		ULONG cbSize = this.sizeof;
		DWORD dwFlags;
		LPCSTR lpSource;
		USHORT wProcessorArchitecture;
		LANGID wLangId;
		LPCSTR lpAssemblyDirectory;
		LPCSTR lpResourceName;
		LPCSTR lpApplicationName;
		HMODULE hModule;
	}
	alias ACTCTXA* PACTCTXA, PCACTCTXA;
	
		struct АКТКТКСА {
		бцел размер = this.sizeof;
		бцел флаги;
		ткст0 исток;
		бкрат архПроцессора;
		ИДЯз идЯзыка;
		ткст0 папкаСборки;
		ткст0 имяРесурса;
		ткст0 имяПриложения;
		ук модуль;
	}
	alias АКТКТКСА КОНТЕКСТ_АКТИВАЦИИ_А;
//////////////////////////////////////////////

	struct ACTCTXW {
		ULONG cbSize = this.sizeof;
		DWORD dwFlags;
		LPCWSTR lpSource;
		USHORT wProcessorArchitecture;
		LANGID wLangId;
		LPCWSTR lpAssemblyDirectory;
		LPCWSTR lpResourceName;
		LPCWSTR lpApplicationName;
		HMODULE hModule;
	}
	alias ACTCTXW* PACTCTXW, PCACTCTXW;
	
			struct АКТКТКС {
		бцел размер = this.sizeof;
		бцел флаги;
		ткст0 исток;
		бкрат архПроцессора;
		ИДЯз идЯзыка;
		шткст *папкаСборки;
		шткст *имяРесурса;
		шткст *имяПриложения;
		ук модуль;
	}
	alias АКТКТКС КОНТЕКСТ_АКТИВАЦИИ;