module gc;

private import exception, stdrus, sync, sys.WinConsts, cidrus, std.intrinsic, util, rt.lifetime;


/************** Отладка ***************************/

//debug = НА_КОНСОЛЬ;			// включить эхо'ы
//debug = COLLECT_PRINTF;		// вкючить эхо'ы
//debug = THREADINVARIANT;	// проверить целостность нити
//debug = LOGGING;		// размещения журналов / освобождения
//debug = MEMSTOMP;		// stomp on memory
//debug = SENTINEL;		// добавить underrun/overrrun защиту
//debug = PTRCHECK;		// дополнительная проверка указателей
//debug = PTRCHECK2;		// тщательная, но медленная проверка указателей
//debug = PROFILING;            // измерить производительность различных этапов
/*************** Конфигурация *********************/
//debug = SENTINEL;
//debug = НА_КОНСОЛЬ;
version = СТЭК_РАСТЁТ_ВНИЗ;	// наращивание стека означает уменьшение от стекового указателя (СУ)
				// (используется для процессоров Intel X86)
				// иначе наращивание стека подразумевает прибавление к СУ
version = МНОГОПОТОЧНАЯ;	// произвести многопоточную версию

    version (МНОГОПОТОЧНАЯ)
    {
        extern  (C) бул нить_нужнаБлокировка();
        extern  (C) проц нить_заморозьВсе();
        extern  (C) проц нить_разморозьВсе();

        extern  (C) проц нить_сканируйВсе( сканФн fn, ук текВерхСтека = null );
		
		//extern (C) бцел dThreadsNumber();
    }
/***************************************************/
const ИСПОЛЬЗОВАТЬ_КЭШ = true;

const МАКС_РЕКУРСИЙ_МЕЧЕНИЯ = 64;

enum
{
    Б_16,
    Б_32,
    Б_64,
    Б_128,
    Б_256,
    Б_512,
    Б_1024,
    Б_2048,
    Б_СТР,             // начало большого размещения
    Б_СТРПЛЮС,         // продолжение большого размещения
    Б_ОСВОБ,             // освободить страницу
    Б_НЕПОДАНО,      // память, не переданная для данной страницы
    Б_МАКС
}


alias ббайт Бины;


struct Список
{
    Список *следщ;
	Пул *пул;
}


const т_мера бинразм[Б_МАКС] = [ 16,32,64,128,256,512,1024,2048,4096 ];
const т_мера небинразм[Б_МАКС] = [ ~(16-1),~(32-1),~(64-1),~(128-1),~(256-1),
                                ~(512-1),~(1024-1),~(2048-1),~(4096-1) ];
								


/*============= СМБиты ================================================*/

version (DigitalMars)
{
    version = bitops;
}
else version (GNU)
{
    // use the unoptimized version
}
else version(LDC)
{
    // ditto
}
else version (D_InlineAsm_X86)
{
    version = Asm86;
}

struct СМБиты
{

alias т_мера т_слово;
    const БИТ_НА_СЛОВО =  (т_слово.sizeof * 8);
    const СДВИГ_БИТ = (т_слово.sizeof == 8 ? 6 : 5);
    const МАСКА_БИТ = (БИТ_НА_СЛОВО - 1);
	const БИТЫ_1 = cast(т_слово)1;

    т_слово*  данные = null;
    т_мера члослов = 0;    // allocated words in данные[] excluding sentinals
    т_мера члобит = 0;     // number of bits in данные[] excluding sentinals

    проц Дтор()
    {
        if (данные)
        {
            cidrus.освободи(данные);
            данные = null;
        }
    }

    invariant
    {
       инвариант(); 
    }
	
private проц инвариант()
{
if (данные)
        {
            assert(члослов * данные[0].sizeof * 8 >= члобит);
        }
	}

    проц размести(т_мера члобит)
    {
        this.члобит = члобит;
        члослов = (члобит + (БИТ_НА_СЛОВО - 1)) >> СДВИГ_БИТ;
        данные = cast(typeof(данные[0])*)cidrus.кразмести(члослов + 2, данные[0].sizeof);
        if (!данные)
            throw new ВнеПамИскл;
    }

    т_слово тестируй(т_мера инд)
    in
    {
        assert(инд < члобит);
    }
    body
    {
        //return (cast(bit *)(данные + 1))[инд];
        return данные[1 + (инд >> СДВИГ_БИТ)] & (БИТЫ_1 << (инд & МАСКА_БИТ));
    }

    проц установи(т_мера инд)
    in
    {
        assert(инд < члобит);
    }
    body
    {
        //(cast(bit *)(данные + 1))[инд] = 1;
        данные[1 + (инд >> СДВИГ_БИТ)] |= (БИТЫ_1 << (инд & МАСКА_БИТ));
    }

    проц сбрось(т_мера инд)
    in
    {
        assert(инд < члобит);
    }
    body
    {
        //(cast(bit *)(данные + 1))[инд] = 0;
        данные[1 + (инд >> СДВИГ_БИТ)] &= ~(БИТЫ_1 << (инд & МАСКА_БИТ));
    }

    т_слово тестСброс(т_мера инд)
    {
        version (bitops)
        {
            return std.intrinsic.btr(данные + 1, инд);
        }
        else version (Asm86)
        {
            asm
            {
                naked                   ;
                mov     EAX,данные[EAX]   ;
                mov     ECX,инд-4[ESP]    ;
                btr     4[EAX],ECX      ;
                sbb     EAX,EAX         ;
                ret     4               ;
            }
        }
        else
        { 

            //результат = (cast(bit *)(данные + 1))[инд];
            //(cast(bit *)(данные + 1))[инд] = 0;

            auto p = &данные[1 + (инд >> СДВИГ_БИТ)];
            auto  маска = (БИТЫ_1 << (инд & МАСКА_БИТ));
            auto результат = *p & маска;
            *p &= ~маска;
            return результат;
        }
    }

    т_слово тестУст(т_мера инд)
    {
        version (bitops)
        {
            return std.intrinsic.bts(данные + 1, инд);
        }
        else version (Asm86)
        {
            asm
            {
                naked                   ;
                mov     EAX,данные[EAX]   ;
                mov     ECX,инд-4[ESP]    ;
                bts     4[EAX],ECX      ;
                sbb     EAX,EAX         ;
                ret     4               ;
            }
        }
        else
        {  
            //результат = (cast(bit *)(данные + 1))[инд];
            //(cast(bit *)(данные + 1))[инд] = 0;

            auto p = &данные[1 + (инд >> СДВИГ_БИТ)];
            auto  маска = (БИТЫ_1 << (инд & МАСКА_БИТ));
            auto результат = *p & маска;
            *p |= маска;
            return результат;
        }
    }

    проц обнули()
    {
        version(MEMCPY_NON_SIG_SAFE) {
            бцел * d1=данные+1,dEnd=d1+члослов;
            for (;d1!=dEnd;++d1)
                *d1=0u;
        } else {
            cidrus.memset(данные + 1, 0, члослов * т_слово.sizeof);
        }
    }

    проц копируй(СМБиты *f)
    in
    {
        assert(члослов == f.члослов);
    }
    body
    {
        version(MEMCPY_NON_SIG_SAFE) {
            бцел * d1=данные+1,d2=f.данные+1,dEnd=d1+члослов;
            for (;d1!=dEnd;++d1,++d2)
                *d1=*d2;
        } else {
            cidrus.memcpy(данные + 1, f.данные + 1, члослов * бцел.sizeof);
        }
    }

    т_слово* основа()
    in
    {
        assert(данные);
    }
    body
    {
        return данные + 1;
    }
}								
								
/* ======================= Детектор Утечки =========================== */


debug (LOGGING)
{
    struct Журнал
    {
        ук  p;
        т_мера размер;
        бдол  строка;
        усим  файл;
        ук  родитель;

        проц выведи()
        {
            эхо("    p = %x, razmer = %d, roditel' = %x ", p, размер, родитель);
            if (файл)
            {
                эхо("%s(%u)", файл, строка);
            }
            эхо("\n");
        }
    }


    struct МассивЖурналов
    {
        т_мера разм;
        т_мера allocdim;
        Журнал *данные;

        проц Дтор()
        {
            if (данные)
                cidrus.освободи(данные);
            данные = null;
        }

        проц резервируй(т_мера члозаписей)
        {
            assert(разм <= allocdim);
            if (allocdim - разм < члозаписей)
            {
                allocdim = (разм + члозаписей) * 2;
                assert(разм + члозаписей <= allocdim);
                if (!данные)
                {
                    данные = cast(Журнал*)cidrus.празмести(allocdim * Журнал.sizeof);
                    if (!данные && allocdim)
                        throw new ВнеПамИскл;
                }
                else
                {   Журнал *новданные;

                    новданные = cast(Журнал*)cidrus.празмести(allocdim * Журнал.sizeof);
                    if (!новданные && allocdim)
                        throw new ВнеПамИскл;
                    cidrus.memcpy(новданные, данные, разм * Журнал.sizeof);
                    cidrus.освободи(данные);
                    данные = новданные;
                }
            }
        }

        проц сунь(Журнал журнал)
        {
            резервируй(1);
            данные[разм++] = журнал;
        }

        проц удали(т_мера инд)
        {
            cidrus.memmove(данные + инд, данные + инд + 1, (разм - инд) * Журнал.sizeof);
            разм--;
        }


        т_мера найди(ук p)
        {
            for (т_мера инд = 0; инд < разм; инд++)
            {
                if (данные[инд].p == p)
                    return инд;
            }
           return СБОЙ_ОП; // не найдено
        }


        проц копируй(МассивЖурналов *из)
        {
            резервируй(из.разм - разм);
            assert(из.разм <= allocdim);
            cidrus.memcpy(данные, из.данные, из.разм * Журнал.sizeof);
            разм = из.разм;
        }
    }
}

final class СМЗамок:Мютекс { }                // класс для получения глобального замка

/**
 * Данная структура инкапсулирует в себе функциональность сборщика мусора
 * языка программирования Динрус.
 */
 
 const бцел ВЕРСИЯ = 1;  
//////////////////////////////////////

/*========= СБОРЩИК МУСОРА ==============*/

alias СборщикМусора СМ, т_см;
export extern (D) class СборщикМусора
{

    // Для передачи отладочному коду
    static т_мера  строка;
    static усим  файл;

	Gcx *gcx;                   // реализация
    static ИнфОКлассе смЗамок;    // глобальный замок
	
private т_см экз;

this()
{
		ClassInfo ci = СМ.classinfo;
		экз = cast(т_см) cidrus.празмести(ci.init.length);
		(cast(байт*)экз)[0 .. ci.init.length] = ci.init[];
		//эхо("Returning from смНовый all\n");
		this = cast(СМ) экз;
		this.иниц();
}

~this()
{
this.Дтор();
cidrus.освободи(cast(ук )экз);
}

export extern (D)  бцел версия(){return ВЕРСИЯ;}

export extern (D) проц иниц()
    {
        смЗамок = СМЗамок.classinfo;
        gcx = cast(Gcx*)cidrus.кразмести(1, Gcx.sizeof);
        if (!gcx)
            throw new ВнеПамИскл;
        gcx.иниц();
        устНизСтэка(util.ртНизСтэка());
		//эхо("СМ initialized");
    }
	
	    export extern (D) проц Дтор()
    {
        if (gcx)
        {
            gcx.Дтор();
            cidrus.освободи(gcx);
            gcx = null;
        }
    }
	
	 invariant
    {
	инвариант();
    }
	
private проц инвариант()
{
        if (gcx)
        {
            gcx.инвариант_Нити();
        }
}

	
	export extern (D) проц монитор (проц delegate() начало, проц delegate(цел, цел) конец)
    {
        gcx.началоСборки = начало;
        gcx.конецСборки = конец;
    }
	
    /**
     * Активирует сборку мусора, если она ранее была приостановлена
     *вызовом откл.  Это функция повторно-входимая, она должна
     * вызываться единожды для каждого вызова откл, перед активацией
     * мусоросборщика.
     */
    export extern (D) проц вкл()
    {
        if (!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            assert(gcx.отключен > 0);
            gcx.отключен--;
        }
        else synchronized (смЗамок)
        {
            assert(gcx.отключен > 0);
            gcx.отключен--;
        }
    }

    /**
     * Отключает мусоросборщик.  Это функция повторного входа, но
     * откл нужно вызывать для каждого вкл.
     */
    export extern (D) проц откл()
    {
        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            gcx.отключен++;
        }
        else synchronized (смЗамок)
        {
            gcx.отключен++;
        }
    }

    /**
     * Активирует полную сборку.  Хотя значение этой функции может меняться
	* в зависимости от реализации сборщика мусора,
     * как правило, она сканирует все сегменты стека на наличие
     * корней (ветвлений), помечает доступные блоки памяти как "живые",
     * а затем отзывает свободное пространство.  Для этого действа может
     * потребоваться приостановка всех запущенных нитей, как  минимум,
	  * для соответствующей части процесса сборки.
	  */
    export extern (D) проц собери()
    {
        полныйСбор();
    }

    /**
     * Указывает на то, что можно уменьшить обрабатываемое пространство
	 * памяти путём возврата свободной физической памяти операционной системе.
	 * Количество возвращаемой свободной памяти зависит от
     * дизайна разместителя и от поведения программы.
     */
    export extern (D) проц уменьши()
    {
        экономь();
    }
       
    /**
     * Возвращает бит-поле, представляющее собой все атрибуты блока, установленные для
	 * памяти, на которую ссылается p. Если p ссылается на пямять, изначально распределенную
	 * не этим мусоросборщиком, то указывает на внутренности блока памяти, или если if p
     * нулевой, возвращает ноль.
     *
     * Параметры:
     *  p = Указатель на корень действительного блока памяти или на пусто.
     *
     * Возвращает:
     *  Бит-поле, содержащее какие-либо биты, установленные для блока памяти, на который
	 * указывает  p, или ноль при ошибке.
     */
    export extern (D) бцел дайАтр( ук p )
    {
         if (!p)
        {
            return 0;
        }

        бцел go()
        {
            Пул* пул = gcx.найдиПул(p);
            бцел  oldb = 0;

            if (пул)
            {
                auto битинд = cast(т_мера)(p - пул.адрОсновы) >> пул.смещНа;

                oldb = gcx.дайБиты(пул, битинд);
            }
            return oldb;
        }

        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            return go();
        }
        else synchronized (смЗамок)
        {
            return go();
        }
    }

    /**
     * Устанавливает указаннные биты для обращений к памяти переменной p.  Если p обращается
     * к памяти, размещённой изначально не данным сборщиком, указывает внутрь блока памяти
     * либо содержит значение пусто, никакого действия не последует.
     *
     * Параметры:
     *  p = Указатель на корень действительного блока памяти, либо в пусто.
     *  a = Битполе с любыми битами, устанавливаемыми для данного блока памяти.
     *
     *  Результат вызова дайАтр устанавливается после установки указанного бита.
     */
    export extern (D) бцел устАтр( ук p, ПАтрБлока маска )
    {
         if (!p)
        {
            return 0;
        }

        бцел go()
        {
            Пул* пул = gcx.найдиПул(p);
            бцел  oldb = 0;

            if (пул)
            {
                auto битинд = cast(т_мера)(p - пул.адрОсновы) >> пул.смещНа;

                oldb = gcx.дайБиты(пул, битинд);
                gcx.устБиты(пул, битинд, маска);
            }
            return oldb;
        }

        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            return go();
        }
        else synchronized (смЗамок)
        {
            return go();
        }
    }

    /**
     * Удаляет указанные биты для обращения к памяти переменной p.  Если p обращается
     * к памяти, размещённой изначально не данным сборщиком, указывает внутрь блока памяти
     * либо содержит значение пусто, никакого действия не последует.
     *
     * Параметры:
     *  p = Указатель на корень действительного блока памяти, либо в пусто.
     *  a = Битполе с любыми битами, устанавливаемыми для данного блока памяти.
     *
     *  Результат вызова дайАтр устанавливается после установки указанного бита.
     */ 
    export extern (D) бцел удалиАтр( ук p, ПАтрБлока маска )
    {
        if (!p)
        {
            return 0;
        }

        бцел go()
        {
            Пул* пул = gcx.найдиПул(p);
            бцел  oldb = 0;

            if (пул)
            {
                auto битинд = cast(т_мера)(p - пул.адрОсновы) >> пул.смещНа;

                oldb = gcx.дайБиты(пул, битинд);
                gcx.удалиБиты(пул, битинд, маска);
            }
            return oldb;
        }

        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            return go();
        }
        else synchronized (смЗамок)
        {
            return go();
        }
    }

    /**
     * Запрашивает размеченный блок управляемой памяти у мусоросборщика.
     * Эту память при желании можно удалить, вызвав cidrus.освободи, либо её можно
     * сбросить и освободить автоматически, при пуске очистки. Если
     * распределение неудачно, то эта функция вызывает onOutOfMemory,
     * от которого ожидается вывод OutOfMemoryException.
     *
     * Параметры:
     *  разм = Желаемый размер размещения в байтах.
     *  ba = Битмаска атрибутов, для установки на данном блоке.
     *
     * Возвращает:
     *  Ссылку на распределенную память или пусто, если памяти
     *  недостаточно.
     *
     * Выводит:
     *  OutOfMemoryException при неудачном распределении.
     */
    export extern (D) ук празмести(т_мера размер, бцел биты = 0, т_мера *разм_размещ = null)
    {
        if (!размер)
        {
		  if(разм_размещ)
                *разм_размещ = 0;
            return null;
        }

        // Т.к. финализатор может запустить новый поток, при сборке всегда
        // нужна блокировка. Это лучше всегда делать при
        // помещении в оперативку.
        synchronized (смЗамок)
        {
		//эхо("Passed to mallocNoSync\n");
            return mallocNoSync(размер, биты, разм_размещ);
        }
    }

    /**
     * Запрашивает у сборщика мусора размещённый блок управляемой памяти,
     * который инициализуется со всеми битами, установленными в ноль. Эту память по желанию
     * можно удалить вызовом cidrus.освободи, или сбросить или очистить автоматически при
     * запуске сборки.  If allocation fails, this
     * function will вызови onOutOfMemory which is expected to throw an
     * OutOfMemoryException.
     *
     * Параметры:
     *  разм = The desired allocation размер in байтs.
     *  ba = A bitmask of the attributes to установи on this block.
     *
     * Возвращает:
     *  A ссылка to the allocated memory or пусто if insufficient memory
     *  is available.
     *
     * Выводит:
     *  OutOfMemoryException on allocation failure.
     */
    export extern (D) ук кразмести(т_мера размер, бцел биты = 0, т_мера *разм_размещ = null)
    {
        if (!размер)
        {
		    if(разм_размещ)
                *разм_размещ = 0;
            return null;
        }
        synchronized (смЗамок)
        {
            return callocNoSync(размер, биты, разм_размещ);
        }
    }

    /**
     * Если разм равно нулю, то память, на которую указывает p, будет освобождена,
     * как это бывает при вызове cidrus.освободи.  Затем новый блок памяти размером в разм
	 * будет распределен, как это бывает при вызове cidrus.празмести, либо вместо этого
	 * реализация может на месте изменить блок в размере. Содержимое нового
     * блока памяти будет таким же, как у старого блока, до наименьшего общего
     * между новым и старым размерами. Запомните, что существующая память будет
     * освобождена только, если разм равно нулю. Впоследствии от сборщика мусора
     * ожидается отзыв этого блока памяти, если он более не используется.
     * Если распределение не удалось, эта функция вызывает onOutOfMemory,
	 * от которого ожидается вывод исключения OutOfMemoryException. Если же p
	  * указывает на память, ранее размещенную не этим мусоросборщиком, 
	  * либо если он указывает во внутрь блока памяти, то никакого действия
	  * не предпринимается. Если ba равно нулю (по умолчанию),
	  * а p указывает на главу действительного, известного блока памяти,
     * тогда все биты, установленные на текущем блоке, будут перенесены на новый блок,
	 * если потребуется перемещение. Если ba не равно нулю, а p указывает на
     * главу действительного, известного блока памяти, тогда биты из ba заменят
     * биты в текущем блоке памяти, а также будут установлены на новом блоке,
     * если понадобится перемещение.
     *
     * Параметры:
     *  p  = Указатель на корень действительного блока памяти или на пусто.
     *  разм = Необходимый размер размещения в байтах.
     *  ba = Бит-маска атрибутов, которые нужно установить на данном блоке.
     *
     * Возвращает:
     *  Ссылку на размещенную память при успехе, либо пусто, если разм равно
     *  нулю. При неудаче возвращается исходное значение p.
     *
     * Выводит:
     *  OutOfMemoryException при неудачном размещении.
     */
    export extern (D) ук перемести(ук p, т_мера размер, бцел биты = 0, т_мера *разм_размещ = null)
    {
        synchronized (смЗамок)
        {
            return reallocNoSync(p, размер, биты, разм_размещ);
        }
    }

    /**
     * Запрашивает, чтобы блок управляемой памяти,  на который ссылается p,
	 * был увеличен на месте, как минимум на mx байт, с желательным расширением на
	 * разм байт. Если расширение требуемой памяти невозможно,
     * и p ссылается на память, ранее размещенную другим сборщиком,
	 * либо же p указывает внутрь блока память,
	 * то никаких действий не предпринимается.
     *
     * Параметры:
     *  mx = Минимальный размер расширения в байтах.
     *  разм = Желаемый размер расширения в байтах.
     *
     * Возвращает:
     *  Размер в байтах расширенного блока памяти, показываемого p, или обнули,
     *  если расширения не произошло.
     */
    export extern (D) т_мера расширь(ук p, т_мера минразм, т_мера максразм)
    {
        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            return extendNoSync(p, минразм, максразм);
        }
        else synchronized (смЗамок)
        {
            return extendNoSync(p, минразм, максразм);
        }
    }

    /**
     * Запрашивает получение от операционной системы как минимум разм байтов
     * с пометкой их как "свободные".
     *
     * Параметры:
     *  разм = Требуемый размер в байтах.
     *
     * Возвращает:
     *  Действительное число размещенных байтов или ноль при ошибке.
     */
    export extern (D) т_мера резервируй(т_мера размер)
    {
        if (!размер)
        {
            return 0;
        }

        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            return reserveNoSync(размер);
        }
        else synchronized (смЗамок)
        {
            return reserveNoSync(размер);
        }
    }

    /**
     * Вымещает память, на которую показывает p.  Если p равен нулю, никаких
     * действий не предпринимается. Если p ссылается на память, ранее размещенную другим
	 * мусоросборщиком, или он указывает внутрь блока памяти,
     * действий не последует. Этот блок останется не финализированным, несмотря на то,
	 * установлен или нет атрибут Финализовать. Если требуется финализация,
     * то следует использовать delete.
     *
     * Параметры:
     *  p = Указатель на корень действующего блока памяти или в пусто.
     */
    export extern (D) проц освободи( ук p )
    {
        if (!p)
        {
            return;
        }

        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            return freeNoSync(p);
        }
        else synchronized (смЗамок)
        {
            return freeNoSync(p);
        }
    }

    /**
     * Возвращает адрес базы блока памяти, содержащего p.  Это значение
     * может использоваться для определения того, является ли p
	 * внутренним указателем, а результат может передаваться
     * процедурам типа sizeOf, которые в противном случае могут не срабатывать.
	 * Если p ссылается на память, которую изначально выделил не этот
	 * сборщик мусора, если p = пусто, или сборщик мусора не поддерживает
     * данную операцию, то будет возвращено пусто.
     *
     * Параметры:
     *  p = A pointer to the корень or the interior of a valid memory block or to
     *      пусто.
     *
     * Возвращает:
     *  The base address of the memory block referenced by p or пусто on error.
     */
    export extern (D) ук адрес_у( ук p )
    {
        if (!p)
        {
            return null;
        }

        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            return addrOfNoSync(p);
        }
        else synchronized (смЗамок)
        {
            return addrOfNoSync(p);
        };
    }

    /**
     * Возвращает настоящий размер блока памяти, указанного p.  Это значение
     * представляет максимальный размер в байтах, в который вызовом realloc 
     * можно на месте изменить существующий блок.  If p references memory not
     * originally allocated by this garbage collector, points to the interior
     * of a memory block, or if p is пусто, ноль will be returned.
     *
     * Параметры:
     *  p = A pointer to the корень of a valid memory block or to пусто.
     *
     * Возвращает:
     *  Размер в байтах of the memory block referenced by p or ноль on error.
     */
    export extern (D) т_мера размер_у( ук p )
    {
        if (!p)
        {
            return 0;
        }

        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            return sizeOfNoSync(p);
        }
        else synchronized (смЗамок)
        {
            return sizeOfNoSync(p);
        }
    }

    /**
     * Возвращает совокупную информацию о блоке памяти, содержащем p.  Если p
     * ссылается на память, исходно установленную не этим сборщиком мусора, 
     *или p имеет значение пусто, либо СМ не поддерживает эту операцию, будет
     * выдано ИнфОБл.init. Как правило, поддержка данной операции зависит от поддержки
     * функции адрес_у.
     *
     * Параметры:
     *  p = Указатель на корень или внутренность валидного блока памяти
     *   либо на  пусто.
     *
     * Возвращает:
     *  Информацию, касающуюся блока бамяти, на который ссылается p, или ИнфОБл.init
     *  при ошибке.
     */
    export extern (D) ИнфОБл опроси( ук p )
    {
        if (!p)
        {
            ИнфОБл инд;
            return  инд;
        }

        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            return queryNoSync(p);
        }
        else synchronized (смЗамок)
        {
            return queryNoSync(p);
        }
    }
	
	    /**
     * Проверяет указатель p:
     *  1) на принадлежность к данному пулу памяти
     *  2) на то, что он указывает на начало размещенного куска памяти
     *  3) что его нет в списке очистки
     */
    export extern (D) проц проверь(ук p)
    {
        if (!p)
        {
            return;
        }

        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            checkNoSync(p);
        }
        else synchronized (смЗамок)
        {
            checkNoSync(p);
        }
    }

    /**
     * Добавляет адрес памяти, на который ссылается p, во внутренний список корней,
     * подлежащих сканированию при сборке.  Если p = пусто, никакой операции
     * не выполняется.
     *
     * Параметры:
     *  p = Указатель на действительный адрес памяти или в пусто.
     */
    export extern (D) проц добавьКорень( ук p )
    {
        if (!p)
        {
            return;
        }

        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            gcx.добавьКорень(p);
        }
        else synchronized (смЗамок)
        {
            gcx.добавьКорень(p);
        }
    }
	
	
		 /**
     *
     */
  export extern (D)  цел delegate(цел delegate(ref ук)) обходКорня()
    {
        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            return &gcx.обходКорня;
        }
        else synchronized (смЗамок)
        {
            return &gcx.обходКорня;
        }
    }

    /**
     * Добавляет блок памяти, указанный p размера разм во внутренний список
     * сканируемых при сборке диапазонов.  Если p пусто, то никаких действий
     * не предпринимается.
     *
     * Параметры:
     *  p  = Указатель на действительный адрес памяти или в пусто.
     *  разм = Размер в байтах добавляемого блока.  Если разм = нуль, то
     *      ничего не произойдёт. Если p = пусто, то разм должен быть нуль.
     */
////////////////////////////////	 
    export extern (D) проц добавьПространство( ук p, т_мера разм )
    {
        debug(НА_КОНСОЛЬ) эхо("addR1: ук, т_мера");
        if (!p || !разм)
        {
            return;
        }

        debug(НА_КОНСОЛЬ) скажифнс("+СМ.добавьПространство(Низ = x%x, Верх = x%x)\n", Низ, Верх);
        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            gcx.добавьПространство(p, p + разм);
        }
        else synchronized (смЗамок)
        {
            gcx.добавьПространство(p, p + разм);
        }
        debug(НА_КОНСОЛЬ) скажи("-СМ.добавьПространство()\n");
    }
/////////////////////////////////////////	
	export extern (D) проц добавьПространство(ук Низ, ук Верх)
    {
	debug(НА_КОНСОЛЬ) скажинс(" addR2: ук, ук");
        if (!Низ || !Верх)
        {
            return;
        }

	debug(НА_КОНСОЛЬ) скажифнс("+СМ.добавьПространство(Низ = x%x, Верх = x%x)\n", Низ, Верх);
        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
	    gcx.добавьПространство(Низ, Верх);
        }
        else synchronized (смЗамок)
	{
	    gcx.добавьПространство(Низ, Верх);
	}
	debug(НА_КОНСОЛЬ) скажи("-СМ.добавьПространство()\n");
    }
//////////////////////////	
	export extern (D) цел delegate(цел delegate(ref Пространство)) обходПространства()
    {
        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            return &gcx.обходПространства;
        }
        else synchronized (смЗамок)
        {
            return &gcx.обходПространства;
        }
    }

    /**
     * Удаляет блок памяти, указанный p, из внутреннего списка "корней" (ветвей),
     * подлежащих сканированию при сборке. Если p = пусто или не представляет собой
     * ранее переданное add(ук) значение, то никакого действия не происходит.
     *
     *  p  = Указатель на действительный адрес памяти или в пусто.
     */
	 
    export extern (D) проц удалиКорень( ук p )
    {
        if (!p)
        {
            return;
        }

        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            gcx.удалиКорень(p);
        }
        else synchronized (смЗамок)
        {
            gcx.удалиКорень(p);
        }
    }

    /**
     * Удаляет блок памяти, на к-й ссылается p, из внутреннего списка диапазонов,
     * подлежащих сканированию при сборке мусора. Если p пусто или не представляет значение,
     * ранее переданное add(ук, т_мера), то никакой операции не выполняется.
     *
     * Параметры:
     *  p  = Указатель на действительный адрес памяти или в пусто.
     */
    export extern (D) проц удалиПространство( ук p )
    {
        if (!p)
        {
            return;
        }

        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            gcx.удалиПространство(p);
        }
        else synchronized (смЗамок)
        {
            gcx.удалиПространство(p);
        }
    }
	
	        
    export extern (D) проц мониторируй( проц delegate() начало, проц delegate(цел, цел) конец )
    {
        монитор( начало, конец );
    }   

    /**
     * Создаёт слабый указатель на данный объект.
     * Возвращает указатель на плотную структуру, размещённую в памяти Си.
     */
    export extern (D) ук создайСлабУк( Объект r )
    {
        if (r)
           {
           //must be allocated in C memory
           //1. to hide the ссылка из the СМ
           //2. the СМ doesn't скан delegates added by rt_detachDisposeEvent for references
           auto wp = cast(СлабыйУказатель*)(cidrus.празмести(СлабыйУказатель.sizeof));
           if (!wp)
               throw new ВнеПамИскл();
           wp.ссылка = r;
           object.rt_attachDisposeEvent(r, &wp.ondestroy);
           return wp;
           }
               return null;
    }


    /**
     * Удаляет слабый указатель, возвращённый weakpointerCreate().
     * Если передано пусто, ничего не происходит.
     */
    export extern (D) проц удалиСлабУк( ук p )
    {
        if (p)        
           {
           auto wp = cast(СлабыйУказатель*)p;
           //must be extra careful about the СМ or parallel threads finalizing the
           //ссылка at the same time
           locked!(проц)({
                   if (wp.ссылка)
                       object.rt_detachDisposeEvent(wp.ссылка, &wp.ondestroy);
                  });
           cidrus.освободи(wp);
           }
    }

    /**
     * Опросить слабук, вернув либо Объект, переданный методу
     * weakpointerCreate, либо пусто, если он был удалён.
     * Если передаётся пусто, пусто и возвращается.
     */
    export extern (D) Объект дайСлабУк( ук p )
    {
        if (p)
           {
           //NOTE: could avoid the блокируй by using Fawzi style СМ counters
           // but that'd require core.sync.Atomic and lots of care about memory consistency
           // it's an optional optimization
           //see http://dsource.org/projects/tango/browser/trunk/user/tango/core/Lifetime.d?rev=5100#L158
           return locked!(Объект)({
                  return (cast(СлабыйУказатель*)p).ссылка;
                  });
           }
        return null;
    }

    /**
    * returns the amount to allocate to оставить some extra space
    * for large allocations the extra allocated space decreases, but is still enough
    * so that the number of reallocations when linearly growing stays logaritmic
    * Параметры:
    * newlength = the number of elements to allocate
    * elSize = размер of one element
    */
    export extern (D) т_мера нарастиДлину (т_мера newlength, т_мера elSize=1)
    {   
        return нарастиДлину (newlength, elSize, 100, 0, 1);
    }
    
    /**
    * returns the amount to allocate to оставить some extra space
    * for large allocations the extra allocated space decreases, but is still enough
    * so that the number of reallocations when linearly growing stays logaritmic
    * Параметры:
    * newlength = the number of elements to allocate
    * elSize = размер of one element
    * a = maximum extra space in percent (the allocated space gets rounded up, so might be larger)
    * b = flatness factor, how fast the extra space decreases with массив размер (the larger the more constant)
    * minBits = minimum number of bits of newlength
    */
    export extern (D) т_мера нарастиДлину(т_мера newlength, т_мера elSize, т_мера a, т_мера b=0, т_мера minBits=1)
    {
        static т_мера log2(т_мера c)
        {
            // could use the bsr bit op
            т_мера инд=1;
            while(c >>= 1)
                  ++инд;
            return инд;
        }

        т_мера newext = 0;
        т_мера newcap = newlength*elSize;
        дол mult = 100 + a*(minBits+b) / (log2(newlength)+b);
        newext = elSize*cast(т_мера)(((newcap * mult)+99) / 100);
        newcap = newext > newcap ? newext : newcap; // just to хэндл overflows
        return newcap;
    }

   /**
     * Выполнить полную сборку мусора
     */
    export extern (D) проц полныйСбор()
    {
        debug(НА_КОНСОЛЬ) скажи("СМ.полныйСбор()\n");

        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            gcx.полная_уборка();
        }
        else synchronized (смЗамок)
        {
            gcx.полная_уборка();
        }

        version (none)
        {
            СМСтат стат;

            getStats(стат);
            debug(НА_КОНСОЛЬ) скажифнс("razmerPula = %x, ispRazmer = %x, razmSpiskaSvobBlokov = %x\n",
                    стат.размерПула, стат.испРазмер, стат.размСпискаСвобБлоков);
        }

        gcx.журнал_сборка();
    }
	
   /**
     * Выполнить полный сбор мусора, игнорируя корни
     */
    export extern (D) проц полныйСборБезСтэка()
    {
        // Поскольку финализатор способен запустить новую нить, всегда надо блокировать
        // при сборе.
        synchronized (смЗамок)
        {
            gcx.безСтэка++;
            gcx.полная_уборка();
            gcx.безСтэка--;
        }
    }
	
/**
     * Выполнить генерационный сбор мусора
     */
    export extern (D) проц генСбор()
    {
	synchronized (смЗамок)
	{
	    gcx.полная_уборка();
	}
    }
///////////////////////////////
	export extern (D) проц естьУказатели(ук p)
    {
	synchronized (смЗамок)
	{
	    gcx.ЕстьУказатели(p);
	}
    }
/////////////////////////
	export extern (D) проц нетУказателей(ук p)
    {
	if (!gcx.консервативный)
	{   synchronized (смЗамок)
	    {
		gcx.НетУказателей(p);
	    }
	}
    }
////////////////////////
	export extern (D) проц устВ1_0()
    {
	gcx.консервативный = 1;
    }
///////////////////
/**
     * Определить размещённый размер указателя p.  If p is an interior pointer
     * or not a gc allocated pointer, return 0.
     */
   export extern (D) т_мера ёмкость(ук p)
    {
        if (!p)
        {
            return 0;
        }

        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            return sizeOfNoSync(p);
        }
        else synchronized (смЗамок)
        {
            return sizeOfNoSync(p);
		}
     }
//////////////
    export extern (D) проц сканируйСтатДан(т_см g)
    {
	ук Низ;
	ук Верх;
	бцел члобайт;

	debug(НА_КОНСОЛЬ) скажи("+СМ.сканируйСтатДан()\n");
	ос_запроссегментастатдан(&Низ, &члобайт);
	Верх = Низ + члобайт;
	g.добавьПространство(Низ, Верх);
	debug(НА_КОНСОЛЬ) скажи("-СМ.сканируйСтатДан()\n");
    }

    export extern (D) проц отсканируйСтатДан(т_см g)
    {
	ук Низ;
	бцел члобайт;

	ос_запроссегментастатдан(&Низ, &члобайт);
	g.удалиПространство(Низ);
    }
///////////////////////////////////////
    /**
     * минимизировать использование пространства
     */
    export extern (D) проц экономь()
    {
        if(!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            gcx.экономь();
        }
        else synchronized (смЗамок)
        {
            gcx.экономь();
        }
    }
///////////////////////////////////////////	
/**
     * Получить статистику о сборке мусора.
     * Применимо при отладке и настройке.
     */
    export extern (D) проц дайСтат(out СМСтат стат)
    {
       if (!нить_нужнаБлокировка()||stdrus.Нить.члонн ==1)
        {
            getStatsNoSync(стат);
        }
        else synchronized (смЗамок)
        {
            getStatsNoSync(стат);
        }
    }
	
	export extern (D) проц устФинализатор(ук p, ФИНАЛИЗАТОР_СМ pFn)
    {
	synchronized (смЗамок)
	{
	    gcx.финализатор = pFn;
	    gcx.заверши(p);
	}
    }
	
//////////////////////////////////////////////////////////////////////////////////////////
private:
//////////////////////////////////////////////
ук mallocNoSync(т_мера размер, бцел биты = 0, т_мера *разм_размещ = null)
//////////////////////////////////////////////
    {
        assert(размер != 0);

        ук p = null;
        Бины бин;
		цел состояние;
        бул собрано;

        assert(gcx);

		    if (gcx.пущен)
            throw new Исключение("Ошибочная операция с памятью", __FILE__, __LINE__);

        размер += SENTINEL_EXTRA;
		бин = gcx.найдиБин(размер);
        Пул *пул;

        if (бин < Б_СТР)
        {
		     if(разм_размещ)
                *разм_размещ = бинразм[бин];
           состояние = gcx.отключен ? 1 : 0;
            собрано = false;

            while (!gcx.бак[бин] && !gcx.разместиСтраницу(бин))
            {
                switch (состояние)
                {
                case 0:
                    т_мера удалённые_страницы = gcx.полная_уборка();
                    собрано = true;
                    if (удалённые_страницы < gcx.чло_пулов * ((РАЗМЕР_ПУЛА / РАЗМЕР_СТРАНИЦЫ) / 8))
                    {   
                        gcx.новыйПул(1, false);
                        состояние = 2;
                    }
                    else
                        состояние = 1;
                    continue;
                case 1:
                    gcx.новыйПул(1, false);
                    состояние = 2;
                    continue;
                case 2:
                    if (собрано)
                        throw new ВнеПамИскл();
                    состояние = 0;
                    continue;
                default:
                    assert(false);
                }
            }
            p = gcx.бак[бин];

            gcx.бак[бин] = (cast(Список*)p).следщ;
            if( !(биты & ПАтрБлока.НеСканировать) )
                cidrus.memset(p + размер, 0, бинразм[бин] - размер);
            debug(НА_КОНСОЛЬ) скажифнс("\tcidrus.празмести => %x\n", p);
            debug (MEMSTOMP) cidrus.memset(p, 0xF0, размер);
        }
        else
        {
            p = gcx.большоеРазмещение(размер, &пул, разм_размещ);
            if (!p)
                throw new ВнеПамИскл();
        }
        размер -= SENTINEL_EXTRA;
        p = сентинель_добавь(p);
        сентинель_иниц(p, размер);
        gcx.журнал_празмести(p, размер);

        if (биты)
        {
            пул = gcx.найдиПул(p);
            assert(пул);

            gcx.устБиты(пул, cast(т_мера)(p - пул.адрОсновы) >> пул.смещНа, биты);
        }
		debug(НА_КОНСОЛЬ) скажифнс("Возврат из cidrus.празмести %i\n", p);
        return p;
    }
/////////////////////////////////////////////	
ук callocNoSync(т_мера размер, бцел биты = 0, т_мера *разм_размещ = null)
/////////////////////////////////////////////
    {
        assert(размер != 0);

        //debug(НА_КОНСОЛЬ) скажифнс("cidrus.кразмести: %x len %d\n", p, len);
        ук p = mallocNoSync(размер, биты, разм_размещ);
        cidrus.memset(p, 0, размер);
        return p;
    }
////////////////////////////////////////////////////	
ук reallocNoSync(ук p, т_мера размер, бцел биты = 0, т_мера *разм_размещ = null)
////////////////////////////////////////////////////
    {
        if (!размер)
        {   if (p)
            {   freeNoSync(p);
                p = null;
            }
			if(разм_размещ)
                *разм_размещ = 0;
        }
        else if (!p)
        {
            p = mallocNoSync(размер, биты, разм_размещ);
        }
        else
        {   ук p2;
            т_мера размук;

            version (SENTINEL)
            {
                сентинель_Инвариант(p);
                размук = *сентинель_размер(p);
                if (размук != размер)
                {
                    if (размук)
                    {
                        Пул *пул = gcx.найдиПул(p);

                        if (пул)
                        {
                            auto битинд = cast(т_мера)(p - пул.адрОсновы) >> пул.смещНа;

                            if (биты)
                            {
                                gcx.удалиБиты(пул, битинд, ПАтрБлока.ВсеБиты);
                                gcx.устБиты(пул, битинд, биты);
                            }
                            else
                            {
                                биты = gcx.дайБиты(пул, битинд);
                            }
                        }
                    }
                    p2 = mallocNoSync(размер, биты, разм_размещ);
                    if (размук < размер)
                        размер = размук;
                    cidrus.memcpy(p2, p, размер);
                    p = p2;
                }
            }
            else
            {
                размук = gcx.найдиРазмер(p);        // найди allocated размер
                if (размук >= РАЗМЕР_СТРАНИЦЫ && размер >= РАЗМЕР_СТРАНИЦЫ)
                {
                    auto psz = размук / РАЗМЕР_СТРАНИЦЫ;
                    auto newsz = (размер + РАЗМЕР_СТРАНИЦЫ - 1) / РАЗМЕР_СТРАНИЦЫ;
                    if (newsz == psz)
                        return p;

                    auto пул = gcx.найдиПул(p);
                    auto номерстр = (p - пул.адрОсновы) / РАЗМЕР_СТРАНИЦЫ;

                    if (newsz < psz)
                    {   // Shrink in place
                        synchronized (смЗамок)
                        {
                            debug (MEMSTOMP) cidrus.memset(p + размер, 0xF2, размук - размер);
                            пул.освободиСтраницы(номерстр + newsz, psz - newsz);
                        }
						if(разм_размещ)
                            *разм_размещ = newsz * РАЗМЕР_СТРАНИЦЫ;
                        return p;
                    }
                    else if (номерстр + newsz <= пул.члостр)
                    {
                        // Attempt to expand in place
                        synchronized (смЗамок)
                        {
                            for (т_мера инд = номерстр + psz; 1;)
                            {
                                if (инд == номерстр + newsz)
                                {
                                    //debug (MEMSTOMP) cidrus.memset(p + размук, 0xF0, размер - размук);
                                    cidrus.memset(&пул.таблица_страниц[номерстр + psz], Б_СТРПЛЮС, newsz - psz);
									пул.обновиСмещения(номерстр);
                                    if(разм_размещ)
                                        *разм_размещ = newsz * РАЗМЕР_СТРАНИЦЫ;
                                    пул.свобстры -= (newsz - psz);
                                    return p;
                                }
                                if (инд == пул.члопереданных)
                                {
                                    auto u = пул.увеличьСтраницы(номерстр + newsz - пул.члопереданных);
                                    if (u == СБОЙ_ОП)
                                        break;
                                    инд = номерстр + newsz;
                                    continue;
                                }
                                if (пул.таблица_страниц[инд] != Б_ОСВОБ)
                                    break;
                                инд++;
                            }
                        }
                    }
                }
                if (размук < размер ||             // if new размер is bigger
                    размук > размер * 2)           // or less than half
                {
                    if (размук)
                    {
                        Пул *пул = gcx.найдиПул(p);

                        if (пул)
                        {
                            auto битинд = cast(т_мера)(p - пул.адрОсновы)  >> пул.смещНа;

                            if (биты)
                            {
                                gcx.удалиБиты(пул, битинд, ПАтрБлока.ВсеБиты);
                                gcx.устБиты(пул, битинд, биты);
                            }
                            else
                            {
                                биты = gcx.дайБиты(пул, битинд);
                            }
                        }
                    }
                    p2 = mallocNoSync(размер, биты, разм_размещ);
                    if (размук < размер)
                        размер = размук;
                    cidrus.memcpy(p2, p, размер);
                    p = p2;
                }
				else if(разм_размещ)
                    *разм_размещ = размук;
            }
        }
        return p;
    }
//////////////////////////////////////////////////////////
т_мера extendNoSync(ук p, т_мера аргминразм, т_мера аргмаксразм)
//////////////////////////////////////////////////////////
    in
    {
        assert( аргминразм <= аргмаксразм );
    }
    body
    {
	
	if (gcx.пущен)
            throw new Исключение("Неправильная операция с памятью", __FILE__, __LINE__);
       
        version (SENTINEL)
        {
            return 0;
        }
        auto размук = gcx.найдиРазмер(p);   // найди allocated размер
        if (размук < РАЗМЕР_СТРАНИЦЫ)
            return 0;                   // cannot extend buckets

        auto psz = размук / РАЗМЕР_СТРАНИЦЫ;
        auto минразм = (аргминразм + РАЗМЕР_СТРАНИЦЫ - 1) / РАЗМЕР_СТРАНИЦЫ;
        auto максразм = (аргмаксразм + РАЗМЕР_СТРАНИЦЫ - 1) / РАЗМЕР_СТРАНИЦЫ;

        auto пул = gcx.найдиПул(p);
        auto номерстр = (p - пул.адрОсновы) / РАЗМЕР_СТРАНИЦЫ;

        т_мера разм;
        for (разм = 0; разм < максразм; разм++)
        {
            auto инд = номерстр + psz + разм;
            if (инд == пул.члопереданных)
                break;
            if (пул.таблица_страниц[инд] != Б_ОСВОБ)
            {   if (разм < минразм)
                    return 0;
                break;
            }
        }
        if (разм >= минразм)
        {
        }
        else if (номерстр + psz + разм == пул.члопереданных)
        {
            auto u = пул.увеличьЧлоСтрДо(максразм - разм);
            if (u == СБОЙ_ОП || (u + разм < минразм))
                return 0;
            разм += u;
			if(разм > максразм) разм = максразм;
        }
        else
            return 0;
        debug (MEMSTOMP) cidrus.memset(p + размук, 0xF0, (psz + разм) * РАЗМЕР_СТРАНИЦЫ - размук);
        cidrus.memset(пул.таблица_страниц + номерстр + psz, Б_СТРПЛЮС, разм);
		пул.обновиСмещения(номерстр);
        пул.свобстры -= разм;
        if (p == gcx.ключ_кэшированного_размера)
            gcx.знач_кэшированного_размера = (psz + разм) * РАЗМЕР_СТРАНИЦЫ;
        if (p == gcx.ключ_кэшированной_инфо)
            gcx.знач_кэшированной_инфо.размер = (psz + разм) * РАЗМЕР_СТРАНИЦЫ;
        return (psz + разм) * РАЗМЕР_СТРАНИЦЫ;
    }
///////////////////////////////////	
т_мера reserveNoSync(т_мера размер)
///////////////////////////////////
    {
        assert(размер != 0);
        assert(gcx);
		
		if (gcx.пущен)
            throw new Исключение("Ошибочная операция с памятью", __FILE__, __LINE__);

        return gcx.резервируй(размер);
    }
/////////////////////
проц freeNoSync(ук p)
/////////////////////
    {
        assert (p);
		
		if (gcx.пущен)
            throw new Исключение("Ошибочная операция с памятью", __FILE__, __LINE__);

        Пул*  пул;
        т_мера номерстр;
        Бины бин;
        т_мера битинд;

        // Find which page it is in
        пул = gcx.найдиПул(p);
        if (!пул)                              // if not one of ours
            return;                             // ignore
        сентинель_Инвариант(p);
        p = сентинель_отн(p);
        номерстр = cast(т_мера)(p - пул.адрОсновы) / РАЗМЕР_СТРАНИЦЫ;
        битинд = cast(т_мера)(p - пул.адрОсновы) >> пул.смещНа;
        gcx.удалиБиты(пул, битинд, ПАтрБлока.ВсеБиты);

        бин = cast(Бины)пул.таблица_страниц[номерстр];
        if (бин == Б_СТР)              // if large alloc
        {
            auto члостр = пул.смещБСтр[номерстр];
            debug (MEMSTOMP) cidrus.memset(p, 0xF2, члостр * РАЗМЕР_СТРАНИЦЫ);
            пул.освободиСтраницы(номерстр, члостр);
        }
        else
        {   // Add to cidrus.освободи список
            Список *список = cast(Список*)p;

            debug (MEMSTOMP) cidrus.memset(p, 0xF2, бинразм[бин]);

            список.следщ = gcx.бак[бин];
			список.пул = пул;
            gcx.бак[бин] = список;
        }
        gcx.журнал_освободи(сентинель_добавь(p));
    }

/////////////////////	
ук addrOfNoSync(ук p)
/////////////////////
    {
        if (!p)
        {
            return null;
        }

        return gcx.найдиОснову(p);
    }
	
/////////////////////////
т_мера sizeOfNoSync(ук p)
/////////////////////////
    {
        assert (p);

        version (SENTINEL)
        {
            p = сентинель_отн(p);
            т_мера размер = gcx.найдиРазмер(p);

            // Check for interior pointer
            // This depends on:
            // 1) размер is a power of 2 for less than РАЗМЕР_СТРАНИЦЫ values
            // 2) основа of memory пул is aligned on РАЗМЕР_СТРАНИЦЫ boundary
            if (cast(т_мера)p & (размер - 1) & (РАЗМЕР_СТРАНИЦЫ - 1))
                размер = 0;
            return размер ? размер - SENTINEL_EXTRA : 0;
        }
        else
        {
            т_мера размер = gcx.найдиРазмер(p);

            // Check for interior pointer
            // This depends on:
            // 1) размер is a power of 2 for less than РАЗМЕР_СТРАНИЦЫ values
            // 2) основа of memory пул is aligned on РАЗМЕР_СТРАНИЦЫ boundary
            if (cast(т_мера)p & (размер - 1) & (РАЗМЕР_СТРАНИЦЫ - 1))
                return 0;
            return размер;
        }
    }
////////////////////////
ИнфОБл queryNoSync(ук p)
///////////////////////
    {
        assert(p);

        return gcx.дайИнфо(p);
    }
	
//////////////////////
проц checkNoSync(ук p)
///////////////////////
    {
        assert(p);

        сентинель_Инвариант(p);
        debug (PTRCHECK)
        {
            Пул*  пул;
            т_мера номерстр;
            Бины бин;
            т_мера размер;

            p = сентинель_отн(p);
            пул = gcx.найдиПул(p);
            assert(пул);
            номерстр = cast(т_мера)(p - пул.адрОсновы) / РАЗМЕР_СТРАНИЦЫ;
            бин = cast(Бины)пул.таблица_страниц[номерстр];
            assert(бин <= Б_СТР);
            размер = бинразм[бин];
            assert((cast(т_мера)p & (размер - 1)) == 0);

            debug (PTRCHECK2)
            {
                if (бин < Б_СТР)
                {
                    // Check that p is not on a cidrus.освободи список
                    Список *список;

                    for (список = gcx.бак[бин]; список; список = список.следщ)
                    {
                        assert(cast(ук)список != p);
                    }
                }
            }
        }
    }
//////////////////////////
проц устНизСтэка(ук p)
/////////////////////////
    {
        version (СТЭК_РАСТЁТ_ВНИЗ)
        {
            //p = (ук )((бцел *)p + 4);
            if (p > gcx.низСтэка)
            {
               debug(НА_КОНСОЛЬ) скажифнс("устНизСтэка(%x)\n", p);
                gcx.низСтэка = p;
            }
        }
        else
        {
            //p = (ук )((бцел *)p - 4);
            if (p < gcx.низСтэка)
            {
                debug(НА_КОНСОЛЬ) скажифнс("устНизСтэка(%x)\n", p);
                gcx.низСтэка = cast(char*)p;
            }
        }
    }
////////////////////////
проц getStatsNoSync(out СМСтат стат)
///////////////////////////////
    {
        т_мера размук = 0;
        т_мера размфл = 0;
		т_мера бразм = 0;
		т_мера иразм = 0;

        т_мера n;

        debug(НА_КОНСОЛЬ) скажи("дайСтат()\n");
        cidrus.memset(&стат, 0, СМСтат.sizeof);

        for (n = 0; n < gcx.чло_пулов; n++)
        {   Пул *пул = gcx.таблица_пулов[n];

            размук += пул.члопереданных * РАЗМЕР_СТРАНИЦЫ;
            for (т_мера j = 0; j < пул.члопереданных; j++)
            {
                Бины бин = cast(Бины)пул.таблица_страниц[j];
                if (бин == Б_ОСВОБ)
                    стат.свобБлоки++;
                else if (бин == Б_СТР)
                    стат.блокиСтр++;
				else if (бин < Б_СТР)
                    бразм += РАЗМЕР_СТРАНИЦЫ;
            }
        }

        for (n = 0; n < Б_СТР; n++)
        {
            for (Список *список = gcx.бак[n]; список; список = список.следщ)
            {
                размфл += бинразм[n];
            }
        }
        иразм = бразм - размфл;
		
        стат.размерПула = размук;
        стат.испРазмер = бразм - размфл;
        стат.размСпискаСвобБлоков = размфл;
    }

    /******************* поддержка слабых ссылок *********************/

    //call locked if necessary
    T locked(T)(in T delegate() code) 
    {
        if (нить_нужнаБлокировка()||stdrus.Нить.члонн != 1)
            synchronized(смЗамок) return code();
        else
           return code();
    }

    struct СлабыйУказатель 
    {
        Объект ссылка;

        проц ondestroy(Объект r) 
        {
            assert(r is ссылка);
            //блокировка ради консистентности памяти (паралельное считывание)
            //
            //also ensures that weakpointerDestroy can be called while another
            //thread is cidrus.освободиing the ссылка with "delete"                    
            locked!(проц)({ ссылка = null; });
        }
    }

}
////////////////////////  КОНЕЦ СМ!!!!!!!!!!!!!!!


/* ============================ Gcx =============================== */

struct Gcx
{


    ук ключ_кэшированного_размера;
    т_мера знач_кэшированного_размера;
    
    ук ключ_кэшированной_инфо;
    ИнфОБл знач_кэшированной_инфо;

    т_мера члокорней;
    т_мера размкорня;
    ук* корни;

    т_мера члопространств;
    т_мера размпространства;
    Пространство *пространства;
	

	бцел консервативный;	// !=0 means консервативный behavior
	бцел безСтэка;       // !=0 means don't скан stack
    бцел журнал;           // turn on logging
    бцел любизмы;
    ук низСтэка;
    бцел готов;
	бцел пущен;
    цел отключен;       // turn off collections if >0

	байт *минАдр;      // min(адрОсновы)
	байт *максАдр;      // max(адрВерха)

	т_мера чло_пулов;
	Пул **таблица_пулов;
	//Пул **пултаб;

	Список *бак[Б_МАКС];        // cidrus.освободи список for each размер
	ФИНАЛИЗАТОР_СМ финализатор;	// финализатор function (one per СМ)


    проц delegate() началоСборки;
    проц delegate(цел освобождено, цел байтыстр) конецСборки;
	
	    debug (THREADINVARIANT)
    {
        т_нук этот;
        проц инвариант_Нити()
        {
            if (этот != эта_нить())
                скажифнс("инвариант_Нити(): gcx = %x, this = %x, pthread_self() = %x\n", this, этот, эта_нить());
            assert(этот == эта_нить());
        }
    }
    else
    {
        проц инвариант_Нити() { }
    }
	
	проц устМинАдр(байт *новАдр){минАдр = новАдр;}
	
	проц устМаксАдр(байт *новАдр){максАдр = новАдр;}

	Пул** дайТабПул()
	{
	/+Пул* пул;
	т_мера n;
	  for (n = 0; n < чло_пулов; n++)
        {
		скажинс("творю массив!");
            пул = таблица_пулов[n];
			пултаб ~= пул;
			
		}+/
	return таблица_пулов;
	}
	
	
    проц иниц()
    {   цел dummy;

        (cast(байт*)this)[0 .. Gcx.sizeof] = 0;
        низСтэка = cast(char*)&dummy;
        журнал_иниц();
        debug (THREADINVARIANT)
            этот = эта_нить();
        //скажифнс("gcx = %p, этот = %x\n", this, этот);
        this.готов = 1;
    }


    проц Дтор()
    {
	
	
        this.готов = 0;

        for (т_мера инд = 0; инд < чло_пулов; инд++)
        {   Пул *пул = таблица_пулов[инд];

            пул.Дтор();
            cidrus.освободи(пул);
        }
        if (таблица_пулов)
            cidrus.освободи(таблица_пулов);

        if (корни)
            cidrus.освободи(корни);

        if (пространства)
            cidrus.освободи(пространства);
    }


    проц Invariant() { }


invariant()
{
инвариант();
}

protected проц инвариант()
{
if(готов)
{
       // debug скажифнс("Gcx.invariant(): this = %p\n", this);
            т_мера инд;

            // Assure we're called on the right thread
            debug (THREADINVARIANT) assert(этот == эта_нить());

            for (инд = 0; инд < чло_пулов; инд++)
            {   auto пул = таблица_пулов[инд];

                пул.Invariant();
                if (инд == 0)
                {
                    assert(минАдр == пул.адрОсновы);
                }
                if (инд + 1 < чло_пулов)
                {
                    assert(пул.opCmp(таблица_пулов[инд + 1]) < 0);
                }
                else if (инд + 1 == чло_пулов)
                {
                    assert(максАдр == пул.адрВерха);
                }
            }

            if (корни)
            {
                assert(размкорня != 0);
                assert(члокорней <= размкорня);
            }

            if (пространства)
            {
                assert(размпространства != 0);
                assert(члопространств <= размпространства);

                for (инд = 0; инд < члопространств; инд++)
                {
                    assert(пространства[инд].Низ);
                    assert(пространства[инд].Верх);
                    assert(пространства[инд].Низ <= пространства[инд].Верх);
                }
            }

            for (инд = 0; инд < Б_СТР; инд++)
            {
                for (auto список = cast(Список*) бак[инд]; список; список = список.следщ)
                {
				
                }
				
            }
		}        
}

////////////////////////////////////////////

   /**
     * Run финализатор on p when it is cidrus.освободи'd.
     */
    проц заверши(ук p)
    {
	Пул *пул = найдиПул(p);
	assert(пул);

	// Only allocate финалы[] if we actually need it
	if (!пул.финалы.члобит)
	    пул.финалы.размести(пул.пометь.члобит);

	пул.финалы.установи((p - пул.адрОсновы) / 16);
    }
	
    /**
     * Indicate that block pointed to by p has possible pointers
     * to СМ allocated memory in it.
     */

	проц ЕстьУказатели(ук p)
    {
	Пул *пул = найдиПул(p);
	assert(пул);

	пул.нескан.сбрось((p - пул.адрОсновы) / 16);
    }
	
    /**
     * Indicate that block pointed to by p has no possible pointers
     * to СМ allocated memory in it.
     */
    проц НетУказателей(ук p)
    {
	//скажифнс("НетУказателей(%p)\n", p);
	Пул *пул = найдиПул(p);
	assert(пул);

	пул.нескан.установи((p - пул.адрОсновы) / 16);
    }

//////////////////////////////////////////////////
    /**
     *
     */
    проц добавьКорень(ук p)
    {
        if (члокорней == размкорня)
        {
            т_мера новразм = размкорня * 2 + 16;
            ук* новкорни;

            новкорни = cast(ук*)cidrus.празмести(новразм * новкорни[0].sizeof);
            if (!новкорни)
                throw new ВнеПамИскл();
            if (корни)
            {   cidrus.memcpy(новкорни, корни, члокорней * новкорни[0].sizeof);
                cidrus.освободи(корни);
            }
            корни = новкорни;
            размкорня = новразм;
        }
        корни[члокорней] = p;
        члокорней++;
    }

    /**
     *
     */
    проц удалиКорень(ук p)
    {
        for (т_мера инд = члокорней; инд--;)
        {
            if (корни[инд] == p)
            {
                члокорней--;
                cidrus.memmove(корни + инд, корни + инд + 1, (члокорней - инд) * корни[0].sizeof);
                return;
            }
        }
        assert(0);
    }

	 /**
     *
     */
    цел обходКорня(цел delegate(ref ук) дг)
    {
        цел результат = 0;
        for( т_мера инд = 0; инд < члокорней; ++инд )
        {
            результат = дг(корни[инд]);
            if (результат)
                break;
        }
        return результат;
    }

    /**
     *
     */
    проц добавьПространство(ук Низ, ук Верх)
    {
        debug(НА_КОНСОЛЬ) скажифнс("Нить %x ", эта_нить());
        debug(НА_КОНСОЛЬ) скажифнс("%x.Gcx::добавьПространство(%x, %x), члопространств = %d\n", this, Низ, Верх, члопространств);
        if (члопространств == размпространства)
        {
            т_мера новразм = размпространства * 2 + 16;
            Пространство *новпрострва;

            новпрострва = cast(Пространство*)cidrus.празмести(новразм * новпрострва[0].sizeof);
            if (!новпрострва)
                throw new ВнеПамИскл();
            if (пространства)
            {   cidrus.memcpy(новпрострва, пространства, члопространств * новпрострва[0].sizeof);
                cidrus.освободи(пространства);
            }
            пространства = новпрострва;
            размпространства = новразм;
        }
        пространства[члопространств].Низ = Низ;
        пространства[члопространств].Верх = Верх;
        члопространств++;
    }

    /**
     *
     */
    проц удалиПространство(ук Низ)
    {
        debug(НА_КОНСОЛЬ) скажифнс("Нить %x ", эта_нить());
        debug(НА_КОНСОЛЬ) скажифнс("%x.Gcx.удалиПространство(%x), члопространств = %d\n", this, Низ, члопространств);
        for (т_мера инд = члопространств; инд--;)
        {
            if (пространства[инд].Низ == Низ)
            {
                члопространств--;
                cidrus.memmove(пространства + инд, пространства + инд + 1, (члопространств - инд) * пространства[0].sizeof);
                return;
            }
        }
        debug(НА_КОНСОЛЬ) скажи("Неверная нить\n");

        // This is a fatal error, but ignore it.
        // The problem is that we can get a Close() call on a thread
        // other than the one the range was allocated on.
        //assert(обнули);
    }
	
	/**
     *
     */
    цел обходПространства(цел delegate(ref Пространство) дг)
    {
        цел результат = 0;
        for( т_мера инд = 0; инд < члопространств; ++инд )
        {
            результат = дг(пространства[инд]);
            if (результат)
                break;
        }
        return результат;
    }

    /**
     * Find Пул that pointer is in.
     * Return null if not in a Пул.
     * Assume таблица_пулов[] is sorted.
     */
    Пул *найдиПул(ук p)
    {
        if (p >= минАдр && p < максАдр)
        {
            if (чло_пулов <= 1)
            {
                return чло_пулов == 0 ? null : таблица_пулов[0];
            }

            /* The таблица_пулов[] is sorted by address, so do a binary search
             */
            auto pt = таблица_пулов;
            т_мера low = 0;
            т_мера high = чло_пулов - 1;
            while (low <= high)
            {
                т_мера mid = (low + high) >> 1;
                auto пул = pt[mid];
                if (p < пул.адрОсновы)
                    high = mid - 1;
                else if (p >= пул.адрВерха)
                    low = mid + 1;
                else
                    return пул;
            }
        }
        return null;
    }

    /**
     * Найти адрес основы блока, где находится указатель p.
     * Returns null if not a gc'd pointer
     */
    ук найдиОснову(ук p)
    {
        Пул *пул;

        пул = найдиПул(p);
        if (пул)
        {
            т_мера смещение = cast(т_мера)(p - пул.адрОсновы);
            т_мера pn = смещение / РАЗМЕР_СТРАНИЦЫ;
            Бины бин = cast(Бины)пул.таблица_страниц[pn];

            // Adjust bit to be at старт of allocated memory block
            if (бин <= Б_СТР)
            {
                return пул.адрОсновы + (смещение & небинразм[бин]);
            }
            else if (бин == Б_СТРПЛЮС)
            {
                auto pageOffset = пул.смещБСтр[pn];
                смещение -= pageOffset * РАЗМЕР_СТРАНИЦЫ;
                pn -= pageOffset;

                return пул.адрОсновы + (смещение & (смещение.max ^ (РАЗМЕР_СТРАНИЦЫ-1)));
            }
            else
            {
                // we are in a Б_ОСВОБ or Б_НЕПОДАНО page
                return null;
            }
        }
        return null;
    }

    /**
     * Найти размер указателя p.
     * Returns 0 if not a gc'd pointer
     */
    т_мера найдиРазмер(ук p)
    {
        Пул*  пул;
        т_мера размер = 0;

        if (ИСПОЛЬЗОВАТЬ_КЭШ && p == ключ_кэшированного_размера)
            return знач_кэшированного_размера;
            
        пул = найдиПул(p);
        if (пул)
        {
            т_мера номерстр;
            Бины бин;

            номерстр = cast(т_мера)(p - пул.адрОсновы) / РАЗМЕР_СТРАНИЦЫ;
            бин = cast(Бины)пул.таблица_страниц[номерстр];
            размер = бинразм[бин];
            if (бин == Б_СТР)
            { 
			размер = пул.смещБСтр[номерстр] * РАЗМЕР_СТРАНИЦЫ;
            }
            ключ_кэшированного_размера = p;
            знач_кэшированного_размера = размер;
        }
        return размер;
    }

    /**
     *
     */
    ИнфОБл дайИнфо(ук p)
    {
        Пул*   пул;
        ИнфОБл инфо;
        
        if (ИСПОЛЬЗОВАТЬ_КЭШ && p == ключ_кэшированной_инфо)
            return знач_кэшированной_инфо;

        пул = найдиПул(p);
        if (пул)
        {
            т_мера смещение = cast(т_мера)(p - пул.адрОсновы);
            т_мера pn = смещение / РАЗМЕР_СТРАНИЦЫ;
            Бины бин = cast(Бины)пул.таблица_страниц[pn];

            ////////////////////////////////////////////////////////////////////
            // findAddr
            ////////////////////////////////////////////////////////////////////

            if (бин <= Б_СТР)
            {
                инфо.основа = cast(ук)((cast(т_мера)p) & небинразм[бин]);
            }
            else if (бин == Б_СТРПЛЮС)
            {
                auto pageOffset = пул.смещБСтр[pn];
                смещение = pageOffset * РАЗМЕР_СТРАНИЦЫ;
                pn -= pageOffset;

                инфо.основа = пул.адрОсновы + (смещение & (смещение.max ^ (РАЗМЕР_СТРАНИЦЫ-1)));

                // fix бин for use by размер calc below
                бин = cast(Бины)пул.таблица_страниц[pn];
            }

            ////////////////////////////////////////////////////////////////////
            // найдиРазмер
            ////////////////////////////////////////////////////////////////////

            инфо.размер = бинразм[бин];
            if (бин == Б_СТР)
            {  
                инфо.размер = пул.смещБСтр[pn] * РАЗМЕР_СТРАНИЦЫ;
            }

            ////////////////////////////////////////////////////////////////////
            // дайБиты
            ////////////////////////////////////////////////////////////////////
            
            смещение = cast(т_мера)(инфо.основа - пул.адрОсновы);
            инфо.атр = дайБиты(пул, cast(т_мера)(смещение >> пул.смещНа));

            ключ_кэшированной_инфо = p;
            знач_кэшированной_инфо = инфо;
        }
        return инфо;
    }

    /**
     * Вычисляет размер корзины.
     */

    static Бины найдиБин_р(т_мера размер)
    {   Бины бин;

        if (размер <= 256)
        {
            if (размер <= 64)
            {
                if (размер <= 16)
                    бин = Б_16;
                else if (размер <= 32)
                    бин = Б_32;
                else
                    бин = Б_64;
            }
            else
            {
                if (размер <= 128)
                    бин = Б_128;
                else
                    бин = Б_256;
            }
        }
        else
        {
            if (размер <= 1024)
            {
                if (размер <= 512)
                    бин = Б_512;
                else
                    бин = Б_1024;
            }
            else
            {
                if (размер <= 2048)
                    бин = Б_2048;
                else
                    бин = Б_СТР;
            }
        }
        return бин;
    }

	    /**
     * Рассчитывает бин-таблицу, используя CTFE.
     */
    static байт[] ctfeBins()
    {
        байт[] ret = new байт[2049];
        for(т_мера инд = 0; инд < 2049; инд++)
        {
            ret[инд] = cast(байт) найдиБин_р(инд);
        }

        return ret;
    }
	
   static Бины найдиБин(т_мера размер)
    {   
	  static байт[2049] binTable =cast(байт[2049]) ctfeBins();

        return (размер <= 2048) ?
            (cast(Бины) binTable[размер]) :
            Б_СТР;
    }

    /**
     * Разместить новый пул как минимум в "размер" байтов.
     * Отсортировать его в таблицу_пулов[].
     * Пометить всю память в пуле как Б_ОСВОБ.
     * Возвращает реальное число резервированных байтов, либо 0 при ошибке.
     */
    т_мера резервируй(т_мера размер)
    {
        т_мера члостр = (размер + РАЗМЕР_СТРАНИЦЫ - 1) / РАЗМЕР_СТРАНИЦЫ;
        Пул*  пул = новыйПул(члостр, false);

        if (!пул || пул.увеличьСтраницы(члостр) == СБОЙ_ОП)
            return 0;
        return пул.члопереданных * РАЗМЕР_СТРАНИЦЫ;
    }

    /**
     * Уменьшает использование физической памяти за счёт возврата
	системе освобождаемых страниц.
     */
 проц экономь()
    {
		
		 static бул используется(Пул *пул)
        {
            return пул.свобстры < пул.члостр;
        }

        for (т_мера n = 0; n < чло_пулов; n++)
        {
            auto пул = таблица_пулов[n];
			  if (используется(пул)) continue;
			
            т_мера pn = n + 1;
            for (; pn < чло_пулов; ++pn)
            {
			пул = таблица_пулов[pn];
			  if (!используется(пул)) continue;
                // swap
                таблица_пулов[pn] = таблица_пулов[n];
                таблица_пулов[n] = пул;
                ++n;
            }
			 // npooltable[0 .. инд]      => использовано
            // npooltable[инд .. чло_пулов] => free

            // free unused pools
            for (pn = n; pn < чло_пулов; ++pn)
            {
                пул = таблица_пулов[pn];
               // debug(PRINTF) printFreeInfo(пул);
                пул.Дтор();
                cidrus.освободи(пул);
            }
            чло_пулов = n;
        }

        if (чло_пулов)
        {
            минАдр = таблица_пулов[0].адрОсновы;
            максАдр = таблица_пулов[чло_пулов - 1].адрВерха;
        }
        else
        {
            минАдр = максАдр = null;
        }

		
//debug скажинс("Экономия пространства выполнена");
		
	}

    /**
     * Размещает "чанк" памяти, с размером большим страницы.
     * При недостатке памяти возвращает null.
     */
    ук большоеРазмещение(т_мера размер, Пул **poolPtr, т_мера *разм_размещ = null)
    {
        Пул*  пул;
        т_мера члостр;
        т_мера n;
        т_мера pn;
        т_мера удалённые_страницы;
        ук  p;
        цел    состояние;
        бул   собрано = false;

        члостр = (размер + РАЗМЕР_СТРАНИЦЫ - 1) / РАЗМЕР_СТРАНИЦЫ;

        for (состояние = отключен ? 1 : 0; ; )
        {
            // This code could use some refinement when repeatedly
            // allocating very large arrays.

            for (n = 0; n < чло_пулов; n++)
            {
                пул = таблица_пулов[n];
				if(!пул.объектБольшой || пул.свобстры < члостр) continue;
                pn = пул.разместиСтраницы(члостр);
                if (pn != СБОЙ_ОП)
                    goto L1;
            }

            // Failed
            switch (состояние)
            {
            case 0:
                // Try collecting
                собрано = true;
                удалённые_страницы = полная_уборка();
                if (удалённые_страницы >= чло_пулов * ((РАЗМЕР_ПУЛА / РАЗМЕР_СТРАНИЦЫ) / 4))
                {   состояние = 1;
                    continue;
                }
                // Release empty pools to prevent bloat
				//скажинс("Первый вызов функции экономь");
                экономь();
                // Allocate new пул
                пул = новыйПул(члостр, true);
                if (!пул)
                {   состояние = 2;
                    continue;
                }
                pn = пул.разместиСтраницы(члостр);
                assert(pn != СБОЙ_ОП);
                goto L1;
            case 1:
                // Release empty pools to prevent bloat
				//скажинс("Второй вызов функции экономь");
                экономь();
                // Allocate new пул
                пул = новыйПул(члостр, true);
                if (!пул)
                {
                    if (собрано)
                        goto Lnomemory;
                    состояние = 0;
                    continue;
                }
                pn = пул.разместиСтраницы(члостр);
                assert(pn != СБОЙ_ОП);
                goto L1;
            case 2:
                goto Lnomemory;
            default:
                assert(false);
            }
        }

      L1:
        пул.таблица_страниц[pn] = Б_СТР;
        if (члостр > 1)
            cidrus.memset(&пул.таблица_страниц[pn + 1], Б_СТРПЛЮС, члостр - 1);
		пул.обновиСмещения(pn);
        пул.свобстры -= члостр;		
        p = пул.адрОсновы + pn * РАЗМЕР_СТРАНИЦЫ;
        cidrus.memset(cast(char *)p + размер, 0, члостр * РАЗМЕР_СТРАНИЦЫ - размер);
        debug (MEMSTOMP) cidrus.memset(p, 0xF1, размер);
		 if(разм_размещ)
            *разм_размещ = члостр * РАЗМЕР_СТРАНИЦЫ;
			*poolPtr = пул;
        //debug(НА_КОНСОЛЬ)		скажифнс("большоеРазмещение: \tp = %x\n", p);
        return p;

      Lnomemory:
        return null; // let caller хэндл the error
    }

    /**
     * Разместить новый пул с - как минимум - члостр в нём.
     * Сортировать его в таблица_пулов[].
     * Вернуть пусто при неудаче.
     */
    Пул *новыйПул(т_мера члостр, bool объектБольшой)
    {
        Пул*  пул;
        Пул** новтаблица_пулов;
        т_мера новпулы;
        т_мера инд;

        //debug(НА_КОНСОЛЬ) скажифнс("************Gcx::новыйПул(члостр = %d)****************\n", члостр);

        // Round up to РАЗМЕР_ПОДАЧИ pages
        члостр = (члостр + (РАЗМЕР_ПОДАЧИ/РАЗМЕР_СТРАНИЦЫ) - 1) & ~(РАЗМЕР_ПОДАЧИ/РАЗМЕР_СТРАНИЦЫ - 1);

        // Minimum of РАЗМЕР_ПУЛА
        if (члостр < РАЗМЕР_ПУЛА/РАЗМЕР_СТРАНИЦЫ)
            члостр = РАЗМЕР_ПУЛА/РАЗМЕР_СТРАНИЦЫ;
        else if (члостр > РАЗМЕР_ПУЛА/РАЗМЕР_СТРАНИЦЫ)
        {   // Give us 150% of requested размер, so there's room to extend
            auto n = члостр + (члостр >> 1);
            if (n < т_мера.max/РАЗМЕР_СТРАНИЦЫ)
                члостр = n;
        }

        // Allocate successively larger pools up to 8 megs
        if (чло_пулов)
        {   т_мера n;

            n = чло_пулов;
            if (n > 32)
                n = 32;         // cap пул размер at 32 megs
            else if (n > 8)
                n = 16;
            n *= (РАЗМЕР_ПУЛА / РАЗМЕР_СТРАНИЦЫ);
            if (члостр < n)
                члостр = n;
        }

        пул = cast(Пул *)cidrus.кразмести(1, Пул.sizeof);
        if (пул)
        {
            пул.иниц(члостр, объектБольшой);
            if (!пул.адрОсновы)
                goto Lerr;

            новпулы = чло_пулов + 1;
            новтаблица_пулов = cast(Пул**)cidrus.realloc(таблица_пулов, новпулы * (Пул*).sizeof);
            if (!новтаблица_пулов)
                goto Lerr;

            // Sort пул into новтаблица_пулов[]
            for (инд = 0; инд < чло_пулов; инд++)
            {
                if (пул.opCmp(новтаблица_пулов[инд]) < 0)
                     break;
            }
            cidrus.memmove(новтаблица_пулов + инд + 1, новтаблица_пулов + инд, (чло_пулов - инд) * (Пул*).sizeof);
            новтаблица_пулов[инд] = пул;

            таблица_пулов = новтаблица_пулов;
            чло_пулов = новпулы;

            минАдр = таблица_пулов[0].адрОсновы;
            максАдр = таблица_пулов[чло_пулов - 1].адрВерха;
        }
        return пул;

      Lerr:
        пул.Дтор();
        cidrus.освободи(пул);
        return null;
    }

    /**
     * Размещает страницу корзин.
     * Возвращает:
     *  0       провал
     */
    цел разместиСтраницу(Бины бин)
    {
        Пул*  пул;
        т_мера n;
        т_мера pn;
        байт*  p;
        байт*  верх;

        //debug(НА_КОНСОЛЬ) скажифнс("Gcx::разместиСтраницу(бин = %d)\n", бин);
        for (n = 0; n < чло_пулов; n++)
        {
            пул = таблица_пулов[n];
			if(пул.объектБольшой) continue;
            pn = пул.разместиСтраницы(1);
            if (pn != СБОЙ_ОП)
                goto L1;
        }
        return 0;               // failed

      L1:
        пул.таблица_страниц[pn] = cast(ббайт)бин;
		пул.свобстры--;
        // Convert page to cidrus.освободи список
        т_мера размер = бинразм[бин];
        Список **b = &бак[бин];

        p = пул.адрОсновы + pn * РАЗМЕР_СТРАНИЦЫ;
        верх = p + РАЗМЕР_СТРАНИЦЫ;
        for (; p < верх; p += размер)
        {
            (cast(Список *)p).следщ = *b;
			(cast(Список *)p).пул = пул;
            *b = cast(Список *)p;
        }
        return 1;
    }

    /**
     * Поиск в диапазоне (пространстве) памяти и выполнение пометки любых указателей  на пул СМ.
     */
    проц пометь(ук низ, ук верх, цел члорекурсий)
    {
	т_мера смещение;
        ук **p1 = cast(ук** )низ;
        ук **p2 = cast(ук** )верх;
        т_мера кэш = 0;
        бцел изменения = 0;

        //эхо("marking range: %p -> %p\n", Низ, Верх);
        for (; p1 < p2; p1++)
        {
            auto p = cast(байт *)(*p1);

            //if (журнал) debug(НА_КОНСОЛЬ) эхо("\tmark %x\n", p);
            if (p >= минАдр && p < максАдр)
            {
                if ((cast(т_мера)p & ~cast(т_мера)(РАЗМЕР_СТРАНИЦЫ-1)) == кэш)
 	            continue;

                auto пул = найдиПул(p);
                if (пул)
                {
                    смещение = cast(т_мера)(p - пул.адрОсновы);
                    т_мера битинд = void;
                    т_мера pn = смещение / РАЗМЕР_СТРАНИЦЫ;
                    Бины бин = cast(Бины)пул.таблица_страниц[pn];
					ук основа = void;
					бул точекДоОсновы = false;
                    //debug(НА_КОНСОЛЬ) эхо("\t\tfound пул %x, основа=%x, pn = %d, бин = %d, битинд = x%x\n", пул, пул.адрОсновы, pn, бин, битинд);

                    // Adjust bit to be at старт of allocated memory block
                    if (бин < Б_СТР)
                    {
					auto offsetBase = смещение & небинразм[бин];
                        битинд = offsetBase >> пул.смещНа;
						основа = пул.адрОсновы + offsetBase;
                        //debug(НА_КОНСОЛЬ) эхо("\t\tбитинд = x%x\n", битинд);
                    }
                    else if (бин == Б_СТР)
                    {
                        auto offsetBase = смещение & небинразм[бин];
                        основа = пул.адрОсновы + offsetBase;
                        точекДоОсновы = offsetBase == смещение;
                        битинд = offsetBase >> пул.смещНа;
                        //debug(НА_КОНСОЛЬ) эхо("\t\tбитинд = x%x\n", битинд);

                        кэш = cast(т_мера)p & ~cast(т_мера)(РАЗМЕР_СТРАНИЦЫ-1);
                    }
                    else if (бин == Б_СТРПЛЮС)
                    {
                        pn -= пул.смещБСтр[pn];
                        основа = пул.адрОсновы + (pn * РАЗМЕР_СТРАНИЦЫ);
                        битинд = pn * (РАЗМЕР_СТРАНИЦЫ >> пул.смещНа);

                        кэш = cast(т_мера)p & ~cast(т_мера)(РАЗМЕР_СТРАНИЦЫ-1);                 
                    }
                    else
                    {
                        // Don't пометь биты in Б_ОСВОБ or Б_НЕПОДАНО pages
                        continue;
                    }
					
					if(пул.безнутра.члобит && !точекДоОсновы && пул.безнутра.тестируй(битинд))
                    {
                        continue;
                    }

                    //debug(НА_КОНСОЛЬ) эхо("\t\tmark(x%x) = %d\n", битинд, пул.пометь.тестируй(битинд));
                    if (!пул.пометь.тестУст(битинд))
                    {
                                  
                        if (!пул.нескан.тестируй(битинд))
                        {
                          
								  if(члорекурсий == 0) {
                                // Then we've got a really deep heap graph.
                                // Start marking stuff to be scanned when we
                                // traverse the heap again next time, to save
                                // stack space.
                                пул.скан.установи(битинд);
                                изменения = 1;
                                пул.новИзмы = true;
                            } else {
                                // Directly recurse пометь() to prevent having
                                // to traverse the heap O(D) times where D
                                // is the max depth of the heap graph.
                                if (бин < Б_СТР)
                                {
                                    пометь(основа, основа + бинразм[бин], члорекурсий - 1);
                                }
                                else
                                {
                                    auto u = пул.смещБСтр[pn];
                                    пометь(основа, основа + u * РАЗМЕР_СТРАНИЦЫ, члорекурсий - 1);
                                }
                            }
                        }
                      debug (LOGGING)  журнал_родитель(сентинель_добавь(пул.адрОсновы +( битинд << пул.смещНа)), сентинель_добавь(низ));
                    }
                }
            }
        }
        любизмы |= изменения;
    }
	
		/**
	 * Перегрузка "пометь" для его начального вызова.
     */
    проц пометь(ук низ, ук верх)
	{
        пометь(низ, верх, МАКС_РЕКУРСИЙ_МЕЧЕНИЯ);
    }
    /**
     *
     */
    т_мера полная_уборка(ук верхСтэка)
    {
        т_мера n;
        Пул*  пул;

        debug(COLLECT_PRINTF) эхо("Gcx.fullcollect()\n");
        if (пущен)
            throw new Exception("Неверная операция с памятью", __FILE__, __LINE__);
        пущен = 1;

        нить_заморозьВсе();
		if (stdrus.Нить.члонн > 0)stdrus.Нить.паузаВсем();

        ключ_кэшированного_размера = ключ_кэшированного_размера.init;
        знач_кэшированного_размера = знач_кэшированного_размера.init;
        ключ_кэшированной_инфо = ключ_кэшированной_инфо.init;
        знач_кэшированной_инфо = знач_кэшированной_инфо.init;

        любизмы = 0;
        for (n = 0; n < чло_пулов; n++)
        {
            пул = таблица_пулов[n];
            пул.пометь.обнули();
            пул.скан.обнули();
            if(!пул.объектБольшой) пул.своббиты.обнули();
        }

        // Mark each cidrus.освободи entry, so it doesn't get scanned
        for (n = 0; n < Б_СТР; n++)
        {
            for (Список *список = бак[n]; список; список = список.следщ)
            {
                пул = найдиПул(список);
                assert(пул);
                пул.своббиты.установи(cast(т_мера)(cast(байт*)список - пул.адрОсновы) / 16);
            }
        }

        for (n = 0; n < чло_пулов; n++)
        {
            пул = таблица_пулов[n];
			пул.новИзмы = false;
			if(!пул.объектБольшой)
            {
            пул.пометь.копируй(&пул.своббиты);
			}
        }

        //ртСканируйСтатДан( &пометь );
		


        version (МНОГОПОТОЧНАЯ)
        {
            if (!безСтэка)
            {
                // Scan stacks and registers for each paused thread
              нить_сканируйВсе( &this.пометь, верхСтэка );
            }
        }
        else
        {
            if (!безСтэка)
            {
                // Scan stack for main thread
                debug(НА_КОНСОЛЬ) эхо(" scan niz steka = %x, top = %x\n", верхСтэка, низСтэка);
                version (СТЭК_РАСТЁТ_ВНИЗ)
                    пометь(верхСтэка, низСтэка);
                else
                    пометь(низСтэка, верхСтэка);
            }
        }

        // Scan корни[]
        debug(COLLECT_PRINTF) эхо("scan korni[]\n");
        пометь(корни, корни + члокорней);

        // Scan пространства[]
        debug(COLLECT_PRINTF) эхо("scan prostranstva[]\n");
        //журнал++;
        for (n = 0; n < члопространств; n++)
        {
            debug(COLLECT_PRINTF) эхо("\t%x .. %x\n", пространства[n].Низ, пространства[n].Верх);
            пометь(пространства[n].Низ, пространства[n].Верх);
        }
        //журнал--;

        debug(COLLECT_PRINTF) эхо("\tscan heap\n");
		цел nTraversals;
        while (любизмы)
        {
            
            for (n = 0; n < чло_пулов; n++)
            {
                пул = таблица_пулов[n];
				пул.старИзмы = пул.новИзмы;
                пул.новИзмы = false;
			}
			любизмы = 0;
			
			for (n = 0; n < чло_пулов; n++)
            {
				пул = таблица_пулов[n];
                if(!пул.старИзмы) continue;
			
				auto смещНа = пул.смещНа;
                auto носнова = пул.скан.основа();
                auto нверх = носнова + пул.скан.члослов;
                for (auto b = носнова; b < нверх;)
                {
                    auto bitm = *b;
                    if (!bitm)
                    {   b++;
                        continue;
                    }
                    *b = 0;

                    auto o = пул.адрОсновы + (b - носнова) * ((typeof(bitm).sizeof*8) << смещНа);
					
					auto firstset = std.intrinsic.bsf(bitm);
                    bitm >>= firstset;
                    o += firstset << смещНа;
					
					 while(bitm)
                    {
                        auto pn = cast(т_мера)(o - пул.адрОсновы) / РАЗМЕР_СТРАНИЦЫ;
                        auto бин = cast(Бины)пул.таблица_страниц[pn];
                        if (бин < Б_СТР)
                        {
                            пометь(o, o + бинразм[бин]);
                        }
                        else if (бин == Б_СТР)
                        {
                            auto u = пул.смещБСтр[pn];
                            пометь(o, o + u * РАЗМЕР_СТРАНИЦЫ);
                        }

                        bitm >>= 1;
                        auto члобит = std.intrinsic.bsf(bitm);
                        bitm >>= члобит;
                        o += (члобит + 1) << смещНа;
                    }
                }
            }
        }

		//thread_processGCMarks();
        нить_разморозьВсе();
        if (stdrus.Нить.члонн > 0) stdrus.Нить.возобновиВсе();
/+
        debug(PROFILING)
        {
            stop = clock();
            markTime += (stop - start);
            start = stop;
        }
+/
        // Free up everything not marked
        debug(COLLECT_PRINTF) эхо("\tfree'ing\n");
        т_мера освобождённые_стр = 0;
        т_мера освобождено = 0;
        for (n = 0; n < чло_пулов; n++)
        {   т_мера pn;

            пул = таблица_пулов[n];
            auto члопереданных = пул.члопереданных;

            if(пул.объектБольшой)
            {
                for(pn = 0; pn < члопереданных; pn++)
                {
                    Бины бин = cast(Бины)пул.таблица_страниц[pn];
                    if(бин > Б_СТР) continue;
                    т_мера битинд = pn;

                    if (!пул.пометь.тестируй(битинд))
                    {   байт *p = пул.адрОсновы + pn * РАЗМЕР_СТРАНИЦЫ;

                        сентинель_Инвариант(сентинель_добавь(p));
                        if (пул.финалы.члобит && пул.финалы.тестСброс(битинд))
                            rt_finalize_gc(сентинель_добавь(p));
                        удалиБиты(пул, битинд, ПАтрБлока.ВсеБиты ^ ПАтрБлока.Финализовать);

                        debug(COLLECT_PRINTF) эхо("\tcollecting big %p\n", p);
                        журнал_освободи(сентинель_добавь(p));
                        пул.таблица_страниц[pn] = Б_ОСВОБ;
                        if(pn < пул.стартПоиска) пул.стартПоиска = pn;
                        освобождённые_стр++;
                        пул.свобстры++;

                        debug (MEMSTOMP) memset(p, 0xF3, РАЗМЕР_СТРАНИЦЫ);
                        while (pn + 1 < члопереданных && пул.таблица_страниц[pn + 1] == Б_СТРПЛЮС)
                        {
                            pn++;
                            пул.таблица_страниц[pn] = Б_ОСВОБ;

                            // Don't need to update стартПоиска here because
                            // pn is guaranteed to be greater than last time
                            // we updated it.

                            пул.свобстры++;
                            освобождённые_стр++;

                            debug (MEMSTOMP)
                            {   p += РАЗМЕР_СТРАНИЦЫ;
                                memset(p, 0xF3, РАЗМЕР_СТРАНИЦЫ);
                            }
                        }
                    }
                }

                continue;
            }
            else
            {

                for (pn = 0; pn < члопереданных; pn++)
                {
                    Бины бин = cast(Бины)пул.таблица_страниц[pn];

                    if (бин < Б_СТР)
                    {
                        auto   размер = бинразм[бин];
                        байт *p = пул.адрОсновы + pn * РАЗМЕР_СТРАНИЦЫ;
                        байт *верх = p + РАЗМЕР_СТРАНИЦЫ;
                        т_мера битинд = pn * (РАЗМЕР_СТРАНИЦЫ/16);
                        т_мера битстрайд = размер / 16;

                        СМБиты.т_слово к_сбросу;
                        т_мера стартСброса = (битинд >> СМБиты.СДВИГ_БИТ) + 1;
                        т_мера индСброса;

                        for (; p < верх; p += размер, битинд += битстрайд, индСброса += битстрайд)
                        {
                            if(индСброса > СМБиты.БИТ_НА_СЛОВО - 1)
                            {
                                if(к_сбросу)
                                {
                                    Gcx.УдалиБитыМал(пул, стартСброса, к_сбросу);
                                    к_сбросу = 0;
                                }

                                стартСброса = (битинд >> СМБиты.СДВИГ_БИТ) + 1;
                                индСброса = битинд & СМБиты.МАСКА_БИТ;
                            }

                            if (!пул.пометь.тестируй(битинд))
                            {
                                сентинель_Инвариант(сентинель_добавь(p));

                                пул.своббиты.установи(битинд);
                                if (пул.финалы.члобит && пул.финалы.тестируй(битинд))
                                    rt_finalize_gc(сентинель_добавь(p));
                                к_сбросу |= СМБиты.БИТЫ_1 << индСброса;

                                Список *список = cast(Список *)p;
                                debug(PRINTF) эхо("\tcollecting %p\n", список);
                                журнал_освободи(сентинель_добавь(список));

                                debug (MEMSTOMP) memset(p, 0xF3, размер);

                                освобождено += размер;
                            }
                        }

                        if(к_сбросу)
                        {
                            Gcx.УдалиБитыМал(пул, стартСброса, к_сбросу);
                        }
                    }
                }
            }
        }

        debug(PROFILING)
        {
            stop = clock();
            sweepTime += (stop - start);
            start = stop;
        }

        // Zero buckets
        бак[] = null;

        // Free complete pages, rebuild free список
        debug(COLLECT_PRINTF) эхо("\tfree complete pages\n");
        т_мера восстановленные_стр = 0;
        for (n = 0; n < чло_пулов; n++)
        {   т_мера pn;
            т_мера члопереданных;

            пул = таблица_пулов[n];
            if(пул.объектБольшой) continue;
            члопереданных = пул.члопереданных;
            for (pn = 0; pn < члопереданных; pn++)
            {
                Бины   бин = cast(Бины)пул.таблица_страниц[pn];
                т_мера битинд;
                т_мера u;

                if (бин < Б_СТР)
                {
                    т_мера размер = бинразм[бин];
                    т_мера битстрайд = размер / 16;
                    т_мера бит_ова = pn * (РАЗМЕР_СТРАНИЦЫ / 16);
                    т_мера bittop = бит_ова + (РАЗМЕР_СТРАНИЦЫ / 16);
                    байт*  p;

                    битинд = бит_ова;
                    for (битинд = бит_ова; битинд < bittop; битинд += битстрайд)
                    {   if (!пул.своббиты.тестируй(битинд))
                            goto Lnotfree;
                    }
                    пул.таблица_страниц[pn] = Б_ОСВОБ;
                    if(pn < пул.стартПоиска) пул.стартПоиска = pn;
                    пул.свобстры++;
                    восстановленные_стр++;
                    continue;

                 Lnotfree:
                    p = пул.адрОсновы + pn * РАЗМЕР_СТРАНИЦЫ;
                    for (u = 0; u < РАЗМЕР_СТРАНИЦЫ; u += размер)
                    {   битинд = бит_ова + u / 16;
                        if (пул.своббиты.тестируй(битинд))
                        {   Список *список;

                            список = cast(Список *)(p + u);
                            if (список.следщ != бак[бин])       // avoid unnecessary writes
                                список.следщ = бак[бин];
                            список.пул = пул;
                            бак[бин] = список;
                        }
                    }
                }
            }
        }

        debug(PROFILING)
        {
            stop = clock();
            recoverTime += (stop - start);
        }

        debug(COLLECT_PRINTF) эхо("\trecovered pages = %d\n", восстановленные_стр);
        debug(COLLECT_PRINTF) эхо("\tfree'd %u bytes, %u pages from %u pools\n", освобождено, освобождённые_стр, чло_пулов);

        пущен = 0; // only clear on success

        return освобождённые_стр + восстановленные_стр;
    }

    /**
     * Возвращает число заполненных страниц, высвобожденных функцией cidrus.освободи.
     */
    т_мера полная_уборка()
    {    
        // The purpose of the 'shell' is to ensure all the registers
        // get put on the stack so they'll be scanned
        ук sp;
        т_мера результат;
        version (GNU)
        {
            __builtin_unwind_init();
            sp = & sp;
        }
        else version (D_InlineAsm_X86)
        {
            asm
            {
                pushad              ;
                mov sp[EBP],ESP     ;
            }
        }
        else version (D_InlineAsm_X86_64)
        {
            asm
            {
                push RAX ;
                push RBX ;
                push RCX ;
                push RDX ;
                push RSI ;
                push RDI ;
                push RBP ;
                push R8  ;
                push R9  ;
                push R10  ;
                push R11  ;
                push R12  ;
                push R13  ;
                push R14  ;
                push R15  ;
                push RAX ;   // 16 байт align the stack
                mov sp[RBP],RSP     ;
            }
        }
        else
        {
            static assert(false, "Архитектура не поддерживается.");
        }

        результат = полная_уборка(sp);

        version (GNU)
        {
            // registers will be popped automatically
        }
        else version (D_InlineAsm_X86)
        {
            asm
            {
                popad;
            }
        }
        else version (D_InlineAsm_X86_64)
        {
            asm
            {
                pop RAX ;   // 16 байт align the stack
                pop R15  ;
                pop R14  ;
                pop R13  ;
                pop R12  ;
                pop R11  ;
                pop R10  ;
                pop R9  ;
                pop R8  ;
                pop RBP ;
                pop RDI ;
                pop RSI ;
                pop RDX ;
                pop RCX ;
                pop RBX ;
                pop RAX ;
            }
        }
        else
        {
            static assert(false, "Архитектура не поддерживается.");
        }
        return результат;
    }
	
/**
     * Возвращает true, если указатель подлежит сборке.  Вызывается только
     * по указателю на основу блока.
     *
     * Внимание! Вызывать следует только когда
	 * полная_сборка блокировала всё остальное.
     */
    bool идётУборка(void *p)
    {
        // first, we find the Pool this block is in, then check to see if the
        // mark bit is clear.
        auto пул = найдиПул(p);
        if(пул)
        {
            auto смещение = cast(т_мера)(p - пул.адрОсновы);
            auto pn = смещение / РАЗМЕР_СТРАНИЦЫ;
            auto бины = cast(Бины)пул.таблица_страниц[pn];
            if(бины <= Б_СТР)
            {
                assert(p == cast(void*)((cast(т_мера)p) & небинразм[бины]));
                // return true if the block is not marked.
                return !(пул.пометь.тестируй(смещение >> пул.смещНа));
            }
        }
        return false; // not collecting or pointer is a valid argument.
    }
				
    /**
     *
     */
    бцел дайБиты(Пул* пул, т_мера битинд)
    in
    {
        assert( пул );
    }
    body
    {
        бцел биты;

        if (пул.финалы.члобит &&
            пул.финалы.тестируй(битинд))
            биты |= ПАтрБлока.Финализовать;
        if (пул.нескан.тестируй(битинд))
            биты |= ПАтрБлока.НеСканировать;
			        if (пул.безнутра.члобит && пул.безнутра.тестируй(битинд))
            биты |= ПАтрБлока.БезНутра;
//       if (пул.неперем.члобит &&
//            пул.неперем.тестируй(битинд))
//            биты |= ПАтрБлока.НеПеремещать;
        if (пул.мождоб.тестируй(битинд))
            биты |= ПАтрБлока.МожноДобавить;
        return биты;
    }

    /**
     *
     */
    проц устБиты(Пул* пул, т_мера битинд, бцел маска)
    in
    {
        assert( пул );
    }
    body
    {
                // Calculate the маска and bit смещение once and then use it to
        // set all of the bits we need to set.
        auto индексДанных = 1 + (битинд >> СМБиты.СДВИГ_БИТ);
        auto битСмещение = битинд & СМБиты.МАСКА_БИТ;
        auto orWith = СМБиты.БИТЫ_1 << битСмещение;

        if (маска & ПАтрБлока.Финализовать)
        {
            if (!пул.финалы.члобит)
                пул.финалы.размести(пул.пометь.члобит);
            пул.финалы.данные[индексДанных] |= orWith;
        }
        if (маска & ПАтрБлока.НеСканировать)
        {
            пул.нескан.данные[индексДанных] |= orWith;
        }
//        if (маска & ПАтрБлока.NO_MOVE)
//        {
//            if (!пул.неперем.члобит)
//                пул.неперем.alloc(пул.пометь.члобит);
//            пул.неперем.данные[индексДанных] |= orWith;
//        }
        if (маска & ПАтрБлока.МожноДобавить)
        {
            пул.мождоб.данные[индексДанных] |= orWith;
        }

        if (пул.объектБольшой && (маска & ПАтрБлока.БезНутра))
        {
            if(!пул.безнутра.члобит)
                пул.безнутра.размести(пул.пометь.члобит);
            пул.безнутра.данные[индексДанных] |= orWith;
        }
    }

    /**
     *
     */
    проц удалиБиты(Пул* пул, т_мера битинд, бцел маска)
    in
    {
        assert( пул );
    }
    body
    {
        auto индексДанных =  1 + (битинд >> СМБиты.СДВИГ_БИТ);
        auto битСмещение = битинд & СМБиты.МАСКА_БИТ;
        auto оставить = ~(СМБиты.БИТЫ_1 << битСмещение);

        if (маска & ПАтрБлока.Финализовать && пул.финалы.члобит)
            пул.финалы.данные[индексДанных] &= оставить;
        if (маска & ПАтрБлока.НеСканировать)
            пул.нескан.данные[индексДанных] &= оставить;
//        if (маска & ПАтрБлока.NO_MOVE && пул.nomove.члобит)
//            пул.nomove.данные[индексДанных] &= оставить;
        if (маска & ПАтрБлока.МожноДобавить)
            пул.мождоб.данные[индексДанных] &= оставить;
        if (пул.безнутра.члобит && (маска & ПАтрБлока.БезНутра))
            пул.безнутра.данные[индексДанных] &= оставить;
    }

	 void УдалиБитыМал(Пул* пул, т_мера индексДанных, СМБиты.т_слово к_сбросу)
    in
    {
        assert(пул);
    }
    body
    {
        auto оставить = ~к_сбросу;
        if (пул.финалы.члобит)
            пул.финалы.данные[индексДанных] &= оставить;

        пул.нескан.данные[индексДанных] &= оставить;

//        if (пул.nomove.члобит)
//            пул.nomove.данные[индексДанных] &= оставить;

        пул.мождоб.данные[индексДанных] &= оставить;

        if (пул.безнутра.члобит)
            пул.безнутра.данные[индексДанных] &= оставить;
    }

    /***** Детектор Утечки ******/


    debug (LOGGING)
    {
        МассивЖурналов текущий;
        МассивЖурналов предыдущ;


        проц журнал_иниц()
        {
            //debug(НА_КОНСОЛЬ) эхо("+журнал_иниц()\n");
            текущий.резервируй(1000);
            предыдущ.резервируй(1000);
            //debug(НА_КОНСОЛЬ) эхо("-журнал_иниц()\n");
        }


        проц журнал_празмести(ук p, т_мера размер)
        {
            //debug(НА_КОНСОЛЬ) эхо("+журнал_празмести(p = %x, размер = %d)\n", p, размер);
            Журнал журнал;

            журнал.p = p;
            журнал.размер = размер;
            журнал.строка = СМ.строка;
            журнал.файл = СМ.файл;
            журнал.родитель = null;

            СМ.строка = 0;
            СМ.файл = null;

            текущий.сунь(журнал);
            //debug(НА_КОНСОЛЬ) эхо("-журнал_празмести()\n");
        }


        проц журнал_освободи(ук p)
        {
            //debug(НА_КОНСОЛЬ) эхо("+журнал_освободи(%x)\n", p);
            т_мера инд;

            инд = текущий.найди(p);
            if (инд == СБОЙ_ОП)
            {
                debug(НА_КОНСОЛЬ) эхо("cidrus.освободи'ing unallocated memory %x\n", p);
            }
            else
                текущий.удали(инд);
            //debug(НА_КОНСОЛЬ) эхо("-журнал_освободи()\n");
        }


        проц журнал_сборка()
        {
            //debug(НА_КОНСОЛЬ) эхо("+журнал_сборка()\n");
            // Print everything in текущий that is not in предыдущ

            debug(НА_КОНСОЛЬ) эхо("New pointers this cycle: --------------------------------\n");
            т_мера использовано = 0;
            for (т_мера инд = 0; инд < текущий.разм; инд++)
            {
                т_мера j;

                j = предыдущ.найди(текущий.данные[инд].p);
                if (j == СБОЙ_ОП)
                    текущий.данные[инд].выведи();
                else
                    использовано++;
            }

            debug(НА_КОНСОЛЬ) эхо("Vse korni dannogo cykla: --------------------------------\n");
            for (т_мера инд = 0; инд < текущий.разм; инд++)
            {
                ук p;
                т_мера j;

                p = текущий.данные[инд].p;
                if (!найдиПул(текущий.данные[инд].родитель))
                {
                    j = предыдущ.найди(текущий.данные[инд].p);
                    if (j == СБОЙ_ОП)
                        debug(НА_КОНСОЛЬ) эхо("N");
                    else
                        debug(НА_КОНСОЛЬ) эхо(" ");;
                    текущий.данные[инд].выведи();
                }
            }

            debug(НА_КОНСОЛЬ) эхо("Used = %d-------------------------------------------------\n", использовано);
            предыдущ.копируй(&текущий);

            debug(НА_КОНСОЛЬ) эхо("-zhurnal_sborka()\n");
        }


        проц журнал_родитель(ук p, ук родитель)
        {
            //debug(НА_КОНСОЛЬ) эхо("+журнал_родитель()\n");
            т_мера инд;

            инд = текущий.найди(p);
            if (инд == СБОЙ_ОП)
            {
                debug(НА_КОНСОЛЬ) эхо("родитель'ing unallocated memory %x, родитель = %x\n", p, родитель);
                Пул *пул;
                пул = найдиПул(p);
                assert(пул);
                т_мера смещение = cast(т_мера)(p - пул.адрОсновы);
                т_мера битинд;
                т_мера pn = смещение / РАЗМЕР_СТРАНИЦЫ;
                Бины бин = cast(Бины)пул.таблица_страниц[pn];
                битинд = (смещение & небинразм[бин]);
                debug(НА_КОНСОЛЬ) эхо("\tbin = %d, смещение = x%x, битинд = x%x\n", бин, смещение, битинд);
            }
            else
            {
                текущий.данные[инд].родитель = родитель;
            }
            //debug(НА_КОНСОЛЬ) эхо("-журнал_родитель()\n");
        }

    }
    else
    {
        проц журнал_иниц() { }
        проц журнал_празмести(ук p, т_мера размер) { }
        проц журнал_освободи(ук p) { }
        проц журнал_сборка() { }
        проц журнал_родитель(ук p, ук родитель) { }
    }
}


/* ============================ Пул  =============================== */


struct Пул
{
    байт* адрОсновы;
    байт* адрВерха;
    СМБиты пометь;        // уже сканированные записи, либо не подлежащие сканированию
    СМБиты скан;        // нуждающиеся в сканировании записи
    СМБиты своббиты;    // записи в списке высвобождения
    СМБиты финалы;      // записи, для которых нужен запуст финализатора
    СМБиты нескан;      // записи, не подлежащие сканированию

    т_мера члостр;
    т_мера члопереданных;    // члопереданных <= члостр
    ббайт* таблица_страниц;
	
	СМБиты мождоб;
	СМБиты безнутра; 
	т_мера свобстры;
	
	бул объектБольшой;
    бул старИзмы;  
    бул новИзмы; 

    бцел* смещБСтр;
	т_мера стартПоиска;
	
	байт *дайАдрОсновы(){return адрОсновы;}
	байт *дайАдрВерха(){return адрВерха;}
	ббайт *дайТаблицуСтраниц(){return таблица_страниц;}

    проц иниц(т_мера члостр, бул объектБольшой)
    {
		this.объектБольшой = объектБольшой;
        т_мера размерПула;

        //debug(НА_КОНСОЛЬ) эхо("Пул::Пул(%u)\n", члостр);
        размерПула = члостр * РАЗМЕР_СТРАНИЦЫ;
        assert(размерПула >= РАЗМЕР_ПУЛА);
        адрОсновы = cast(байт *)ос_памВкарту(размерПула);

        // Some of the code depends on page alignment of memory pools
        assert((cast(т_мера)адрОсновы & (РАЗМЕР_СТРАНИЦЫ - 1)) == 0);

        if (!адрОсновы)
        {
            //debug(НА_КОНСОЛЬ) эхо("СМ fail: размерПула = x%x, errno = %d\n", размерПула, errno);
            //debug(НА_КОНСОЛЬ) эхо("message = '%s'\n", sys_errсписок[errno]);

            члостр = 0;
            размерПула = 0;
        }
        //assert(адрОсновы);
        адрВерха = адрОсновы + размерПула;
		 auto div = this.divisor;
        auto члобит = cast(т_мера)размерПула / div;
		
        пометь.размести(cast(т_мера)члобит);
        скан.размести(cast(т_мера) члобит);
		
		 if(!объектБольшой)
        {
        своббиты.размести(cast(т_мера)члобит);
		}
        нескан.размести(cast(т_мера)члобит);
		мождоб.размести(члобит);

        таблица_страниц = cast(ббайт*)cidrus.празмести(члостр);
        if (!таблица_страниц)
            throw new ВнеПамИскл();
			
		 if(объектБольшой)
        {
            смещБСтр = cast(бцел*)cidrus.празмести(члостр * бцел.sizeof);
            if (!смещБСтр)
                throw new ВнеПамИскл();
        }
        cidrus.memset(таблица_страниц, Б_НЕПОДАНО, члостр);

        this.члостр = члостр;
		this.свобстры = члостр;
        члопереданных = 0;
    }


    проц Дтор()
    {
        if (адрОсновы)
        {
            цел результат;

            if (члопереданных)
            {
                результат = ос_памДекоммит(адрОсновы, 0, члопереданных * РАЗМЕР_СТРАНИЦЫ);
                assert(результат == 0);
                члопереданных = 0;
            }

            if (члостр)
            {
                результат = ос_памИЗкарты(адрОсновы, члостр * РАЗМЕР_СТРАНИЦЫ);
				assert(результат == 0);
                члостр = 0;
            }

            адрОсновы = null;
            адрВерха = null;
        }
        if (таблица_страниц)
            cidrus.освободи(таблица_страниц);
		
		         if(смещБСтр)
            cidrus.освободи(смещБСтр);

        пометь.Дтор();
        скан.Дтор();
		if(объектБольшой)
        {
            безнутра.Дтор();
        }
        else
        {
        своббиты.Дтор();
		}
        финалы.Дтор();
        нескан.Дтор();
		мождоб.Дтор();
    }


    проц Invariant() { }


    invariant
    {
     инвариант();        
    }

private	проц инвариант()
	{
	if (адрОсновы)
        {
            assert(адрОсновы + члостр * РАЗМЕР_СТРАНИЦЫ == адрВерха, "Первый ассёрт инварианта Пула СМ");
            assert(члопереданных <= члостр, "Второй ассёрт инварианта Пула СМ");
        }

        for (т_мера инд = 0; инд < члостр; инд++)
        {   Бины бин = cast(Бины)таблица_страниц[инд];

            assert(бин < Б_МАКС, "Третий ассёрт инварианта Пула СМ");
        }
	}
	
	private т_мера divisor()
    {
        // NOTE: Since this is called by initialize it must be private or
        //       invariant() will be called and fail.
        return объектБольшой ? РАЗМЕР_СТРАНИЦЫ : 16;
    }
	
	бцел смещНа()
    {
        return объектБольшой ? 12 : 4;
    }
	
	проц обновиСмещения(т_мера откуда)
    {
        assert(таблица_страниц[откуда] == Б_СТР);
        т_мера pn = откуда + 1;
        for(бцел смещение = 1; pn < члопереданных; pn++, смещение++)
        {
            if(таблица_страниц[pn] != Б_СТРПЛЮС) break;
            смещБСтр[pn] = смещение;
        }

        // Store the размер of the block in смещБСтр[откуда].
        смещБСтр[откуда] = cast(бцел) (pn - откуда);
    }

    /**
     * Размещает n страниц в Пул.
     * Возвращает СБОЙ_ОП при провале.
     */
    т_мера разместиСтраницы(т_мера n)
    {
	
	if(свобстры < n) return СБОЙ_ОП;
        т_мера инд;
        т_мера n2;

        //debug(НА_КОНСОЛЬ) эхо("Пул::разместиСтраницы(n = %d)\n", n);
        n2 = n;
        for (инд = стартПоиска; инд < члопереданных; инд++)
        {
            if (таблица_страниц[инд] == Б_ОСВОБ)
            {
			
                if(таблица_страниц[стартПоиска] < Б_ОСВОБ)
                {
                    стартПоиска = инд + (!объектБольшой);
                }

                if (--n2 == 0)
                {   //debug(PRINTF) эхо("\texisting pn = %d\n", инд - n + 1);
                    return инд - n + 1;
                }
            }
            else
			{
            n2 = n;
			if(таблица_страниц[инд] == Б_СТР)
                {
                    // Then we have the смещение information.  We can skip a
                    // whole bunch of stuff.
                    инд += смещБСтр[инд] - 1;
                }
            }
        }

        if(таблица_страниц[стартПоиска] < Б_ОСВОБ)
        {
            стартПоиска = члопереданных;
        }
        return увеличьСтраницы(n);
    }

    /**
     * Расширяет Пул на n страниц.
     * При провале возвращает СБОЙ_ОП.
     */
    т_мера увеличьСтраницы(т_мера n)
    {
        //debug(НА_КОНСОЛЬ) эхо("Пул::увеличьСтраницы(n = %d)\n", n);
        if (члопереданных + n <= члостр)
        {
            т_мера к_передаче;

            к_передаче = (n + (РАЗМЕР_ПОДАЧИ/РАЗМЕР_СТРАНИЦЫ) - 1) & ~(РАЗМЕР_ПОДАЧИ/РАЗМЕР_СТРАНИЦЫ - 1);
            if (члопереданных + к_передаче > члостр)
                к_передаче = члостр - члопереданных;
            //debug(НА_КОНСОЛЬ) эхо("\tlooking to commit %d more pages\n", к_передаче);
            //fflush(stdout);
            if (ос_памКоммит(адрОсновы, члопереданных * РАЗМЕР_СТРАНИЦЫ, к_передаче * РАЗМЕР_СТРАНИЦЫ) == 0)
            {
                cidrus.memset(таблица_страниц + члопереданных, Б_ОСВОБ, к_передаче);
                auto инд = члопереданных;
                члопереданных += к_передаче;

                while (инд && таблица_страниц[инд - 1] == Б_ОСВОБ)
                    инд--;

                return инд;
            }
            //debug(НА_КОНСОЛЬ) эхо("\tfailed to commit %d pages\n", к_передаче);
        }

        return СБОЙ_ОП;
    }
	
	  /**
     * расширяет диапазон страниц до n страниц как минимум.Возвращает
     * число добавленных страниц.
     */
    т_мера увеличьЧлоСтрДо(т_мера n)
    {
        //debug(PRINTF) эхо("Pool::увеличьЧлоСтрДо(n = %d)\n", n);
        if (члопереданных + n > члостр)
            n = члостр - члопереданных;
        т_мера к_передаче;

        к_передаче = (n + (РАЗМЕР_ПОДАЧИ/РАЗМЕР_СТРАНИЦЫ) - 1) & ~(РАЗМЕР_ПОДАЧИ/РАЗМЕР_СТРАНИЦЫ - 1);
        if (члопереданных + к_передаче > члостр)
            к_передаче = члостр - члопереданных;
        if(к_передаче == 0)
            return 0;
        //debug(PRINTF) эхо("\tlooking to commit %d more pages\n", к_передаче);
            //fflush(stdout);
        if (ос_памКоммит(адрОсновы, члопереданных * РАЗМЕР_СТРАНИЦЫ, к_передаче * РАЗМЕР_СТРАНИЦЫ) == 0)
        {
            memset(таблица_страниц + члопереданных, Б_ОСВОБ, к_передаче);
            члопереданных += к_передаче;

            return к_передаче > n;
        }
        //debug(PRINTF) эхо("\tfailed to commit %d pages\n", к_передаче);

        return СБОЙ_ОП;
    }


    /**
     * Освобождает члостр, начиная с номерстр.
     */
    проц освободиСтраницы(т_мера номерстр, т_мера члостр)
    {
        //cidrus.memset(&таблица_страниц[номерстр], Б_ОСВОБ, члостр);
		if(номерстр < стартПоиска) стартПоиска = номерстр;

        for(т_мера инд = номерстр; инд < члостр + номерстр; инд++)
        {
            if(таблица_страниц[инд] < Б_ОСВОБ)
            {
                свобстры++;
            }

            таблица_страниц[инд] = Б_ОСВОБ;
        }
    }
	
	
    /**
     * Используется для сортировки таблица_пулов[]
     */
    цел opCmp(Пул *p2)
    {
        if (адрОсновы < p2.адрОсновы)
            return -1;
        else
        return cast(цел)(адрОсновы > p2.адрОсновы);
    }
}


/* ============================ SENTINEL =============================== */


version (SENTINEL)
{
    const т_мера SENTINEL_PRE = cast(т_мера) 0xF4F4F4F4F4F4F4F4UL; // 32 or 64 биты
    const ббайт SENTINEL_POST = 0xF5;           // 8 биты
    const бцел SENTINEL_EXTRA = 2 * т_мера.sizeof + 1;


    т_мера* сентинель_размер(ук p)  { return &(cast(т_мера *)p)[-2]; }
    т_мера* sentinel_pre(ук p)   { return &(cast(т_мера *)p)[-1]; }
    ббайт* sentinel_post(ук p) { return &(cast(ббайт *)p)[*сентинель_размер(p)]; }


    проц сентинель_иниц(ук p, т_мера размер)
    {
        *сентинель_размер(p) = размер;
        *sentinel_pre(p) = SENTINEL_PRE;
        *sentinel_post(p) = SENTINEL_POST;
    }


    проц сентинель_Инвариант(ук p)
    {
        assert(*sentinel_pre(p) == SENTINEL_PRE);
        assert(*sentinel_post(p) == SENTINEL_POST);
    }


    ук сентинель_добавь(ук p)
    {
        return p + 2 * т_мера.sizeof;
    }


    ук сентинель_отн(ук p)
    {
        return p - 2 * т_мера.sizeof;
    }
}
else
{
    const бцел SENTINEL_EXTRA = 0;


    проц сентинель_иниц(ук p, т_мера размер)
    {
    }


    проц сентинель_Инвариант(ук p)
    {
    }


    ук сентинель_добавь(ук p)
    {
        return p;
    }


    ук сентинель_отн(ук p)
    {
        return p;
    }
}

////////////////////

export extern (C) т_см смНовый()
	{
		version (all)
		{
		ук  укз;
		ClassInfo ci = СМ.classinfo;
		укз = cidrus.празмести(ci.init.length);
		(cast(байт*)укз)[0 .. ci.init.length] = ci.init[];
		//debug эхо("(gc ln 3735) Returning from gcNew all\n");
		return cast(т_см)укз;
		}
		else
		{
		//debug эхо("(gc ln 3735) Returning from gcNew else\n");
		return cast(т_см)cidrus.кразмести(1, СМ.sizeof);
		}
	}

export extern (C) проц смУдали(т_см см)
	{
		см.Дтор();
		cidrus.освободи(cast(ук )см);
	}

/////////////////////////////////////////////////////////////////////////////////
