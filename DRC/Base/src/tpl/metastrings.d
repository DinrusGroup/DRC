
// Написано на языке программирования Динрус.

/**
 * Шаблоны для проведения работы над строками при компиляции.
 *
 * Macros:
 *	WIKI = Phobos/StdMetastrings
 * Copyright:
 *	Public Domain
 */

/*
 * Authors:
 *	Walter Bright, Digital Mars, www.digitalmars.com
 *	Don Clugston
 */

module tpl.metastrings;

/**
 * Форматирует константы в текст при компиляции.
 * Аналогичен stdrus.форматируй().
 *Параметры: 
 *	A =	кортеж из констант,, к-е м.б. строками,
 *		символами или интегральными значениями.
 * Форматы:
 *	Поддерживаемыми форматами являются %s для строк и %%
 *	для символа %.
 * Пример:
 * ---
import tpl.metastrings;
import stdrus;

проц main()
{
  ткст s = Форматируй!("Arg %s = %s", "foo", 27);
  пишифнс(s); // "Arg foo = 27"
}
 * ---
 */

template Форматируй(A...)
{
    static if (A.length == 0)
	const сим[] Форматируй = "";
    else static if (is(typeof(A[0]) : сим[]))
	const сим[] Форматируй = ТекстФормата!(A[0], A[1..$]);
	//const сим[] Форматируй = ТекстФормата!(A[0]);
    else
	const сим[] Форматируй = ВТкст!(A[0]) ~ Форматируй!(A[1..$]);
}

template ТекстФормата(ткст F, A...)
{
    static if (F.length == 0)
	const сим[] ТекстФормата = Форматируй!(A);
    else static if (F.length == 1)
	const сим[] ТекстФормата = F[0] ~ Форматируй!(A);
    else static if (F[0..2] == "%s")
	const сим[] ТекстФормата = ВТкст!(A[0]) ~ ТекстФормата!(F[2..$],A[1..$]);
    else static if (F[0..2] == "%%")
	const сим[] ТекстФормата = "%" ~ ТекстФормата!(F[2..$],A);
    else static if (F[0] == '%')
	static assert(0, cast(ткст)"неопознанный формат %" ~ F[1]);
    else
	const сим[] ТекстФормата = F[0] ~ ТекстФормата!(F[1..$],A);
}

/**
 * Преобразование константного аргумента в ткст.
 */

template ВТкст(бдол U)
{
    static if (U < 10)
	const сим[] ВТкст = "" ~ cast(сим)(U + '0');
    else
	const сим[] ВТкст = ВТкст!(U / 10) ~ ВТкст!(U % 10);
}

/// описано ранее
template ВТкст(дол I)
{
    static if (I < 0)
	const сим[] ВТкст = "-" ~ ВТкст!(cast(бдол)(-I));
    else
	const сим[] ВТкст = ВТкст!(cast(бдол)I);
}

static assert(ВТкст!(0x100000000) == "4294967296");

/// описано ранее
template ВТкст(бцел U)
{
    const сим[] ВТкст = ВТкст!(cast(бдол)U);
}

/// описано ранее
template ВТкст(цел I)
{
    const сим[] ВТкст = ВТкст!(cast(дол)I);
}

/// описано ранее
template ВТкст(бкрат U)
{
    const сим[] ВТкст = ВТкст!(cast(бдол)U);
}

/// описано ранее
template ВТкст(крат I)
{
    const сим[] ВТкст = ВТкст!(cast(дол)I);
}

/// описано ранее
template ВТкст(ббайт U)
{
    const сим[] ВТкст = ВТкст!(cast(бдол)U);
}

/// описано ранее
template ВТкст(байт I)
{
    const сим[] ВТкст = ВТкст!(cast(дол)I);
}

/// описано ранее
template ВТкст(бул B)
{
    const сим[] ВТкст = B ? "да" : "нет";
}

/// описано ранее
template ВТкст(ткст S)
{
    const сим[] ВТкст = S;
}

/// описано ранее
template ВТкст(сим C)
{
    const сим[] ВТкст = "" ~ C;
}

unittest
{
    ткст s = Форматируй!("hel%slo", "world", -138, 'c', да);
    assert(s == "helworldlo-138ctrue");
}


/********
 * Разобрать беззначный целый литерал с начала ткст s.
 * Возвращает:
 *	.значение = целочисленный литерал в виде ткст,
 *	.остаток = ткст, следующий за целочисленным литералом
 * В противном случае:
 *	.значение = пусто,
 *	.остаток = s
 */

template ПарсируйБцел(ткст s)
{
    static if (s.length == 0)
    {	const сим[] значение = "";
	const сим[] остаток = "";
    }
    else static if (s[0] >= '0' && s[0] <= '9')
    {	const сим[] значение = s[0] ~ ПарсируйБцел!(s[1..$]).значение;
	const сим[] остаток = ПарсируйБцел!(s[1..$]).остаток;
    }
    else
    {	const сим[] значение = "";
	const сим[] остаток = s;
    }
}

/********
 * Parse integer literal optionally preceded by '-'
 * from the старт of ткст s.
 * возвращает:
 *	.значение = целочисленный литерал в виде ткст,
 *	.остаток = ткст, следующий за целочисленным литералом
 * В противном случае:
 *	.значение = пусто,
 *	.остаток = s
 */

template ПарсируйЦел(ткст s)
{
    static if (s.length == 0)
    {	const сим[] значение = "";
	const сим[] остаток = "";
    }
    else static if (s[0] >= '0' && s[0] <= '9')
    {	const сим[] значение = s[0] ~ ПарсируйБцел!(s[1..$]).значение;
	const сим[] остаток = ПарсируйБцел!(s[1..$]).остаток;
    }
    else static if (s.length >= 2 &&
		s[0] == '-' && s[1] >= '0' && s[1] <= '9')
    {	const сим[] значение = s[0..2] ~ ПарсируйБцел!(s[2..$]).значение;
	const сим[] остаток = ПарсируйБцел!(s[2..$]).остаток;
    }
    else
    {	const сим[] значение = "";
	const сим[] остаток = s;
    }
}

unittest
{
    assert(ПарсируйБцел!("1234abc").значение == "1234");
    assert(ПарсируйБцел!("1234abc").остаток == "abc");
    assert(ПарсируйЦел!("-1234abc").значение == "-1234");
    assert(ПарсируйЦел!("-1234abc").остаток == "abc");
}

